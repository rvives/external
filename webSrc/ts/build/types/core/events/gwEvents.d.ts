/**
 * How to construct an element on the server that responds to events:
 * 1. add data-gw-eventname="methodname", ie: '<div data-gw-click="fireEvent">'
 *   -
 *   - You can also pass a dot delimited string to use a method not on this.methods: ie:
 *     - data-gw-eventname="SouthPanel.UIMethods.toggleMinMax"
 * 2. Any additional arguments should be supplied after the method name and a space.
 *   - ie: <div data-gw-click="fireEvent add:class1 class2 class3 target:.class4">.
 *   - if you use an `argName: blah` format, then the client will build a map of argName to argString.
 *   - for the common methods, these are already defined. So addClass expects add: blah, etc.
 *     - for custom methods, it will call your method as myMethod(node, argumentMap, event);
 *   - If you want to pass custom info to a custom method and not use name: blah, just don't use any colons, and the client will execute
 *     your method as myMethod(node, entireArgString, event);
 *
 * Key event handling makes use of "key listener" objects. A key listener contains the description of
 * a key (a keyCode plus boolean modifiers, like alt, shift, ctrl), an optional enableDefault flag and
 * an action to execute. The action is either a simple method name, stored in a field called "methodName",
 * or a "createEventDescription" function that can be called to get a complete event description.
 */
import { GwDomNode, GwMap, GwPanelScope, GwContextNode, GwTypedMap, GwAction } from "../../types/gwTypes";
import { GwOrderDependantInitializableSystem } from "../util/GwOrderDependantInitializableSystem";
export declare class GwEvents extends GwOrderDependantInitializableSystem {
    getSystemName(): string;
    private eventLockCount;
    /**
     * A flag indicating to other event handlers whether the mouse has been clicked.
     * Specifically, in IE focusIn events are fired on all dom elements, we need to know
     * whether something was focused on click or by keyboard navigation
     * @type {boolean}
     */
    private mouseDown;
    /**
     * A flag that indicates whether we should handle the next double click event. The double click event is always
     * preceded by a click event generated by the first click in the double click.  If that initial click has an action
     * associated with it, we set this flag to false so that the action associated with the double click event will be
     * ignored.
     */
    private allowNextDoubleClickEvent;
    /**
     *
     * Queue for multiple events fired at the same time. Currently possible event got queued would be the action widget's mouse click
     * event following by change event which trigger a request back to server. Since focusOut happens first so the onChange event
     * will fired first, then the mouse click event will be queued and processEventQueue will be called after the page is loaded from the first
     * request.
     */
    private eventQueue;
    /**
     * Many types of event listeners do not respond to synthetically generated  We easily bypass this since all of our
     * events are handled via our 'onGlobalBlahEvent' handlers. So instead of constructing an event object and firing it,
     * or using $(el).trigger, (neither of which would be caught by the global listener, for example onchange) we can just directly
     * fire the onGlobalChangeEvent method, and pass in a fakeEvent object. Then use all the same code paths from there.
     * @param targetEl
     * @param eventName
     * @param optRelatedTargetEl
     */
    forceGlobalEvent(targetEl: GwDomNode, eventName: string, optRelatedTargetEl?: GwDomNode): void;
    /**
     * @private
     * Called on a dom node and an attribute object, to transform any matching data-gw-'event' attributes
     */
    private addAdditionalAttributeTransforms(el, attributes);
    /**
     * Catch all method to do anything when the escape key is pressed. Focus node can be checked to do specific things.
     *
     */
    escapeKeyPressed(): void;
    closeAllTemporaryUIElements(): void;
    focusQuickjump(): void;
    /**
     * @public constant
     * @type {string}
     */
    dataPrefix: string;
    /**
     * @private
     * Contains the custom transformations used to add complex additional attributes for particular data-gw-* attributes.
     * These transforms are processed after the base transforms, to ensure there's no extra attributes added by chaining.
     * ie: if a node has gw-data-hover-submenu on it, then it will end up with 4 additional attributes handling mouseenter and mouseleave.
     */
    private readonly complexAttributeTransforms;
    /**
     * @private
     *
     * All properties on this object will be given a tabindex=0 inline attribute.
     * //TODO: this object's sole purpose now is just to add tabindexes, need to change it to be that more clearly.
     */
    private readonly baseAttributeTransforms;
    /**
     * @private
     * The default suffix for any fireEvent action. This can be overriden inline for the default events methods by passing a suffix
     * argument, ie "fireEvent suffix:_other" or fireEvent suffix:null to not use a suffix. Mainly used for dev actions like PCF_RELOAD
     * @type {string}
     */
    actionSuffix: string;
    /**
     * @private
     * Use the disableEvents and enableEvents functions
     */
    private eventsEnabled;
    /**
     * @private
     * Used to convert the actual DOM event name from key to value, when we process static
     * This is primarily so that we never need to change how events are declared on the server, regardless of how we
     * decide to listen for events on the client. ie, we changed from onkeypress to onkeydown, but the server just sets
     * data-gw-key.
     *
     */
    eventsMap: GwMap;
    /**
     * Events types listed here, by our "internal event names" meaning, "key" not "onkeydown".
     * Will fire event.preventDefault if the events system finds a target that can handle the event.
     * Unless the eventDescription it finds specifically sets enableDefault: true.
     * @type {{key: boolean, copy: boolean, dragover: boolean, drop: boolean}}
     */
    private readonly disableDefaultBehaviorIfHandled;
    private navigationConfirmIsDisabled;
    possiblyAddOnBeforeUnloadHandler(): void;
    /**
     * Clears any currently registered onBeforeUnload handler
     */
    clearBeforeUnload(): void;
    /**
     * Checks whether an onBeforeUnload handler has been registered.
     */
    isBeforeUnloadRegistered(): boolean;
    /**
     * @public
     * should be called on any page reload.
     */
    orderSpecificInit(isFullReload: boolean, reloadProps: GwMap): void;
    onBeforeUnload(): string;
    onGlobalDragstartEvent(event: MouseEvent): void;
    onGlobalDragEvent(event: MouseEvent): void;
    onGlobalDragendEvent(event: MouseEvent): void;
    onGlobalDragcancelEvent(event: MouseEvent): void;
    private abstractGlobalForPostStartDragEvents(event);
    onGlobalCopyEvent(event: ClipboardEvent): void;
    onGlobalPasteEvent(event: ClipboardEvent): void;
    onGlobalCutEvent(event: ClipboardEvent): void;
    /**
     * Looks for the closest element with attribute '"data-gw-" + type' and fires abstractOnEvent normally.
     * @param event
     * @param type
     * @returns {mouseableSelfOrParent} Returns the element the event is associated with
     */
    abstractGlobalMouseEvent(event: MouseEvent, type: string, forceAllowEvent?: boolean): GwDomNode | undefined;
    onGlobalMouseoverEvent(event: MouseEvent): void;
    onGlobalMouseClickEvent(event: MouseEvent): void;
    onGlobalMouseDblClickEvent(event: MouseEvent): void;
    private mouseMoveOwner;
    /**
     * Mouse move is special because an element may want to watch for mouse move events even though
     * the mouse isn't over the element any more, in which case our usual approach of looking up the
     * DOM from the event target won't find the interested party. So we allow one system at a time
     * to register as the "mouse move owner", and they'll be sent all mouse move events until they
     * surrender their ownership.
     *
     * @param event the mouse move event
     */
    onGlobalMouseMoveEvent(event: MouseEvent): void;
    /**
     * Set the mouse move owner. The argument should be a function to be called with future mouse
     *  Returns a function that the caller can call to surrender ownership of mouse movement
     * @param newOwner a function to be called on future mouse move events
     */
    setMouseMoveOwner(newOwner: Function): Function;
    onGlobalMouseOutEvent(event: MouseEvent): void;
    private isInTouchEvent;
    isCurrentlyInTouchEvent(): boolean;
    onGlobalTouchstartEvent(event: TouchEvent): void;
    onGlobalTouchcancelEvent(event: TouchEvent): void;
    /**
     *
     * Currently we handle the following cases:
     * 1) for <select>, when the selection is changed
     * 2) textarea, input:password, input:search: input:text; during onblur if the value's been changed
     *
     * TODO: input:file, input:range slightly different?
     *       input:checkbox and input:radio may be handled differently in IE?
     *
     * The complicated part is we need to know if the element that caused the blur, (clicked or tabbed to),
     * is actually a child of the widget holding the input, meaning, the user has clicked something like the
     * autocomplete widget. In that case, we don't want to fire the onChange method.
     *
     * The only way for us to know that, is to wait for the blur event, and then run all the logic there.
     *
     * So, here, we set a flag to tell the following on blur event to run all the on change logic.
     * Unless this event is the result of a call to forceGlobalEvent, in which case we process the event normally.
     * @type {boolean}
     */
    onGlobalChangeEvent(event: Event): void;
    findEnclosingValueWidget(el: GwDomNode): GwDomNode | null;
    findEnclosingWidget(el: GwDomNode): GwDomNode | null;
    setPendingChangesOnElement(el: GwDomNode): void;
    /**
     * Returns whether or not an input has multiple child inputs
     * @param el
     * @returns {boolean}
     */
    isMultiPartInput(el: GwDomNode): boolean;
    private isImmediateChangeNodeType(node);
    /**
     * IE11 fires extra input event when focus enters or leaves an empty input with a placeholder. The
     * extra event on entry is fairly harmless but the one on leave can cause the autocomplete dropdown
     * to appear on the wrong input when tabbing between two autocomplete inputs. So watch for this
     * particular case and ignore it. For more details see:
     *
     * https://connect.microsoft.com/IE/feedback/details/810538/ie-11-fires-input-event-on-focus
     * http://jsfiddle.net/H8XTX/11/
     *
     * @param node the event target
     * @param e the event
     * @returns {boolean}
     */
    private isBogusIE11InputEvent(e);
    /**
     * Input event fires every time the value of an input changes
     * @param event
     */
    onGlobalInputEvent(event: Event): void;
    private lostFocusTimer;
    private checkForLostFocus(relatedTarget);
    private clearLostFocusTimer();
    private onLostFocus();
    /**
     * @private
     * Sets gwNavigation.lastFocused
     * Then processes the blur event
     * Then if processChangeEventInBlurEvent, process a change event
     *
     * @param event
     */
    onGlobalFocusoutEvent(event: FocusEvent): void;
    processEventQueue(): void;
    clearEventQueue(): void;
    /**
     * @private
     * Stores the currentFocus and lastFocus globals. Then fires abstractOnEvent, passing the newly set currentFocus as the node.
     * @param event
     */
    onGlobalFocusinEvent(event: FocusEvent): void;
    private handleDeferredChangeEvent(targetNode, allowNullTarget?);
    /**
     * Fires when a user drag & drops a file on a dropzone target.
     */
    onGlobalDropEvent(event: DragEvent): void;
    /**
     * Fires when a user drag a file over a dropzone target
     */
    onGlobalDragoverEvent(event: DragEvent): void;
    private abstractGlobalDragDropEvent(event, type);
    /**
     * NOTE: This is being called on every scroll event; do not put anything expensive in this method
     * NOTE: We only listen to targets that are divs.
     * @param event
     */
    onGlobalScrollEvent(event: Event): void;
    /**
     * @public
     * The event listener method placed on any elements with data-gw-"event" attributes requiring the node to listen for the event.
     * @parem node: passed to the function via inline 'this'.
     * @param event
     */
    onElementEvent(event: Event, node: GwDomNode): void;
    /**
     * @private
     * Global callback for any key event.
     * @param event
     */
    onGlobalKeyEvent(event: KeyboardEvent): void;
    private areEventsDisabled(node, e);
    private isEventEnabledOnNode(node, eventType);
    /**
     * @private
     * Given a string describing a method return the corresponding function
     * @param methodName
     * @returns {*}
     */
    private findMethod(methodName);
    /**
     * @private
     * If the node running this event includes a prompt, show the prompt and the optional
     * default value, and set the eventParam input to match the submitted value before continuing.
     * @return boolean false if the action was canceled, stopping the event
     */
    private checkForAndShowPrompt(eventDescription);
    /**
     * @private
     * Fires after any mouse click event. Closes all open submenus and datepickers
     * if the click comes from outside of the submenu or the datepicker.
     * @param target - DOM element
     */
    private doAfterAnyClick(target);
    /**
     * @private
     * This should not need to be referenced outside of this file. This is the catch all listener function for all static
     * @param node: a DOM element
     * @param e: the event object
     * @param forceAllowEvent: boolean - set to true will bypass the gw-disabled and eventsEnabled checks. Used to allow things like
     * mouseleave to let hover menus close even during a server roundtrip.
     */
    private abstractOnEvent(node, e, forceAllowEvent?);
    /**
     * @private
     * This could in theory be used elsewhere in the app, but I can't imagine where
     * Looks through the event to find one of the hundreds of possible locations various browsers store key codes
     * @param e
     * @returns {key code}
     */
    getKeyCode(e: KeyboardEvent): number | null;
    /**
     * @private
     * Checks the current focus and returns associated scope. If the focus is inside a worksheet,
     * the scope returned is "SOUTH" else we return "CENTER".
     * @returns "SOUTH" if focus is inside a worksheet else returns "CENTER"
     */
    getCurrentScope(): GwPanelScope;
    /**
     * @private
     * Checks to see if the gw-internalTools-flag info div is set to true, signalling that
     * internal tools are enabled
     * @returns true if internal tools are enabled, false if not.
     */
    internalToolsEnabled(): boolean;
    /**
     * Called by addInlineEventListenersToContainer,
     * allows systems to add processing to check every node in the dom, since we're already walking them for addInlineEventListeners
     * @param node
     */
    private doCustomSystemWorkOnEveryNodeOnPageLoad(node);
    addInlineEventListenersToContainer(contextNode: GwContextNode): void;
    /**
     * @public
     * Currently called on full or partial page reload. TODO: this could get optimized to only run on the diff nodes.
     * Iterates over every element in the dom looking for data-gw-"event" attributes, and adds the corresponding inline event listeners
     * //TODO: eventually, this could become the "walkAllDomNodesOnPageLoad" generic method.
     */
    addInlineEventListenersToDom(contextNode?: GwContextNode): void;
    processNodeForInlineEvents(node: GwDomNode): void;
    addInlineEventListenersToThisSpecificNode(el: GwDomNode): void;
    addAdditionalAttributes(node: GwDomNode): void;
    /**
     * @public
     * Enable events globally. This includes mouse, keyboard, blur, focus.  Calling enableEvents will decrement the
     * current lock count by 1 and will only enable events if the underlying lock count is <= 0.
     *
     * Lock count is incremented every time {@method disabledEvents} is called.
     *
     */
    enableEvents(): void;
    onEventsEnabled(): void;
    onEventsDisabled(): void;
    /**
     * @public
     * Disable events globally. This includes mouse, keyboard, blur, focus.  Each call to this method will increment
     * an underlying lock counter.
     */
    disableEvents(): void;
    /**
     * Indicates whether events are currently enabled.
     * @returns {boolean}
     */
    areEventsEnabled(): boolean;
    disableNavigationConfirmationUntilUserCancelsConfirm(): void;
    confirmationCancelled(): void;
    handleOnChangeMethod(onChangeMethod: string, node: GwDomNode, args: GwMap): void;
    private tempActiveId;
    /**
     * @private
     * These methods should only be called as a result of a lookup inside of gw.event.onElementEvent
     * @type {{fireEvent: this.methods.fireEvent, addClass: this.methods.addClass, removeClass: this.methods.removeClass, addAndRemoveClass: this.methods.addAndRemoveClass, toggleClass: this.methods.toggleClass, openSubMenu: this.methods.openSubMenu, closeSubMenu: this.methods.closeSubMenu, toggleSubMenu: this.methods.toggleSubMenu, resetValue: this.methods.resetValue, page: this.methods.page}}
     */
    methods: GwTypedMap<GwAction>;
}
export declare const gwEvents: GwEvents;
