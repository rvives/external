(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 235);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Catch-all for utility methods used by multiple systems.
 */
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwTypes_1 = __webpack_require__(20);
var GwPoint_1 = __webpack_require__(59);
var gwPerfAnalyzer_1 = __webpack_require__(60);
var gwEvents_1 = __webpack_require__(3);
var gwPageLoadBar_1 = __webpack_require__(128);
var gw_1 = __webpack_require__(10);
var gwAnimation_1 = __webpack_require__(57);
var gwKeys_1 = __webpack_require__(23);
var plApp_1 = __webpack_require__(29);
var gwAjax_1 = __webpack_require__(15);
var GwUtil = /** @class */ (function (_super) {
    __extends(GwUtil, _super);
    function GwUtil() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.whitespaceRegex = /[\s\u202F\u00A0]/g;
        _this.targetIdsToAnimate = [];
        _this.CSRF_PARAM_NAME = "csrfToken";
        _this._isIE11 = null;
        _this._isEdge = null;
        _this.UNIQUE_CHILD_CLASSES = [
            "gw-action--inner", "gw-action--expand-button"
        ];
        return _this;
    }
    GwUtil.prototype.getSystemName = function () {
        return "gwUtil";
    };
    GwUtil.prototype.getUtilityInfo = function (id) {
        var node = document.getElementById(id);
        if (!node) {
            return "";
        }
        if (node.hasAttribute("data-gw-info")) {
            return node.getAttribute("data-gw-info");
        }
        else if (node.hasAttribute("value")) {
            return node.getAttribute("value");
        }
        else {
            return "";
        }
    };
    GwUtil.prototype.getUtilityFlag = function (id) {
        return "true" === this.getUtilityInfo(id);
    };
    GwUtil.prototype.getUtilityJson = function (id) {
        var info = this.getUtilityInfo(id);
        return info ? JSON.parse(info) : null;
    };
    GwUtil.prototype.onLoginPage = function () {
        var locObject = this.getDomNode(".gw-location-name");
        if (locObject) {
            var locName = locObject.getAttribute("data-gw-location-name");
            // If we are on the login page, then don't bother asking for a websocket
            if (locName && locName.indexOf("Login") > -1) {
                return true;
            }
        }
        return false;
    };
    GwUtil.prototype.hasUnsavedWork = function () {
        return this.getUtilityFlag("gw-hasUnsavedWork");
    };
    /**
     * Returns a vector
     * @param el
     * @param e
     * @returns GwPoint
     */
    GwUtil.prototype.getMousePosition = function (el, e) {
        if (this.hasValue(e.pageX)) {
            return new GwPoint_1.GwPoint(e.pageX, e.pageY);
        }
        else {
            var rect = el.getBoundingClientRect();
            var root = document.documentElement;
            var x = e.clientX - rect.left - root.scrollLeft;
            var y = e.clientY - rect.top - root.scrollTop;
            return new GwPoint_1.GwPoint(x, y);
        }
    };
    GwUtil.prototype.convertIfString = function (val) {
        if (val === "true") {
            return true;
        }
        if (val === "false") {
            return false;
        }
        if (val === "undefined") {
            return undefined;
        }
        if (val === "null") {
            return null;
        }
        return val;
    };
    /**
     * @public
     *
     * @param id: the event id, including the suffix, most commonly _act.
     */
    GwUtil.prototype.fireEvent = function (id) {
        gwPerfAnalyzer_1.gwPerfAnalyzer.startRequest(id);
        gwEvents_1.gwEvents.disableEvents();
        plApp_1.gwApp.beforeEachFireEventToServer();
        gwPageLoadBar_1.gwPageLoadBar.go(20);
        $("#gw-event-source").val(id);
        $("#gw-root-form").submit(); //TODO: come back to this
        this.clearEventParam();
        gwPerfAnalyzer_1.gwPerfAnalyzer.requestSent();
    };
    /**
     * Calls the server to render children that weren't initially rendered, but are rendered as the result of
     * clicking on the element with the given id. This is how subMenuOnDemand is implemented. The server is
     * notified that the children of the element with the given id are needed and it responds with just the
     * HTML for those children. The new HTML is added into the DOM (or replaces existing HTML if the children
     * were already present for some reason). In the event of an error contacting the server the onError
     * handler is called so the caller can clean up any client side state.
     */
    GwUtil.prototype.renderDeferredChildren = function (id, onSuccess, onError) {
        var _this = this;
        gwAjax_1.gwAjax.ajaxRequest({
            __renderTarget: id
        }, function (response) {
            if (response.deferredTarget && (response.childContent || response.isEmptyContent)) {
                _this.replaceDeferred(response.deferredTarget, response.childContent, response.isEmptyContent);
                onSuccess();
            }
            else if (response.targets) {
                _this.replaceTargets(0, 0, 1, response.targets);
                onSuccess();
            }
            else {
                //TODO: @localize
                throw new Error("Invalid response to rerenderTarget, missing targets or deferredTarget and childContent: " + response);
            }
        }, function () {
            _this.replaceDeferred(id);
            onError();
        });
    };
    GwUtil.prototype.showOnDemandElement = function (id, callback) {
        var _this = this;
        var idSelector = "#" + id;
        if (!this.getDomNode(idSelector)) {
            return;
        }
        gwEvents_1.gwEvents.disableEvents();
        gwAjax_1.gwAjax.ajaxRequest({ __onDemandElementId: id }, function (response) {
            if (response.id === id) {
                _this.replaceTarget(idSelector, response.content);
                gwEvents_1.gwEvents.addInlineEventListenersToDom(_this.getDomNode(idSelector));
                gwEvents_1.gwEvents.enableEvents();
                if (callback) {
                    callback();
                }
            }
        }, function () {
            gwEvents_1.gwEvents.enableEvents();
        });
    };
    GwUtil.prototype.hideOnDemandElement = function (id) {
        var el = this.getDomNode("#" + id);
        if (el) {
            this.addClass(el, "gw-hidden");
            el.innerHTML = "";
        }
    };
    GwUtil.prototype.freeze = function (obj) {
        if (Object.freeze) {
            Object.freeze(obj);
        }
    };
    /**
     * If a widget has PostOnChange=true, this function will be called onChange()
     * Sends the current form to the server, with no specific action as the source.
     */
    GwUtil.prototype.refresh = function (id) {
        if (id === void 0) { id = ""; }
        this.setEventParam("pocTrigger", id);
        this.fireEvent("_refresh_");
    };
    GwUtil.prototype.unsavedWork = function (id, unsavedWorkItem) {
        this.setEventParam("unsavedWork", unsavedWorkItem);
        this.fireEvent(id);
    };
    GwUtil.prototype.browserAction = function (node, id, event) {
        if (gw_1.gw.browserActions[id]) {
            gw_1.gw.browserActions[id].call(node, event);
        }
        else {
            this.devlog("ERROR: No Browser Action found for RenderID: " + id);
        }
    };
    GwUtil.prototype.setEventParam = function (name, value) {
        var paramInput = $("#gw-event-param");
        paramInput.attr("name", name);
        paramInput.val(value);
    };
    GwUtil.prototype.clearEventParam = function () {
        var paramInput = $("#gw-event-param");
        paramInput.removeAttr("name");
        paramInput.removeAttr("value");
    };
    GwUtil.prototype.runAfterPageLoad = function () {
        exports.gwUtil.disableIEMenuShortcut();
        if (plApp_1.gwApp.shouldFlash) {
            exports.gwUtil.forEach(this.targetIdsToAnimate, function (id) {
                gwAnimation_1.gwAnimation.addAnimation(id, "pulse");
            });
            this.targetIdsToAnimate.length = 0;
        }
        //This is rare case to have events in eventQueue, only if there were multiple events fired at the same time(for example
        //modifying a field with PostOnChange then click on a button right away). In that case we want to process the following
        //event when the page is loaded from the first request and events are enabled again.
        gwEvents_1.gwEvents.processEventQueue();
    };
    /**
     * Work around to support Edge; during certain page transitions where a large number of DOM elements
     * get swapped quickly, the first element clicked loses it's global onClick.
     * @param classIdTagOrNode
     * @param newContent
     */
    GwUtil.prototype.replaceTarget = function (classIdTagOrNode, newContent) {
        var targetElement = this.getDomNode(classIdTagOrNode);
        if (!targetElement) {
            throw new Error(" replaceTarget unable to find valid target from classIdTagOrNode");
        }
        var $targetElement = $(targetElement);
        if (this.isEdge()) {
            // Edge has problems with onClick if we don't hide the old HTML before replacing it
            $targetElement.css("display", "none");
        }
        $targetElement.replaceWith(newContent);
    };
    GwUtil.prototype.cleanId = function (id) {
        return "#" + id.replace(/(:|\.|\[|\]|,|=)/g, "\\$1");
    };
    GwUtil.prototype.replaceTargets = function (start, prog, inc, targets) {
        var max = start + plApp_1.gwApp.maxElementsToReplacePerFrame;
        var target;
        var id;
        var ids = [];
        for (var i = start; i < targets.length && i <= max; i++) {
            target = targets[i];
            ids.push(target.id);
            id = exports.gwUtil.cleanId(target.id);
            this.replaceTarget(id, target.content); //TODO: what are these targets elements, or jquery elemetns
            if (plApp_1.gwApp.shouldFlash) {
                this.targetIdsToAnimate.push(id);
            }
            prog += inc;
            if (i === max) {
                gwPageLoadBar_1.gwPageLoadBar.go(60 + prog);
                setTimeout(exports.gwUtil.replaceTargets.bind(this, i, prog, inc, targets), 0);
                return;
            }
        }
        plApp_1.gwApp.fireAfterPartialPageReload({ reason: plApp_1.GwPartialReloadReason.REPLACE_ITEMS, ids: ids });
    };
    GwUtil.prototype.replaceDeferred = function (deferredTargetID, childContent, isEmptyContent) {
        if (isEmptyContent === void 0) { isEmptyContent = false; }
        var node = exports.gwUtil.getDomNode(exports.gwUtil.cleanId(deferredTargetID));
        if (node === null) {
            throw new Error("Unable to locate node for deferred replacement");
        }
        var deferredNode = exports.gwUtil.getDomNode(".gw-deferred", node);
        var $deferredNode = $(deferredNode);
        $deferredNode.empty();
        if (isEmptyContent) {
            $deferredNode.append("<div class='gw-deferred-menuItem gw-deferred--empty'></div>");
        }
        else if (childContent) {
            // childContent will always be truthy if server responded.
            // It is only falsey if the content is actually empty (and in this case isEmptyContent==true)
            // or we got an error
            $deferredNode.append(childContent);
            $deferredNode.removeClass("gw-deferred");
            gwEvents_1.gwEvents.addInlineEventListenersToContainer(node);
        }
    };
    /**
     * Helper for truthy falsey evals when all you care about is not null or undefined.
     * Common JS library method.
     * @param thing
     * @returns {boolean}
     */
    GwUtil.prototype.hasValue = function (thing) {
        return thing !== undefined && thing !== null;
    };
    GwUtil.prototype.convertAllWhitespaceToStandard = function (str) {
        return str.replace(this.whitespaceRegex, " ");
    };
    /**
     * Reloads the client from cache without asking the server for any files.
     */
    GwUtil.prototype.reloadClient = function () {
        gwEvents_1.gwEvents.disableEvents();
        window.location.reload(false);
    };
    GwUtil.prototype.forceFullClientRefresh = function () {
        gwEvents_1.gwEvents.disableEvents();
        window.location.reload(true);
    };
    GwUtil.prototype.setOptionOnSelect = function (classIdTagOrNode, valStr, ignoreNullEl) {
        if (ignoreNullEl === void 0) { ignoreNullEl = false; }
        var el = exports.gwUtil.getDomNode(classIdTagOrNode);
        if (!el) {
            if (ignoreNullEl) {
                return;
            }
            throw new Error("Attempted to set an option on a null select element");
        }
        if (el.tagName.toLowerCase() !== "select") {
            throw new Error("Tried to setOptionOnSelect on a non select element.");
        }
        el.setAttribute("value", valStr);
        el.value = valStr;
        var foundValidOption = false;
        exports.gwUtil.forEach($("option", el), function (opt) {
            opt.removeAttribute("selected");
            if (opt.value === valStr) {
                foundValidOption = true;
                opt.selected = true;
            }
        });
        if (!foundValidOption) {
            exports.gwUtil.devlog("No Valid option for " + valStr + " found on select element: ", el);
        }
    };
    GwUtil.prototype.setOptionsOnSelect = function (classIdTagOrNode, values) {
        var el = exports.gwUtil.getDomNode(classIdTagOrNode);
        if (!el) {
            exports.gwUtil.devlog("Attempted to set an option on a null select element");
            return;
        }
        if (el.tagName.toLowerCase() !== "select") {
            throw new Error("Tried to setOptionsOnSelect on a non select element.");
        }
        if (!Array.isArray(values)) {
            values = [values];
        }
        //TODO: cooper TS how did this ever work, setting an array to an attribute?
        // el.setAttribute("value", values);
        // el.value = values;
        exports.gwUtil.forEach($("option", el), function (opt) {
            opt.removeAttribute("selected");
            if (values.indexOf(opt.value) !== -1) {
                opt.selected = true;
            }
        });
    };
    /**
     * Returns the element.dataset.dataSetProp if it exists, or if provided, a defaultValue, else an empty string
     * @param classIdTagOrNode
     * @param dataSetProp - camelCase property on the dataset object
     * @param defaultValue - optional return value if no matching property found
     * @returns {*}
     */
    GwUtil.prototype.getDatasetPropOrDefault = function (classIdTagOrNode, dataSetProp, defaultValue) {
        if (defaultValue === void 0) { defaultValue = ""; }
        var el = exports.gwUtil.getDomNode(classIdTagOrNode);
        if (!el) {
            return defaultValue;
        }
        if (exports.gwUtil.hasValue(el.dataset)) {
            return el.dataset[dataSetProp] || defaultValue;
        }
        return defaultValue;
    };
    /**
     * Given a dom element try to construct a selector that can be given to document.querySelector to return that
     * same element. This relies on some assumptions about our HTML. We assume any element id or name is unique.
     * Then for certain CSS classes we assume only one child with that class will appear under a parent with a
     * particular id (so we can use the parent id plus the class to uniquely identify the child).
     * @param {GwDomNode} node
     * @returns {string | null}
     */
    GwUtil.prototype.getUniqueSelector = function (node) {
        if (node.hasAttribute("id")) {
            return "#" + node.id;
        }
        else if (node.hasAttribute("name")) {
            return "[name=\"" + node.getAttribute("name") + "\"]";
        }
        else if (node.parentElement && node.parentElement.hasAttribute("id")) {
            for (var _i = 0, _a = this.UNIQUE_CHILD_CLASSES; _i < _a.length; _i++) {
                var c = _a[_i];
                if (this.hasClass(node, c)) {
                    return "#" + node.parentElement.id + " > ." + c;
                }
            }
        }
        return null;
    };
    /**
     * @private
     * Used inside of getDomeNode and getDomNodes to select the correct method
     * @param classIdOrTag
     * @returns {}
     */
    GwUtil.prototype.getElementsByString = function (classIdTagOrNode, contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        if (typeof classIdTagOrNode === "string") {
            if (classIdTagOrNode[0] === "#") {
                var node = document.getElementById(classIdTagOrNode.slice(1));
                if (node === null) {
                    return null;
                }
                return [node];
            }
            else if (classIdTagOrNode[0] === ".") {
                return contextNode.getElementsByClassName(classIdTagOrNode.slice(1));
            }
            else {
                return contextNode.getElementsByTagName(classIdTagOrNode);
            }
        }
        return [classIdTagOrNode];
    };
    /**
     * @public
     * Returns a collection. Always. Even if passing in dom node or an id or an HTMLCollection.
     * @param classIdTagOrNode: class, id, or tag string, or
     * @returns {collection of DOM Nodes}
     */
    GwUtil.prototype.getDomNodes = function (classIdTagOrNode, contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        if (!classIdTagOrNode) {
            return [];
        }
        if (typeof classIdTagOrNode === "string" || classIdTagOrNode instanceof Element) {
            return this.getElementsByString(classIdTagOrNode, contextNode) || [];
        }
        return classIdTagOrNode;
    };
    /**
     * @public
     * Returns a single Dom Node
     * @param classIdTagOrNode: class string, id string, tag string, or if it's a node, it gets passed right back.
     * @contextNode the node too search within
     * @returns {DOM Node}
     */
    GwUtil.prototype.getDomNode = function (classIdTagOrNode, contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        if (!classIdTagOrNode) {
            return null;
        }
        var vals = this.getElementsByString(classIdTagOrNode, contextNode);
        if (vals === null) {
            return null;
        }
        return vals[0];
    };
    GwUtil.prototype.getDomNodeOrThrow = function (classIdTagOrNode, contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        var node = this.getDomNode(classIdTagOrNode, contextNode);
        if (!node) {
            throw new Error("Unable to locate a matching node for: " + classIdTagOrNode);
        }
        return node;
    };
    GwUtil.prototype.getInputElement = function (classIdTagOrNode, contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        return this.getDomNode(classIdTagOrNode, contextNode);
    };
    /**
     * @public
     * @param attr - String: html dom attribute
     * @param optValue - any, if undefined, then checks for the presence of the attribute, if defined then checks against the value
     * @param optParent - DOM Element, if undefined, then uses the document.
     * @returns {Element || null}
     */
    GwUtil.prototype.getDomNodeByAttr = function (attr, optValue, optParent) {
        if (optParent === void 0) { optParent = document; }
        if (optValue === undefined) {
            return optParent.querySelector("[" + attr + "]");
        }
        return optParent.querySelector("[" + attr + "='" + optValue + "']");
    };
    GwUtil.prototype.getDomNodeByName = function (nameValue, optParent) {
        if (optParent === void 0) { optParent = document; }
        return this.getDomNodeByAttr("name", nameValue, optParent);
    };
    /**
     * @public
     * @param attr - String: html dom attribute
     * @param optValue - any, if undefined, then checks for the presence of the attribute, if defined then checks against the value
     * @param optParent - DOM Element, if undefined, then uses the document.
     * @returns {NodeList || null}
     */
    GwUtil.prototype.getDomNodesByAttr = function (attr, optValue, optParent) {
        if (optParent === void 0) { optParent = document; }
        if (optValue === undefined) {
            return optParent.querySelectorAll("[" + attr + "]");
        }
        return optParent.querySelectorAll("[" + attr + "='" + optValue + "']");
    };
    /**
     * @public
     * Removes a dom node from the parent if one exists
     * @param classIdTagOrNode: class string, id string, tag string, or a node that identifies the node to be removed.
     * @param contextNode the node from which to remove the child
     */
    GwUtil.prototype.removeNodeIfExists = function (classIdTagOrNode, parentNode) {
        var node = exports.gwUtil.getDomNode(classIdTagOrNode, parentNode);
        if (node) {
            parentNode.removeChild(node);
        }
    };
    GwUtil.prototype.getSelfOrFirstParentWithClass = function (self, cssClass) {
        var el = self;
        cssClass = cssClass.replace(".", "");
        var safety = 100;
        while (el && safety--) {
            if (!el || (el.classList && el.classList.contains("gw-body"))) {
                return null;
            }
            if (el.classList && el.classList.contains(cssClass)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    };
    GwUtil.prototype.getSelfOrFirstParentWithClassOrThrow = function (self, cssClass) {
        var found = this.getSelfOrFirstParentWithClass(self, cssClass);
        if (!found) {
            throw new Error("Unable to locate matching node");
        }
        return found;
    };
    GwUtil.prototype.getSelfOrFirstParentWithAttr = function (self, attr) {
        var el = self;
        var safety = 100;
        while (el && safety--) {
            if (!el || (el.classList && el.classList.contains("gw-body"))) {
                return null;
            }
            if (el.hasAttribute(attr)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    };
    GwUtil.prototype.getSelfOrFirstParentWithEitherAttr = function (self, attrOrArrOfAttributes) {
        if (!Array.isArray(attrOrArrOfAttributes)) {
            return this.getSelfOrFirstParentWithAttr(self, attrOrArrOfAttributes);
        }
        var el = self;
        var safety = 100;
        while (el && safety--) {
            if (!el || (el.classList && el.classList.contains("gw-body"))) {
                return null;
            }
            for (var i = 0; i < attrOrArrOfAttributes.length; i++) {
                if (el.hasAttribute(attrOrArrOfAttributes[i])) {
                    return el;
                }
            }
            el = el.parentElement;
        }
        return null;
    };
    /**
     * @public
     * Returns true or false based on the presence of a css class on the first result of gwUtil.getDomNodes
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classToCheck: css class
     * @returns {boolean}
     */
    GwUtil.prototype.hasClass = function (classIdTagOrNode, classToCheck) {
        var el = exports.gwUtil.getDomNode(classIdTagOrNode);
        if (el && el.classList) {
            var re = /\./g; //TODO: cooper, make sure that older browsers like IE11 are smart enough to cache inline regex instantiation, if not, we should pull them out into the parent.
            return el.classList.contains(classToCheck.replace(re, ""));
        }
        return false;
    };
    /**
     * @public
     * Returns true or false based on the presence of at least one css class on the first result of gwUtil.getDomNodes
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classesToCheck: css classes to check
     * @returns {boolean}
     */
    GwUtil.prototype.hasAnyClass = function (classIdTagOrNode, classesToCheck) {
        var el = exports.gwUtil.getDomNode(classIdTagOrNode);
        if (el && el.classList) {
            var re = /\./g; //TODO: cooper, make sure that older browsers like IE11 are smart enough to cache inline regex instantiation, if not, we should pull them out into the parent.
            for (var i = 0; i < classesToCheck.length; i++) {
                if (el.classList.contains(classesToCheck[i].replace(re, ""))) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * @public
     * Toggles a css class on the results of getDomNodes for classIdTagOrNode
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classToToggle: css class
     */
    GwUtil.prototype.toggleClass = function (classIdTagOrNode, classToToggle) {
        var els = exports.gwUtil.getDomNodes(classIdTagOrNode);
        var re = /\./g;
        classToToggle = classToToggle.replace(re, "");
        for (var i = 0; i < els.length; i++) {
            var el = els[i];
            if (!el) {
                continue;
            }
            if (!el.classList) {
                exports.gwUtil.devlog("WARNING: called toggle class on element without classList support. This is likely an IE11 issue.", el);
                continue;
            }
            el.classList.toggle(classToToggle);
        }
    };
    /**
     * @public
     * Ensures the presence of a the provided class based on the condition. If condition is true, adds the class,
     * if condition is false removes the class from the the target.
     * @param condition
     * @param classIdTagOrNode
     * @param classStrOrArrayOfStr
     */
    GwUtil.prototype.conditionalAddRemoveClass = function (condition, classIdTagOrNode, classStrOrArrayOfStr) {
        condition = exports.gwUtil.convertIfString(condition);
        if (condition) {
            this.addClass(classIdTagOrNode, classStrOrArrayOfStr);
        }
        else {
            this.removeClass(classIdTagOrNode, classStrOrArrayOfStr);
        }
    };
    GwUtil.prototype.conditionalAddRemoveAttr = function (condition, classIdTagOrNode, key, value) {
        condition = exports.gwUtil.convertIfString(condition);
        if (!this.hasValue(value)) {
            value = "";
        }
        else {
            value = "" + value;
        }
        this.forEach(this.getDomNodes(classIdTagOrNode), function (node) {
            if (condition) {
                node.setAttribute(key, value);
            }
            else {
                node.removeAttribute(key);
            }
        });
    };
    /**
     * @private
     * Private method called by addClass and removeClass
     */
    GwUtil.prototype.abstractAddRemoveClass = function (addOrRemove, classIdTagOrNode, classStrOrArrayOfStr) {
        if (typeof classStrOrArrayOfStr === "string") {
            classStrOrArrayOfStr = classStrOrArrayOfStr.split(" ");
        }
        var re = /\./g;
        var classes = [];
        var els = exports.gwUtil.getDomNodes(classIdTagOrNode);
        for (var i = 0; i < classStrOrArrayOfStr.length; i++) {
            if (!classStrOrArrayOfStr[i]) {
                continue;
            }
            classes.push(classStrOrArrayOfStr[i].replace(re, ""));
        }
        // Note: we have to walk backwards over this list, as an HTML Node list is live, and if we modify the classes it could change contents
        for (var i = els.length - 1; i >= 0; i--) {
            var el = els[i];
            if (!el) {
                continue;
            }
            if (!el.classList) {
                exports.gwUtil.devlog("WARNING: called add/remove class on element without classList support. This is likely an IE11 issue.", el);
                continue;
            }
            for (var j = 0; j < classes.length; j++) {
                el.classList[addOrRemove](classes[j]); //NOTE: IE11 does not support adding removing via array, so have to iterate
            }
        }
    };
    /**
     * @public
     * adds a css class or array of classes onto the results of getDomNodes for classIdTagOrNode
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classStrOrArrayOfStrToAdd: css class string, or array of classes
     */
    GwUtil.prototype.addClass = function (classIdTagOrNode, classStrOrArrayOfStrToAdd) {
        this.abstractAddRemoveClass("add", classIdTagOrNode, classStrOrArrayOfStrToAdd);
    };
    /**
     * @public
     * removes a css class or array of classes from the results of getDomNodes for classIdTagOrNode
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classStrOrArrayOfStrToRemove: css class string, or array of classes
     */
    GwUtil.prototype.removeClass = function (classIdTagOrNode, classStrOrArrayOfStrToRemove) {
        this.abstractAddRemoveClass("remove", classIdTagOrNode, classStrOrArrayOfStrToRemove);
    };
    /**
     * @public
     * Helper method for calling addClass and removeClass. Especially handy when inlining.
     * @param classIdTagOrNode: the argument to be passed to getDomNodes
     * @param classStrOrArrayOfStrToAdd: css class string, or array of classes
     * @param classStrOrArrayOfStrToRemove: css class string, or array of classes
     */
    GwUtil.prototype.addAndRemoveClasses = function (classIdTagOrNode, classStrOrArrayOfStrToAdd, classStrOrArrayOfStrToRemove) {
        var collection = exports.gwUtil.getDomNodes(classIdTagOrNode);
        exports.gwUtil.addClass(collection, classStrOrArrayOfStrToAdd);
        exports.gwUtil.removeClass(collection, classStrOrArrayOfStrToRemove);
    };
    GwUtil.prototype.appendEl = function (parentClassIdTagOrNode, childClassIdTagOrNode) {
        var newParent = exports.gwUtil.getDomNode(parentClassIdTagOrNode);
        var children = exports.gwUtil.getDomNodes(childClassIdTagOrNode);
        if (!newParent || !children) {
            throw new Error("appendEl could not find parent or child matching the given arguments.");
        }
        exports.gwUtil.forEach(children, function (child) {
            if (child.parentNode) {
                child.parentNode.removeChild(child);
            }
            newParent.appendChild(child);
        });
    };
    /**
     * Escape any special characters in the given string so they will not be used as special regular expression
     * characters. For example "." will become "\."
     * @param {string} s the string to be escaped
     * @returns {string} the escaped string
     */
    GwUtil.prototype.escapeForRegExp = function (s) {
        return s.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&");
    };
    /**
     * @public
     * noop
     */
    GwUtil.prototype.noop = function () {
        // NOOP
    };
    /**
     * @public
     * @debug logs the arguments if gwApp.showDevLogs is true;
     * Does not need to be localized.
     * @param str: some string
     * @param obj: optional, logged directly to the console, not string converted
     */
    GwUtil.prototype.devlog = function (str, obj) {
        if (plApp_1.gwApp.showDevLogs) {
            if (obj === undefined || obj === null) {
                console.log(str);
            }
            else {
                console.log(str, obj);
            }
        }
    };
    GwUtil.prototype.eventLog = function (str, obj) {
        if (plApp_1.gwApp.showEventLogs) {
            if (obj === undefined || obj === null) {
                console.log(str);
            }
            else {
                console.log(str, obj);
            }
            if (plApp_1.gwApp.showEventTrace) {
                console.log(this.getTrace());
            }
        }
    };
    GwUtil.prototype.getTrace = function () {
        var trace;
        try {
            null.toString(); //TODO: fool ts to throw at runtime
        }
        catch (e) {
            trace = e.stack;
        }
        var splitTrace = trace.split("\n");
        //Remove this function, the caller, and the fake exception text
        return splitTrace.slice(3).join("\n");
    };
    /**
     * @public
     * TODO: this could probaly get moved into a component specific file, like Row.js
     * @param targetGroupRowNode
     */
    GwUtil.prototype.toggleRowGroup = function (targetRowGroupEl) {
        $(targetRowGroupEl).toggleClass("gw-RowGroup--expanded")
            .nextUntil("tr.gw-RowGroup, tr:has(td.gw-FooterCellWidget)")
            .toggleClass("gw-hidden");
    };
    GwUtil.prototype.convertArrayToMapSet = function (arr) {
        var map = {};
        if (!arr) {
            return map;
        }
        for (var i = 0; i < arr.length; i++) {
            map[arr[i]] = true; //TODO
        }
        return map;
    };
    GwUtil.prototype.isIndexIterable = function (coll) {
        return coll.forEach !== undefined || coll.each !== undefined;
    };
    /**
     * @public
     * Takes any collection, object, array, or even more useful, HTMLNodeCollections, etc.
     * @param coll: object or array, or array-like.
     * @param cb: a function with signature cb(value, indexOrKey, collection, (mockIndex). Where mockIndex is the current count of
     * values processed on a non-array. return false inside the callback explicitly to break the loop;
     */
    GwUtil.prototype.forEach = function (coll, cb) {
        if (!coll) {
            return;
        }
        if (typeof coll === "string" || this.isIndexIterable(coll)) {
            for (var i = 0; i < coll.length; i++) {
                if (cb(coll[i], "" + i, coll, i) === gwTypes_1.GW_BREAKER) {
                    return;
                }
            }
        }
        else if (typeof coll === "object") {
            var mockIndex = -1;
            for (var key in coll) {
                if (!coll.hasOwnProperty(key)) {
                    continue;
                }
                mockIndex++;
                if (cb(coll[key], key, coll, mockIndex) === gwTypes_1.GW_BREAKER) {
                    return;
                }
            }
        }
    };
    /**
     * @public
     * same as forEach, but reversed. In the case of objects, there's an extra build from Object.keys, which is then
     * iterated over backwards.
     * @param coll: object or array, or array-like.
     * @param cb: a function with signature cb(value, indexOrKey, collection, (mockIndex). Where mockIndex is the current count of
     * values processed on a non-array. return false inside the callback explicitly to break the loop;
     */
    GwUtil.prototype.forEachReverse = function (coll, cb) {
        if (!coll) {
            return;
        }
        if (typeof coll === "string" || this.isIndexIterable(coll)) {
            for (var i = coll.length - 1; i >= 0; i--) {
                if (cb(coll[i], "" + i, coll, i) === gwTypes_1.GW_BREAKER) {
                    return;
                }
            }
        }
        else if (typeof coll === "object") {
            var keys = Object.keys(coll);
            for (var mockIndex = keys.length - 1; mockIndex >= 0; mockIndex--) {
                var key = keys[mockIndex];
                if (cb(coll[key], key, coll, mockIndex) === gwTypes_1.GW_BREAKER) {
                    return;
                }
            }
        }
    };
    /**
     * Helper method to create a div via lists of classes attributes and styles.
     * This should be used sparingly, as Pebbles is a server side rendererd system, so any client side generated elements
     * will need to be regenerated and re-added to the dom after any page load, full or partial.
     * This is most commonly used by client side systems to add MenuItems to the settings dropdown.
     * @param classes - String as single class or array of strings.
     * @param attributes - Object: key value pairs for inline attributes, including 'id'. Pass empty string value if no value needed.
     * @param styles - Object: key value pairs for inline styles.
     * @param label - if provided, then div.innerHTML = label is called.
     * @returns {DOMElement: DIV}
     */
    GwUtil.prototype.createDiv = function (classes, attributes, styles, label) {
        var div = document.createElement("div");
        if (classes) {
            this.addClass(div, classes);
        }
        this.forEach(attributes, function (value, key) {
            if (typeof value === "string") {
                div.setAttribute(key, value);
            }
        });
        this.forEach(styles, function (value, key) {
            if (!value) {
                return;
            }
            div.style.setProperty(key, value);
        });
        if (label) {
            div.innerHTML = label;
        }
        return div;
    };
    /**
     * Detects whether we're running IE 11.
     * @returns {boolean} Returns true if IE11 else false
     */
    GwUtil.prototype.isIE11 = function () {
        if (this._isIE11 === null) {
            var trident = !!navigator.userAgent.match(/Trident\/7.0/);
            var net = !!navigator.userAgent.match(/.NET4.0/);
            this._isIE11 = trident && net;
        }
        return this._isIE11;
    };
    /**
     * Detects whether we're running Edge.
     * @returns {boolean} Returns true if Edge else false
     */
    GwUtil.prototype.isEdge = function () {
        if (this._isEdge === null) {
            this._isEdge = !!navigator.userAgent.match(/Edge\//);
        }
        return this._isEdge;
    };
    /**
     * @private
     * Generates a span containing an accessKey for each server shortcut key to allow shortcut keys to work
     * in IE (See comment for disableIEShortcuts below).
     * @returns {string} HTML span containing an accessKey entry for each server shortcut
     */
    GwUtil.prototype.generateIEShortcutWorkAround = function () {
        var workAroundTargets = gwKeys_1.gwKeys.getServerKeyboardShortcutCharacters();
        var str = "<span id='gw-ie-shortcut-links' style='position:absolute'>";
        str += workAroundTargets.map(function (target) {
            return "<a accessKey=\"" + target + "\" href=\"javascript:void(0)\" data-gw-refuse-focus tabIndex=\"-1\"></a>";
        }).join("");
        str += "</span>";
        return str;
    };
    /**
     * The following is horrible hackery to make keyboard shortcuts work more reliably on IE.
     *
     * The normal event.preventDefault() mechanism does not work for key down events in IE. If a key combination
     * is bound to an IE specific shortcut, like Alt-F (File menu) then the JavaScript event will fire but
     * preventDefault() will not prevent IE from also popping up the IE file menu.
     *
     * Various fixes are suggested on the internet - setting the keyCode to zero, setting returnValue to false,
     * returning false from the event handler - but none of them work reliably. The only thing guaranteed to work
     * is to set up a link with an "accesskey". For example a link with the accesskey "f" will grab Alt-F and the
     * IE file menu will not come up.
     *
     * Unfortunately the accesskey workaround leaves focus with the link, so we mark the links with a special
     * attribute, data-gw-refuse-focus, which tells the event system to bounce focus back to the last target
     * when the link gets a focus event.
     */
    GwUtil.prototype.disableIEMenuShortcut = function () {
        if (this.isIE11()) {
            var shortcutSpan = document.getElementById("gw-ie-shortcut-links");
            var shortcutHtml = this.generateIEShortcutWorkAround();
            if (shortcutSpan) {
                this.replaceTarget(shortcutSpan, shortcutHtml);
            }
            else {
                $(document.body).prepend(shortcutHtml);
            }
        }
    };
    /**
     * Fire a custom event on the body of the document. The event is created with the given name and the detail
     * object can be used to pass information useful to listeners, who can access it via event.detail
     * @param eventName the name of the custom event
     * @param detail object containing further details of the event
     */
    GwUtil.prototype.fireCustomEvent = function (eventName, detail) {
        var event;
        if (this.isIE11()) {
            event = document.createEvent("CustomEvent");
            event.initCustomEvent(eventName, false, false, detail);
        }
        else {
            event = new CustomEvent(eventName, { detail: detail });
        }
        document.body.dispatchEvent(event);
    };
    /**
     * Listen for a custom event on the body of the document. Typically the event would be fired using
     * gwUtil.fireCustomEvent
     * @param eventName the name of the event to listen for
     * @param handler function to call if the event is filed; takes one argument which will be the event that was fired
     */
    GwUtil.prototype.addCustomEventListener = function (eventName, handler) {
        document.body.addEventListener(eventName, handler);
    };
    return GwUtil;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwUtil = GwUtil;
exports.gwUtil = new GwUtil();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return exp; });
/* unused harmony export floor */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return tan; });
/* harmony export (immutable) */ __webpack_exports__["b"] = acos;
/* harmony export (immutable) */ __webpack_exports__["c"] = asin;
/* harmony export (immutable) */ __webpack_exports__["m"] = haversin;
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gw_1 = __webpack_require__(10);
var GwRegisteredSystem = /** @class */ (function () {
    function GwRegisteredSystem() {
        if (this.availableToGlobal()) {
            gw_1.gw.registerGlobalSystem(this);
        }
    }
    GwRegisteredSystem.prototype.availableToGlobal = function () {
        return true;
    };
    return GwRegisteredSystem;
}());
exports.GwRegisteredSystem = GwRegisteredSystem;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwEventDescription_1 = __webpack_require__(61);
var gwFocus_1 = __webpack_require__(8);
var gwPrefPanel_1 = __webpack_require__(28);
var gw_1 = __webpack_require__(10);
var gwDisplayKey_1 = __webpack_require__(16);
var gwKeys_1 = __webpack_require__(23);
var gwMenus_1 = __webpack_require__(26);
var gwInputs_1 = __webpack_require__(5);
var gwTooltips_1 = __webpack_require__(56);
var gwDraggable_1 = __webpack_require__(82);
var gwHelpText_1 = __webpack_require__(81);
var gwForm_1 = __webpack_require__(25);
var gwDateValue_1 = __webpack_require__(55);
var gwReflection_1 = __webpack_require__(54);
var gwConfirm_1 = __webpack_require__(133);
var gwScroll_1 = __webpack_require__(27);
var gwUtil_1 = __webpack_require__(0);
var GwForcedEvent_1 = __webpack_require__(230);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwEvents = /** @class */ (function (_super) {
    __extends(GwEvents, _super);
    function GwEvents() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.eventLockCount = 1; // Start out locked; the app reload code will explicitly enable events when it is ready
        /**
         * A flag indicating to other event handlers whether the mouse has been clicked.
         * Specifically, in IE focusIn events are fired on all dom elements, we need to know
         * whether something was focused on click or by keyboard navigation
         * @type {boolean}
         */
        _this.mouseDown = false;
        /**
         * A flag that indicates whether we should handle the next double click event. The double click event is always
         * preceded by a click event generated by the first click in the double click.  If that initial click has an action
         * associated with it, we set this flag to false so that the action associated with the double click event will be
         * ignored.
         */
        _this.allowNextDoubleClickEvent = false;
        /**
         *
         * Queue for multiple events fired at the same time. Currently possible event got queued would be the action widget's mouse click
         * event following by change event which trigger a request back to server. Since focusOut happens first so the onChange event
         * will fired first, then the mouse click event will be queued and processEventQueue will be called after the page is loaded from the first
         * request.
         */
        _this.eventQueue = [];
        /**
         * @public constant
         * @type {string}
         */
        _this.dataPrefix = "data-gw-"; // If you change this, you are going to have to change it everywhere on the server
        /**
         * @private
         * Contains the custom transformations used to add complex additional attributes for particular data-gw-* attributes.
         * These transforms are processed after the base transforms, to ensure there's no extra attributes added by chaining.
         * ie: if a node has gw-data-hover-submenu on it, then it will end up with 4 additional attributes handling mouseenter and mouseleave.
         */
        _this.complexAttributeTransforms = {
            "menu-hover": {
                "data-gw-mouseenter": "gwMouse.enter"
            },
            autocomplete: {
                autocomplete: "off",
                "data-gw-input": "gwInputs.inputEventNotifySystems",
                "data-gw-focus": "gwTextValue.autocomplete",
                "data-gw-key": "gwTextValue.chooseCurrentAutocompleteEntry key:13"
            },
            "input-mask": {
                "data-gw-input": "gwInputs.inputEventNotifySystems",
                "data-gw-copy": "gwInputs.copyEventNotifySystems"
            },
            "currency-info": {
                "data-gw-input": "gwInputs.inputEventNotifySystems",
                "data-gw-copy": "gwInputs.copyEventNotifySystems",
                "data-gw-paste": "gwInputs.pasteEventNotifySystems"
            },
            draggable: {
                "data-gw-dragstart": "gwDraggable.start",
                "data-gw-dragend": "gwDraggable.end",
                "data-gw-dragcancel": "gwDraggable.cancel"
            },
            tooltip: {
                "data-gw-mouseenter": "gwMouse.enter",
                "data-gw-mousemove": "gwTooltips.move",
                "data-gw-mouseout": "gwTooltips.hide"
            }
        };
        /**
         * @private
         *
         * All properties on this object will be given a tabindex=0 inline attribute.
         * //TODO: this object's sole purpose now is just to add tabindexes, need to change it to be that more clearly.
         */
        _this.baseAttributeTransforms = {
            mouseenter: {},
            mouseleave: {},
            draggable: {},
            blur: {},
            focus: {},
            change: {},
            click: {},
            key: {}
        };
        /**
         * @private
         * The default suffix for any fireEvent action. This can be overriden inline for the default events methods by passing a suffix
         * argument, ie "fireEvent suffix:_other" or fireEvent suffix:null to not use a suffix. Mainly used for dev actions like PCF_RELOAD
         * @type {string}
         */
        _this.actionSuffix = "_act"; // TODO, cooper, there may come a day when we have more than these, but I'd still rather sort em out on the client
        /**
         * @private
         * Use the disableEvents and enableEvents functions
         */
        _this.eventsEnabled = false;
        /**
         * @private
         * Used to convert the actual DOM event name from key to value, when we process static
         * This is primarily so that we never need to change how events are declared on the server, regardless of how we
         * decide to listen for events on the client. ie, we changed from onkeypress to onkeydown, but the server just sets
         * data-gw-key.
         *
         */
        _this.eventsMap = {
            keydown: "key",
            focusout: "blur",
            focusin: "focus",
            mouseover: "mouseenter",
            mousecancel: "dragend",
            mousedown: "dragstart",
            mouseup: "dragend"
        };
        /**
         * Events types listed here, by our "internal event names" meaning, "key" not "onkeydown".
         * Will fire event.preventDefault if the events system finds a target that can handle the event.
         * Unless the eventDescription it finds specifically sets enableDefault: true.
         * @type {{key: boolean, copy: boolean, dragover: boolean, drop: boolean}}
         */
        _this.disableDefaultBehaviorIfHandled = {
            key: true,
            dragover: true,
            drop: true,
            copy: true,
            focusin: true,
            focusout: true
        };
        _this.navigationConfirmIsDisabled = false;
        _this.mouseMoveOwner = null;
        _this.isInTouchEvent = false;
        _this.lostFocusTimer = -1;
        _this.tempActiveId = null;
        /**
         * @private
         * These methods should only be called as a result of a lookup inside of gw.event.onElementEvent
         * @type {{fireEvent: this.methods.fireEvent, addClass: this.methods.addClass, removeClass: this.methods.removeClass, addAndRemoveClass: this.methods.addAndRemoveClass, toggleClass: this.methods.toggleClass, openSubMenu: this.methods.openSubMenu, closeSubMenu: this.methods.closeSubMenu, toggleSubMenu: this.methods.toggleSubMenu, resetValue: this.methods.resetValue, page: this.methods.page}}
         */
        _this.methods = {
            /**
             * This method fires the event inside of a setTimeout to ensure that the browser has a frame to render and update first
             * @param node
             * @param args
             * @param cbAfterClientFiresEventMethod - method fires inside the timeout after gwUtil.fireEvent is called.
             */
            fireEvent: function (node, args, e, cbAfterClientFiresEventMethod) {
                //TODO: temp hack to see about preventing flash highlighting in nav menu;
                if (gwUtil_1.gwUtil.hasClass(node, "gw-action--inner")) {
                    var parentEl = $(node).parents(".gw-action--outer")[0];
                    gwUtil_1.gwUtil.addClass(parentEl, "gw-event-temp-active");
                    exports.gwEvents.tempActiveId = parentEl.id;
                }
                exports.gwEvents.disableEvents();
                setTimeout(function () {
                    exports.gwEvents.enableEvents();
                    gwUtil_1.gwUtil.fireEvent(args.id + args.suffix);
                    if (cbAfterClientFiresEventMethod) {
                        cbAfterClientFiresEventMethod(node, args);
                    }
                }, 0);
            },
            refresh: function (node, args) { return gwUtil_1.gwUtil.refresh(args.id); },
            browserAction: function (node, args, event) {
                gwUtil_1.gwUtil.browserAction(node, args.id, event);
                gwMenus_1.gwMenus.closeAllMenus();
            },
            noOp: function () {
            },
            addClass: function (node, args) { return gwUtil_1.gwUtil.addClass(args.target || node, args.add); },
            removeClass: function (node, args) { return gwUtil_1.gwUtil.removeClass(args.target || node, args.remove); },
            addAndRemoveClass: function (node, args) { return gwUtil_1.gwUtil.addAndRemoveClasses(args.target || node, args.add, args.remove); },
            toggleClass: function (node, args) { return gwUtil_1.gwUtil.toggleClass(args.target || node, args.toggle); },
            toggleSubMenu: function (node, args) { return gwMenus_1.gwMenus.toggleSubMenu(args.target || node, args.eventType); },
            toggleOnDemand: function (node, args) {
                //TODO: cannot find toggleOnDemand anywhere in js code, other than here
                //gwMenus.toggleOnDemand(args.target || node, args);
                throw new Error("This method no longer does anything after the Typescript conversion. Need to understand where the js went");
            },
            resetValue: function (node, args) {
                var val = args.reset;
                if (val === null || val === undefined) {
                    gwUtil_1.gwUtil.devlog("WARNING: resetValue called for node with no data-gw-reset attribute", node);
                }
                var targetNode = gwUtil_1.gwUtil.getDomNode(args.target || node);
                if (targetNode) {
                    targetNode.value = val;
                }
            },
            unsavedWork: function (node, args) { return gwUtil_1.gwUtil.unsavedWork(args.id + (args.go ? "_go" : "_discard"), args.go || args.discard); },
            logout: function (node, args) {
                exports.gwEvents.disableNavigationConfirmationUntilUserCancelsConfirm();
                exports.gwEvents.methods.fireEvent(node, args);
            }
        };
        return _this;
    }
    GwEvents.prototype.getSystemName = function () {
        return "gwEvents";
    };
    /**
     * Many types of event listeners do not respond to synthetically generated  We easily bypass this since all of our
     * events are handled via our 'onGlobalBlahEvent' handlers. So instead of constructing an event object and firing it,
     * or using $(el).trigger, (neither of which would be caught by the global listener, for example onchange) we can just directly
     * fire the onGlobalChangeEvent method, and pass in a fakeEvent object. Then use all the same code paths from there.
     * @param targetEl
     * @param eventName
     * @param optRelatedTargetEl
     */
    GwEvents.prototype.forceGlobalEvent = function (targetEl, eventName, optRelatedTargetEl) {
        gwUtil_1.gwUtil.eventLog("Forcing global '" + eventName + "' event on target:", targetEl);
        if (eventName.indexOf("on") === 0) {
            eventName = eventName.substring(2).toLowerCase();
        }
        var methodEventName = this.eventsMap[eventName] || eventName;
        methodEventName = methodEventName[0].toUpperCase() + methodEventName.slice(1);
        methodEventName = "onGlobal" + methodEventName + "Event";
        var fakeEvent = new GwForcedEvent_1.GwForcedEvent(targetEl, eventName, optRelatedTargetEl);
        this[methodEventName](fakeEvent); //TODO: rework this for ts
    };
    /**
     * @private
     * Called on a dom node and an attribute object, to transform any matching data-gw-'event' attributes
     */
    GwEvents.prototype.addAdditionalAttributeTransforms = function (el, attributes) {
        var obj;
        for (var attribute in attributes) {
            if (el.hasAttribute(this.dataPrefix + attribute)) {
                obj = attributes[attribute];
                Object.keys(obj).forEach(function (newAttribute) {
                    if (el.hasAttribute(newAttribute)) {
                        if (el.getAttribute(newAttribute) !== obj[newAttribute]) {
                            // Then two different systems have tried to use the same event
                            // They need to be rectified manually in complexAttributeTransforms
                            throw new Error("EVENT METHOD ERROR: " + newAttribute + " was defined twice by two different systems: \n1. " + el.getAttribute(newAttribute) + "\n2. " + obj[newAttribute]);
                        }
                    }
                    else {
                        el.setAttribute(newAttribute, obj[newAttribute]);
                    }
                });
            }
        }
    };
    /**
     * Catch all method to do anything when the escape key is pressed. Focus node can be checked to do specific things.
     *
     */
    GwEvents.prototype.escapeKeyPressed = function () {
        this.closeAllTemporaryUIElements();
        if (gwDraggable_1.gwDraggable.getBeingDragged()) {
            this.forceGlobalEvent(gwDraggable_1.gwDraggable.getBeingDragged(), "dragcancel");
        }
    };
    GwEvents.prototype.closeAllTemporaryUIElements = function () {
        gwMenus_1.gwMenus.closeAllMenus();
        gwInputs_1.gwInputs.closeOpenInputs();
        gwTooltips_1.gwTooltips.hide();
    };
    GwEvents.prototype.focusQuickjump = function () {
        gwFocus_1.gwFocus.forceFocus("#QuickJump", true);
    };
    GwEvents.prototype.possiblyAddOnBeforeUnloadHandler = function () {
        var _this = this;
        // If the user is on the login page, then reset the navigationConfirmIsDisabled flag, so on next non login page load, we'll add it.
        if (gwUtil_1.gwUtil.onLoginPage()) {
            this.navigationConfirmIsDisabled = false;
            this.clearBeforeUnload();
            return;
        }
        // If navigation confirmation is disabled then bail
        if (this.navigationConfirmIsDisabled) {
            this.clearBeforeUnload();
            return;
        }
        // Otherwise, the user is on a standard page, so add or remove the event handler based on prefs.
        if (gwPrefPanel_1.gwPrefPanel.getPrefValueById("alwaysConfirmNavigation") || gwUtil_1.gwUtil.hasUnsavedWork() || gwPrefPanel_1.gwPrefPanel.isDirty()) {
            window.onbeforeunload = function () { return _this.onBeforeUnload(); };
        }
        else {
            this.clearBeforeUnload();
        }
    };
    /**
     * Clears any currently registered onBeforeUnload handler
     */
    GwEvents.prototype.clearBeforeUnload = function () {
        window.onbeforeunload = null;
    };
    /**
     * Checks whether an onBeforeUnload handler has been registered.
     */
    GwEvents.prototype.isBeforeUnloadRegistered = function () {
        return window.onbeforeunload !== null;
    };
    /**
     * @public
     * should be called on any page reload.
     */
    GwEvents.prototype.orderSpecificInit = function (isFullReload, reloadProps) {
        this.addInlineEventListenersToDom();
        if (isFullReload) {
            document.body.addEventListener("copy", this.onGlobalCopyEvent.bind(this));
            document.body.addEventListener("cut", this.onGlobalCutEvent.bind(this));
            document.body.addEventListener("paste", this.onGlobalPasteEvent.bind(this));
            document.body.addEventListener("keydown", this.onGlobalKeyEvent.bind(this));
            document.body.addEventListener("focusin", this.onGlobalFocusinEvent.bind(this));
            document.body.addEventListener("focusout", this.onGlobalFocusoutEvent.bind(this));
            document.addEventListener("mouseover", this.onGlobalMouseoverEvent.bind(this));
            document.addEventListener("mousemove", this.onGlobalMouseMoveEvent.bind(this));
            document.addEventListener("mouseout", this.onGlobalMouseOutEvent.bind(this));
            document.addEventListener("click", this.onGlobalMouseClickEvent.bind(this));
            document.addEventListener("dblclick", this.onGlobalMouseDblClickEvent.bind(this));
            window.addEventListener("dragover", this.onGlobalDragoverEvent.bind(this)); //TODO: these events are only used by the file drag and drop system. One day, it would be nice to hook them into the more generic mousemovement based drags
            window.addEventListener("drop", this.onGlobalDropEvent.bind(this));
            window.addEventListener("touchstart", this.onGlobalTouchstartEvent.bind(this));
            window.addEventListener("touchcancel", this.onGlobalTouchcancelEvent.bind(this));
            document.addEventListener("mousedown", this.onGlobalDragstartEvent.bind(this));
            document.addEventListener("mouseup", this.onGlobalDragendEvent.bind(this));
            // Add listener on capture phase as scroll events do not bubble
            window.addEventListener("scroll", this.onGlobalScrollEvent.bind(this), true);
        }
        this.possiblyAddOnBeforeUnloadHandler();
        //onChange and onInput events don't work if they are added at the body or window level,
        //so we attach them to the <form> tag instead
        var gwBody = gwUtil_1.gwUtil.getDomNode(".gw-body");
        //The body can be swapped by a diff (login!) so check that these are still registered
        if (gwBody && !(gwBody.hasAttribute("onchange") && gwBody.hasAttribute("oninput"))) {
            gwBody.setAttribute("onchange", "gw.globals.gwEvents.onGlobalChangeEvent(event)");
            gwBody.setAttribute("oninput", "gw.globals.gwEvents.onGlobalInputEvent(event)");
        }
        if (this.tempActiveId) {
            gwUtil_1.gwUtil.removeClass("#" + this.tempActiveId, "gw-event-temp-active");
            this.tempActiveId = null;
        }
    };
    GwEvents.prototype.onBeforeUnload = function () {
        return gwDisplayKey_1.gwDisplayKey.get("Web.Client.ConfirmNavigateAway");
    };
    GwEvents.prototype.onGlobalDragstartEvent = function (event) {
        var _this = this;
        // Ignore drag events if anything resembling a right click happens
        if (event.ctrlKey || event.metaKey || event.which === 3 || event.button === 2) {
            return;
        }
        //Register that the mouse is down for the focusIn event
        this.mouseDown = true;
        //Unset mouseDown in the next frame
        setTimeout(function () { return _this.mouseDown = false; }, 0);
        event.stopPropagation();
        if (event.target) {
            // Check to see if there's a click for the target and cancel drag if there is
            if (event.target.hasAttribute("data-gw-click")) {
                gwUtil_1.gwUtil.eventLog("onGlobalDragstartEvent - click event detected, dropping drag start");
                return;
            }
            var queryStr = "[data-gw-draggable]";
            var draggableSelfOrParent = $(event.target).closest(queryStr)[0];
            if (draggableSelfOrParent) {
                event.preventDefault();
                this.abstractOnEvent(draggableSelfOrParent, event);
            }
        }
    };
    GwEvents.prototype.onGlobalDragEvent = function (event) {
        this.abstractGlobalForPostStartDragEvents(event);
    };
    GwEvents.prototype.onGlobalDragendEvent = function (event) {
        this.abstractGlobalForPostStartDragEvents(event);
    };
    // Currently only triggered in escapeKeyPressed
    // If we end up wanting to handle mouse cancel when the mouse leaves the document,
    // we'd need to have mousemove check for being outside the document constraints,
    // because mouseleave doesn't fire when the mouse is held down
    GwEvents.prototype.onGlobalDragcancelEvent = function (event) {
        this.abstractGlobalForPostStartDragEvents(event);
    };
    GwEvents.prototype.abstractGlobalForPostStartDragEvents = function (event) {
        event.stopPropagation();
        var beingDragged = gwDraggable_1.gwDraggable.getBeingDragged();
        if (beingDragged) {
            event.preventDefault();
            this.abstractOnEvent(beingDragged, event);
        }
    };
    GwEvents.prototype.onGlobalCopyEvent = function (event) {
        if (event.target) {
            this.abstractOnEvent(event.target, event);
        }
    };
    GwEvents.prototype.onGlobalPasteEvent = function (event) {
        if (event.target) {
            this.abstractOnEvent(event.target, event);
        }
    };
    GwEvents.prototype.onGlobalCutEvent = function (event) {
        this.onGlobalCopyEvent(event);
    };
    /**
     * Looks for the closest element with attribute '"data-gw-" + type' and fires abstractOnEvent normally.
     * @param event
     * @param type
     * @returns {mouseableSelfOrParent} Returns the element the event is associated with
     */
    GwEvents.prototype.abstractGlobalMouseEvent = function (event, type, forceAllowEvent) {
        if (forceAllowEvent === void 0) { forceAllowEvent = false; }
        event.stopPropagation();
        var queryStr = "[data-gw-" + type + "]";
        var mouseableSelfOrParent;
        if (event.target) {
            mouseableSelfOrParent = $(event.target).closest(queryStr)[0];
            if (mouseableSelfOrParent) {
                this.abstractOnEvent(mouseableSelfOrParent, event, forceAllowEvent);
            }
        }
        return mouseableSelfOrParent;
    };
    GwEvents.prototype.onGlobalMouseoverEvent = function (event) {
        this.abstractGlobalMouseEvent(event, "mouseenter", false);
    };
    GwEvents.prototype.onGlobalMouseClickEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalMouseClick", event);
        this.clearLostFocusTimer();
        var targetNode = event.target;
        this.handleDeferredChangeEvent(targetNode);
        //If events are currently disabled but we still got a mouse click event then we assume that the mouse click caused a loss of focus which in
        //turn caused a post on change AJAX request which disabled events. In that case we want to process the mouse click after the post on change
        //completes, so we save it on the event queue to be processed when the response arrives.
        if (!this.areEventsEnabled() && document.activeElement) {
            var mouseableSelfOrParent = $(document.activeElement).closest("[data-gw-click]")[0];
            if (mouseableSelfOrParent &&
                this.isEventEnabledOnNode(mouseableSelfOrParent, "click") &&
                mouseableSelfOrParent.id) {
                this.eventQueue.push({ id: mouseableSelfOrParent.id, e: event });
            }
        }
        var mouseEventElement = this.abstractGlobalMouseEvent(event, "click", false);
        if (targetNode) {
            this.doAfterAnyClick(mouseEventElement || targetNode);
        }
        this.isInTouchEvent = false;
        this.allowNextDoubleClickEvent = !mouseEventElement;
    };
    GwEvents.prototype.onGlobalMouseDblClickEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalDblMouseClick", event);
        if (!this.allowNextDoubleClickEvent) {
            gwUtil_1.gwUtil.eventLog("onGlobalDblMouseClick - allowNextDoubleClickEvent set to false, dropping double click event");
            this.allowNextDoubleClickEvent = true; // Just in case -> this should always be reset by click event
            return;
        }
        this.clearLostFocusTimer();
        this.handleDeferredChangeEvent(event.target);
        this.abstractGlobalMouseEvent(event, "dblclick", false);
        this.isInTouchEvent = false;
    };
    /**
     * Mouse move is special because an element may want to watch for mouse move events even though
     * the mouse isn't over the element any more, in which case our usual approach of looking up the
     * DOM from the event target won't find the interested party. So we allow one system at a time
     * to register as the "mouse move owner", and they'll be sent all mouse move events until they
     * surrender their ownership.
     *
     * @param event the mouse move event
     */
    GwEvents.prototype.onGlobalMouseMoveEvent = function (event) {
        if (this.mouseMoveOwner) {
            event.stopPropagation();
            this.mouseMoveOwner(event);
            return;
        }
        this.abstractGlobalMouseEvent(event, "mousemove", false);
    };
    /**
     * Set the mouse move owner. The argument should be a function to be called with future mouse
     *  Returns a function that the caller can call to surrender ownership of mouse movement
     * @param newOwner a function to be called on future mouse move events
     */
    GwEvents.prototype.setMouseMoveOwner = function (newOwner) {
        var _this = this;
        if (this.mouseMoveOwner) {
            throw new Error("Only one system at a time can own the mouse move event");
        }
        var surrendered = false;
        this.mouseMoveOwner = newOwner;
        return function () {
            if (_this.mouseMoveOwner === newOwner && !surrendered) {
                _this.mouseMoveOwner = null;
                surrendered = true;
            }
        };
    };
    GwEvents.prototype.onGlobalMouseOutEvent = function (event) {
        //Force mouseout events even when the events are disabled
        this.abstractGlobalMouseEvent(event, "mouseout", true);
    };
    GwEvents.prototype.isCurrentlyInTouchEvent = function () {
        return this.isInTouchEvent;
    };
    GwEvents.prototype.onGlobalTouchstartEvent = function (event) {
        this.isInTouchEvent = true;
    };
    GwEvents.prototype.onGlobalTouchcancelEvent = function (event) {
        this.isInTouchEvent = false;
    };
    /**
     *
     * Currently we handle the following cases:
     * 1) for <select>, when the selection is changed
     * 2) textarea, input:password, input:search: input:text; during onblur if the value's been changed
     *
     * TODO: input:file, input:range slightly different?
     *       input:checkbox and input:radio may be handled differently in IE?
     *
     * The complicated part is we need to know if the element that caused the blur, (clicked or tabbed to),
     * is actually a child of the widget holding the input, meaning, the user has clicked something like the
     * autocomplete widget. In that case, we don't want to fire the onChange method.
     *
     * The only way for us to know that, is to wait for the blur event, and then run all the logic there.
     *
     * So, here, we set a flag to tell the following on blur event to run all the on change logic.
     * Unless this event is the result of a call to forceGlobalEvent, in which case we process the event normally.
     * @type {boolean}
     */
    GwEvents.prototype.onGlobalChangeEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalChangeEvent", event);
        gwForm_1.gwForm.elementChanged(event.target);
        var target = this.findEnclosingWidget(event.target);
        if (target) {
            // If there's a target, and this event was the result of a forceGlobalEvent or has data-gw-always-change, then
            // handle the event.
            if (GwForcedEvent_1.GwForcedEvent.isGwForcedEvent(event)
                || event.target.hasAttribute("data-gw-always-change")
                || target.hasAttribute("data-gw-always-change")
                || (this.isImmediateChangeNodeType(event.target) && !this.isMultiPartInput(target))) {
                this.abstractOnEvent(target, event);
            }
            else {
                this.setPendingChangesOnElement(target);
            }
        }
    };
    GwEvents.prototype.findEnclosingValueWidget = function (el) {
        return gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(el, "gw-ValueWidget");
    };
    //START HERE, just cleaning up, though this is named poorly
    GwEvents.prototype.findEnclosingWidget = function (el) {
        // TODO skwon:  maybe we can use class = gw-ValueWidget for this as tmorris suggested?
        return gwUtil_1.gwUtil.getSelfOrFirstParentWithEitherAttr(el, ["data-gw-change", "data-gw-reflection-trigger"]);
    };
    GwEvents.prototype.setPendingChangesOnElement = function (el) {
        gwUtil_1.gwUtil.eventLog("setPendingChangesOnElement: el: ", el);
        el.setAttribute("data-gw-pending-change", "");
    };
    /**
     * Returns whether or not an input has multiple child inputs
     * @param el
     * @returns {boolean}
     */
    GwEvents.prototype.isMultiPartInput = function (el) {
        var widget = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(el, "data-gw-multi-input");
        return widget !== null;
    };
    GwEvents.prototype.isImmediateChangeNodeType = function (node) {
        var inputType = gwInputs_1.gwInputs.inputType(node);
        if (inputType === "select") {
            var widget = this.findEnclosingWidget(node);
            var isShuttleList = gwUtil_1.gwUtil.hasClass(widget, "gw-RangeShuttleValueWidget");
            return !isShuttleList;
        }
        else if (inputType === "checkbox" || inputType === "radio" || inputType === "button" || inputType === "file") {
            return true;
        }
        return false;
    };
    /**
     * IE11 fires extra input event when focus enters or leaves an empty input with a placeholder. The
     * extra event on entry is fairly harmless but the one on leave can cause the autocomplete dropdown
     * to appear on the wrong input when tabbing between two autocomplete inputs. So watch for this
     * particular case and ignore it. For more details see:
     *
     * https://connect.microsoft.com/IE/feedback/details/810538/ie-11-fires-input-event-on-focus
     * http://jsfiddle.net/H8XTX/11/
     *
     * @param node the event target
     * @param e the event
     * @returns {boolean}
     */
    GwEvents.prototype.isBogusIE11InputEvent = function (e) {
        return gwUtil_1.gwUtil.isIE11() && e.target !== document.activeElement;
    };
    /**
     * Input event fires every time the value of an input changes
     * @param event
     */
    GwEvents.prototype.onGlobalInputEvent = function (event) {
        if (this.isBogusIE11InputEvent(event)) {
            gwUtil_1.gwUtil.eventLog("###! Ignoring Input Event", event);
            return;
        }
        gwUtil_1.gwUtil.eventLog("### onGlobalInputEvent", event);
        if (event.target) {
            gwForm_1.gwForm.elementChanged(event.target);
            this.abstractOnEvent(event.target, event);
        }
    };
    GwEvents.prototype.checkForLostFocus = function (relatedTarget) {
        // Called from the focusout handler. If the focusout event's related target is either null
        // (Chrome/Firefox) or the root HTML element (IE) then we are either clicking on a non focusable
        // element or focus is leaving the document entirely. In such cases we may not get a subsequent
        // focusin or click event, which will mean any deferred change won't get applied. To fix this
        // we set a timer. If there are focusin or click events queued they'll cancel the timer
        // and do our normal processing. But if there are no events queued the timer will fire and apply
        // any deferred change
        this.clearLostFocusTimer();
        if (!relatedTarget || relatedTarget === document.documentElement) {
            this.lostFocusTimer = setTimeout(this.onLostFocus.bind(this), 0);
        }
    };
    GwEvents.prototype.clearLostFocusTimer = function () {
        if (this.lostFocusTimer >= 0) {
            clearTimeout(this.lostFocusTimer);
            this.lostFocusTimer = -1;
        }
    };
    GwEvents.prototype.onLostFocus = function () {
        gwUtil_1.gwUtil.eventLog("### onLostFocus");
        this.handleDeferredChangeEvent(null, true);
    };
    /**
     * @private
     * Sets gwNavigation.lastFocused
     * Then processes the blur event
     * Then if processChangeEventInBlurEvent, process a change event
     *
     * @param event
     */
    GwEvents.prototype.onGlobalFocusoutEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalFocusout", event);
        gwFocus_1.gwFocus.setLastFocus(event.target);
        var target = event.target;
        var relatedTarget = event.relatedTarget;
        gwHelpText_1.gwHelpText.focusOut();
        // Run the blur event first if it exists
        var blurMethodOwner = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(target, "data-gw-blur");
        // If the related target of the blur event is contained by the containing widget, then ignore the event
        if (blurMethodOwner && !blurMethodOwner.contains(relatedTarget)) {
            this.abstractOnEvent(blurMethodOwner, event);
        }
        this.checkForLostFocus(relatedTarget);
        event.stopPropagation();
        event.preventDefault();
    };
    GwEvents.prototype.processEventQueue = function () {
        if (this.eventQueue.length > 0) {
            var eventObj = this.eventQueue.shift();
            if (eventObj) {
                var actionElement = gwUtil_1.gwUtil.getDomNode("#" + eventObj.id);
                if (actionElement) {
                    this.abstractOnEvent(actionElement, eventObj.e);
                }
            }
        }
    };
    GwEvents.prototype.clearEventQueue = function () {
        this.eventQueue = [];
    };
    /**
     * @private
     * Stores the currentFocus and lastFocus globals. Then fires abstractOnEvent, passing the newly set currentFocus as the node.
     * @param event
     */
    GwEvents.prototype.onGlobalFocusinEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalFocusinEvent", event);
        this.clearLostFocusTimer();
        var nodeToFocus = event.target;
        if (!nodeToFocus) {
            return;
        }
        else if (nodeToFocus.hasAttribute && nodeToFocus.hasAttribute("data-gw-refuse-focus")) {
            gwFocus_1.gwFocus.restoreFocus(false);
            return;
        }
        var isFocusable = gwFocus_1.gwFocus.isFocusable(nodeToFocus, !this.mouseDown);
        //If the mouse is down, don't allow searching down
        if (this.mouseDown && !isFocusable) {
            //If the clicked node isn't focusable, search up until we find one
            nodeToFocus = gwFocus_1.gwFocus.findFocusableNodeForClick(nodeToFocus);
            gwUtil_1.gwUtil.eventLog("Target not focusable; updated target: ", nodeToFocus);
        }
        if (nodeToFocus) {
            gwFocus_1.gwFocus.setCurrentFocus(nodeToFocus);
            gwHelpText_1.gwHelpText.focusIn(nodeToFocus);
            this.handleDeferredChangeEvent(nodeToFocus);
            this.abstractOnEvent(event.target, event);
        }
        else {
            gwFocus_1.gwFocus.restoreFocus(false);
        }
        event.stopPropagation();
        event.preventDefault();
    };
    GwEvents.prototype.handleDeferredChangeEvent = function (targetNode, allowNullTarget) {
        if (allowNullTarget === void 0) { allowNullTarget = false; }
        if (!targetNode && !allowNullTarget) {
            gwUtil_1.gwUtil.eventLog("handleDeferredChangeEvent: no targetNode; no defer change needed");
            return;
        }
        var lFocus = gwFocus_1.gwFocus.getLastFocus();
        if (!lFocus) {
            gwUtil_1.gwUtil.eventLog("handleDeferredChangeEvent: no last focus; no defer change needed. Target:", targetNode);
            return;
        }
        var widgetWithPendingChange = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(lFocus, "data-gw-pending-change");
        if (!widgetWithPendingChange) {
            gwUtil_1.gwUtil.eventLog("handleDeferredChangeEvent: last focused element did not have pending; no defer change needed. Target:", targetNode);
            return;
        }
        if (allowNullTarget || !widgetWithPendingChange.contains(targetNode)) {
            var deferredChangeSystem = widgetWithPendingChange.getAttribute("data-gw-pending-change");
            widgetWithPendingChange.removeAttribute("data-gw-pending-change");
            if (deferredChangeSystem) {
                //TODO: maybe register deferred changes specifically?
                gw_1.gw.globals[deferredChangeSystem].deferredChangeOnFocusInMethod(widgetWithPendingChange); //TODO: this loads objects currently on the gw, but won't work in ts
            }
            gwUtil_1.gwUtil.eventLog("handleDeferredChangeEvent: triggering force change event. Target:", targetNode);
            this.forceGlobalEvent(widgetWithPendingChange, "change", targetNode);
        }
        else {
            gwUtil_1.gwUtil.eventLog("handleDeferredChangeEvent: still within parent widget, not sending change event. Target:", targetNode);
        }
    };
    /**
     * Fires when a user drag & drops a file on a dropzone target.
     */
    GwEvents.prototype.onGlobalDropEvent = function (event) {
        this.abstractGlobalDragDropEvent(event, "drop");
    };
    /**
     * Fires when a user drag a file over a dropzone target
     */
    GwEvents.prototype.onGlobalDragoverEvent = function (event) {
        this.abstractGlobalDragDropEvent(event, "dragover");
    };
    GwEvents.prototype.abstractGlobalDragDropEvent = function (event, type) {
        event.preventDefault();
        var queryStr = "[data-gw-" + type + "]";
        if (event.target) {
            var droppableSelfOrParent = $(event.target).closest(queryStr)[0];
            if (droppableSelfOrParent) {
                this.abstractOnEvent(droppableSelfOrParent, event);
            }
        }
    };
    /**
     * NOTE: This is being called on every scroll event; do not put anything expensive in this method
     * NOTE: We only listen to targets that are divs.
     * @param event
     */
    GwEvents.prototype.onGlobalScrollEvent = function (event) {
        // Some silly browsers call scroll when we set the values of customized select elements
        // We don't want or need that, so we'll just limit to divs for now.
        var eventTarget = event.target;
        if (!eventTarget || (eventTarget.tagName && eventTarget.tagName.toLowerCase() !== "div")) {
            return;
        }
        // If the scroll event is inside of a fixed element, like a helptext window, then leave everything open
        if (eventTarget.id === gwHelpText_1.gwHelpText.HELP_TEXT_EL_ID) {
            return;
        }
        gwMenus_1.gwMenus.closeAllMenusContainedBy(event.target);
        gwInputs_1.gwInputs.closeOpenInputs(event);
    };
    /**
     * @public
     * The event listener method placed on any elements with data-gw-"event" attributes requiring the node to listen for the event.
     * @parem node: passed to the function via inline 'this'.
     * @param event
     */
    GwEvents.prototype.onElementEvent = function (event, node) {
        var e = event;
        var forceAllowEvent = false;
        var eType = e.type;
        if (eType === "mouseleave") {
            forceAllowEvent = true;
        }
        this.abstractOnEvent(node, e, forceAllowEvent);
    };
    /**
     * @private
     * Global callback for any key event.
     * @param event
     */
    GwEvents.prototype.onGlobalKeyEvent = function (event) {
        gwUtil_1.gwUtil.eventLog("### onGlobalKeyEvent", event);
        var e = event;
        var key = this.getKeyCode(e);
        if (key !== null && key !== undefined) {
            if (gwKeys_1.gwKeys.ignoredKeyCodes[key]) {
                return;
            }
        }
        this.abstractOnEvent(e.target, e);
    };
    GwEvents.prototype.areEventsDisabled = function (node, e) {
        // Kill the event if we find disabled
        if (!this.isEventEnabledOnNode(node, e.type)) {
            //gwUtil.devlog("Event disabled via gw-disabled class: ", id);
            e.stopPropagation();
            return true;
        }
        if (!this.eventsEnabled) {
            //gwUtil.devlog("Event disabled via preventClick: " + e.type, id);
            e.stopPropagation();
            return true;
        }
        return false;
    };
    GwEvents.prototype.isEventEnabledOnNode = function (node, eventType) {
        var eventClass = "gw-" + eventType + "-enabled";
        return !gwUtil_1.gwUtil.hasClass(node, "gw-disabled") || gwUtil_1.gwUtil.hasClass(node, eventClass);
    };
    /**
     * @private
     * Given a string describing a method return the corresponding function
     * @param methodName
     * @returns {*}
     */
    GwEvents.prototype.findMethod = function (methodName) {
        var path = methodName.split(".");
        if (path.length === 1) {
            // If there isn't a deep path specified then we assume it's a method on our events methods object
            var methodOnEventMethodObject = this.methods[path[0]];
            if (typeof methodOnEventMethodObject !== "function") {
                gwUtil_1.gwUtil.devlog("WARNING: found object not of type function via data attribute path: ", methodName);
                return null;
            }
            return methodOnEventMethodObject;
        }
        // We allow the path to be dot delimited, so we walk down it to find the method
        // If they didn't include gw, then we'll start there.
        if (path[0] === "gw") {
            path.shift();
        }
        if (path[0] === "globals") {
            path.shift();
        }
        var functionChunk = null;
        var contextChunk = null;
        var chunkObject = gw_1.gw.globals;
        if (!gw_1.gw.globals[path[0]]) {
            throw new Error("Unable to locate global system " + path[0] + ". Ensure that the class is set up correctly, and is being included in the import chain.");
        }
        for (var i = 0; i < path.length; i++) {
            chunkObject = chunkObject[path[i]];
            if (i === 0) {
                contextChunk = chunkObject;
            }
            else if (i === path.length - 1) {
                if (typeof chunkObject !== "function") {
                    break;
                }
                functionChunk = chunkObject;
            }
        }
        if (contextChunk === null || functionChunk === null) {
            throw new Error("found object not of type function via data attribute path: " + methodName);
        }
        return functionChunk.bind(contextChunk);
    };
    /**
     * @private
     * If the node running this event includes a prompt, show the prompt and the optional
     * default value, and set the eventParam input to match the submitted value before continuing.
     * @return boolean false if the action was canceled, stopping the event
     */
    GwEvents.prototype.checkForAndShowPrompt = function (eventDescription) {
        if (eventDescription.eventType !== "click" && !eventDescription.replacesClick) {
            // no need to show a prompt for events other than 'click'
            return true;
        }
        var node = eventDescription.eventTargetNode;
        if (node && node.dataset && node.dataset.gwPrompt) {
            var promptText = node.dataset.gwPrompt;
            var promptDefault = node.dataset.gwPromptDefault || "";
            var response = window.prompt(promptText, promptDefault);
            if (response === null) {
                //The browser returns "null" if the prompt is canceled
                return false;
            }
            gwUtil_1.gwUtil.setEventParam("eventParam", response);
        }
        return true;
    };
    /**
     * @private
     * Fires after any mouse click event. Closes all open submenus and datepickers
     * if the click comes from outside of the submenu or the datepicker.
     * @param target - DOM element
     */
    GwEvents.prototype.doAfterAnyClick = function (target) {
        var targetIsClickable = target.hasAttribute("data-gw-click");
        // Check if click is inside a sub menu, if it is, then don't close the open menus
        var clickIsInSubmenu = !!gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(target, ".gw-subMenu");
        if (clickIsInSubmenu) {
            targetIsClickable = clickIsInSubmenu;
        }
        // If we are in a click event triggered by a touch event, then that means we've ignored all concepts of mouseover
        // Therefore we have to close all the menus ourselves.
        if (exports.gwEvents.isCurrentlyInTouchEvent() || !clickIsInSubmenu) {
            gwMenus_1.gwMenus.closeAllMenus();
        }
        gwMenus_1.gwMenus.openStoredMenu();
        // When a date picker is shown, it becomes the child of the DateValueWidget that holds the date input.
        // If the click is in a DateValueWidget, don't close the date picker
        if (!gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(target, ".gw-inDatePicker")) {
            gwDateValue_1.gwDateValue.hideDatePicker();
        }
        // When a time picker is shown, it becomes the child of the DateValueWidget that holds the date input.
        // If the click is in a DateValueWidget, don't close the date picker
        if (!gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(target, ".gw-inTimePicker")) {
            // gwDateValue.hideTimePicker();
        }
        if (!targetIsClickable && !gwFocus_1.gwFocus.focusableOnClick(target)) {
            gwFocus_1.gwFocus.clearFocus();
        }
    };
    /**
     * @private
     * This should not need to be referenced outside of this file. This is the catch all listener function for all static
     * @param node: a DOM element
     * @param e: the event object
     * @param forceAllowEvent: boolean - set to true will bypass the gw-disabled and eventsEnabled checks. Used to allow things like
     * mouseleave to let hover menus close even during a server roundtrip.
     */
    GwEvents.prototype.abstractOnEvent = function (node, e, forceAllowEvent) {
        if (forceAllowEvent === void 0) { forceAllowEvent = false; }
        if (!forceAllowEvent) {
            if (this.areEventsDisabled(node, e)) {
                return;
            }
        }
        if (e.type === "change") {
            gwInputs_1.gwInputs.clearInvalidValueStatus(node);
        }
        var eventDescription = GwEventDescription_1.GwEventDescription.getEventDescription(node, e);
        gwUtil_1.gwUtil.eventLog("abstractOnEvent for event '" + e.type + "', eventDescription:", eventDescription);
        var method = eventDescription && eventDescription.methodName && this.findMethod(eventDescription.methodName);
        var maybeReflect = (e.type === "change" && gwReflection_1.gwReflection.isReflectionTrigger(node));
        // Bail if we didn't find any method and this node is not a reflection trigger candidate
        if (!method && !maybeReflect) {
            return;
        }
        if (eventDescription) {
            // If the event's target is disabled, bail
            if (eventDescription.eventTargetNode && !this.isEventEnabledOnNode(eventDescription.eventTargetNode, eventDescription.eventType)) {
                return;
            }
            // Bail if the event needs confirmation and the user vetoes it
            if (!gwConfirm_1.gwConfirm.confirmEvent(eventDescription)) {
                return;
            }
            //If there is a prompt, show it. If the user cancels the prompt, we stop the event
            if (!this.checkForAndShowPrompt(eventDescription)) {
                return;
            }
        }
        // Stop propagation prevents the event from bubbling any further.
        e.stopPropagation();
        if (eventDescription) {
            // If the method was triggered by a key, we prevent the default behavior unless enableDefault is set
            if (this.disableDefaultBehaviorIfHandled[eventDescription.eventType]) {
                if (!eventDescription.enableDefault) {
                    e.preventDefault();
                }
            }
        }
        if (method) {
            if (eventDescription && eventDescription.unnamedArgs) {
                //then this method was defined in HTML without colon separated arguments, so we just send it the whole string after the method name
                method(node, eventDescription.unnamedArgs, e);
            }
            else {
                method(node, eventDescription, e);
            }
        }
        if (maybeReflect) {
            gwReflection_1.gwReflection.notifyTriggerChange(node.id);
        }
    };
    /**
     * @private
     * This could in theory be used elsewhere in the app, but I can't imagine where
     * Looks through the event to find one of the hundreds of possible locations various browsers store key codes
     * @param e
     * @returns {key code}
     */
    GwEvents.prototype.getKeyCode = function (e) {
        var keyCode;
        if (e.which !== undefined) {
            keyCode = e.which;
        }
        else if (e.keyCode !== undefined) {
            keyCode = e.keyCode;
        }
        else if (e.charCode !== undefined) {
            keyCode = e.charCode;
        }
        else if (e.key !== undefined) {
            keyCode = e.key;
        }
        if (keyCode === null || keyCode === undefined) {
            return null;
        }
        // This is a string, not an int, so technically will still fail
        return +keyCode;
    };
    /**
     * @private
     * Checks the current focus and returns associated scope. If the focus is inside a worksheet,
     * the scope returned is "SOUTH" else we return "CENTER".
     * @returns "SOUTH" if focus is inside a worksheet else returns "CENTER"
     */
    GwEvents.prototype.getCurrentScope = function () {
        var currentFocus = gwFocus_1.gwFocus.getCurrentFocus();
        if (!currentFocus) {
            return "NULL" /* NULL */;
        }
        if ($(currentFocus).parents("#gw-south-panel").length > 0) {
            return "SOUTH" /* SOUTH */;
        }
        else {
            return "CENTER" /* CENTER */;
        }
    };
    /**
     * @private
     * Checks to see if the gw-internalTools-flag info div is set to true, signalling that
     * internal tools are enabled
     * @returns true if internal tools are enabled, false if not.
     */
    GwEvents.prototype.internalToolsEnabled = function () {
        return gwUtil_1.gwUtil.getUtilityFlag("gw-internalTools-flag");
    };
    /**
     * Called by addInlineEventListenersToContainer,
     * allows systems to add processing to check every node in the dom, since we're already walking them for addInlineEventListeners
     * @param node
     */
    GwEvents.prototype.doCustomSystemWorkOnEveryNodeOnPageLoad = function (node) {
        gwScroll_1.gwScroll.restoreScrollForNode(node);
        gwReflection_1.gwReflection.initForNode(node);
    };
    GwEvents.prototype.addInlineEventListenersToContainer = function (contextNode) {
        if (!contextNode) {
            throw new Error("addInlineEventListenersToContainer requires a contextNode");
        }
        this.addInlineEventListenersToDom(contextNode);
    };
    /**
     * @public
     * Currently called on full or partial page reload. TODO: this could get optimized to only run on the diff nodes.
     * Iterates over every element in the dom looking for data-gw-"event" attributes, and adds the corresponding inline event listeners
     * //TODO: eventually, this could become the "walkAllDomNodesOnPageLoad" generic method.
     */
    GwEvents.prototype.addInlineEventListenersToDom = function (contextNode) {
        if (contextNode === void 0) { contextNode = document; }
        var nodes = contextNode.getElementsByTagName("*"); //TODO: need to @Optimize this one day to be more specific. Or to not walk all nodes.
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (!node) {
                continue;
            }
            this.processNodeForInlineEvents(node);
        }
    };
    GwEvents.prototype.processNodeForInlineEvents = function (node) {
        this.addAdditionalAttributes(node);
        this.doCustomSystemWorkOnEveryNodeOnPageLoad(node);
        //NOTE: all native user input elements will already have a tabIndex of 0
        if (!node.hasAttribute("data-gw-no-tab-index")) {
            if (node.hasAttribute("data-gw-click")
                || node.hasAttribute("data-gw-key")
                || node.hasAttribute("data-gw-focus")
                || node.hasAttribute("data-gw-blur")) {
                node.setAttribute("tabIndex", "0");
            }
        }
    };
    GwEvents.prototype.addInlineEventListenersToThisSpecificNode = function (el) {
        this.processNodeForInlineEvents(el);
    };
    GwEvents.prototype.addAdditionalAttributes = function (node) {
        this.addAdditionalAttributeTransforms(node, this.baseAttributeTransforms);
        this.addAdditionalAttributeTransforms(node, this.complexAttributeTransforms);
    };
    /**
     * @public
     * Enable events globally. This includes mouse, keyboard, blur, focus.  Calling enableEvents will decrement the
     * current lock count by 1 and will only enable events if the underlying lock count is <= 0.
     *
     * Lock count is incremented every time {@method disabledEvents} is called.
     *
     */
    GwEvents.prototype.enableEvents = function () {
        if (this.eventLockCount < 1) {
            gwUtil_1.gwUtil.devlog("WARNING: (enableEvents) Encountered unexpected event lock count (resetting to 0): " + this.eventLockCount);
            this.eventLockCount = 0;
        }
        else {
            this.eventLockCount--;
        }
        if (this.eventLockCount === 0) {
            this.eventsEnabled = true;
            this.onEventsEnabled();
        }
    };
    GwEvents.prototype.onEventsEnabled = function () {
        gwTooltips_1.gwTooltips.hide();
        gwUtil_1.gwUtil.removeClass(".gw-click-overlay", "gw-disable-click");
    };
    GwEvents.prototype.onEventsDisabled = function () {
        gwUtil_1.gwUtil.addClass(".gw-click-overlay", "gw-disable-click");
        gwTooltips_1.gwTooltips.hide();
    };
    /**
     * @public
     * Disable events globally. This includes mouse, keyboard, blur, focus.  Each call to this method will increment
     * an underlying lock counter.
     */
    GwEvents.prototype.disableEvents = function () {
        if (this.eventLockCount < 0) {
            gwUtil_1.gwUtil.devlog("WARNING: (disableEvents) Encountered unexpected event lock count (resetting to 0): " + this.eventLockCount);
            this.eventLockCount = 0;
        }
        if (this.eventLockCount === 0) {
            this.eventsEnabled = false;
            this.onEventsDisabled();
        }
        this.eventLockCount++;
    };
    /**
     * Indicates whether events are currently enabled.
     * @returns {boolean}
     */
    GwEvents.prototype.areEventsEnabled = function () {
        return this.eventsEnabled;
    };
    GwEvents.prototype.disableNavigationConfirmationUntilUserCancelsConfirm = function () {
        this.clearBeforeUnload();
        this.navigationConfirmIsDisabled = true;
    };
    GwEvents.prototype.confirmationCancelled = function () {
        this.navigationConfirmIsDisabled = false;
        this.possiblyAddOnBeforeUnloadHandler();
    };
    GwEvents.prototype.handleOnChangeMethod = function (onChangeMethod, node, args) {
        if (this.methods[onChangeMethod]) {
            this.methods[onChangeMethod](node, args);
        }
        else {
            gwUtil_1.gwUtil.devlog("WARNING: handleOnChangeMethod - Unknown events method: ", onChangeMethod);
        }
    };
    return GwEvents;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwEvents = GwEvents;
exports.gwEvents = new GwEvents();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gw_1 = __webpack_require__(10);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwInitializableSystem = /** @class */ (function (_super) {
    __extends(GwInitializableSystem, _super);
    function GwInitializableSystem() {
        var _this = _super.call(this) || this;
        if (_this.availableToInitialize()) {
            gw_1.gw.registerInitializableSystem(_this);
        }
        return _this;
    }
    GwInitializableSystem.prototype.availableToInitialize = function () {
        return true;
    };
    return GwInitializableSystem;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwInitializableSystem = GwInitializableSystem;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwTypes_1 = __webpack_require__(20);
var gwResizer_1 = __webpack_require__(35);
var gwEvents_1 = __webpack_require__(3);
var gwFocus_1 = __webpack_require__(8);
var gwHelpText_1 = __webpack_require__(81);
var gwJic_1 = __webpack_require__(40);
var gwJicHelper_1 = __webpack_require__(84);
var gwReflection_1 = __webpack_require__(54);
var gwCurrency_1 = __webpack_require__(226);
var gwForm_1 = __webpack_require__(25);
var gwDateValue_1 = __webpack_require__(55);
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwTextValue_1 = __webpack_require__(228);
var GwInputs = /** @class */ (function (_super) {
    __extends(GwInputs, _super);
    function GwInputs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // This needs to match the default placeholder character in TextValueInputMask.java
        _this.DEFAULT_INPUT_MASK_PLACEHOLDER_CHAR = "#";
        _this.clearTrailingMaskCharacters = true;
        return _this;
    }
    GwInputs.prototype.getSystemName = function () {
        return "gwInputs";
    };
    GwInputs.prototype.setCheckedOnInput = function (classIdTagOrNode, checked) {
        var el = gwUtil_1.gwUtil.getInputElement(classIdTagOrNode);
        if (!el) {
            throw new Error("Unable to locate element " + classIdTagOrNode);
        }
        if (el.tagName.toLowerCase() !== "input") {
            throw new Error("Tried to setCheckedOnInput on a non select element.");
        }
        if (checked === true || checked === "true" || checked === "checked") {
            checked = true;
        }
        else {
            checked = false;
        }
        el.checked = checked;
    };
    /**
     * If an input has a data-gw-undo property, then swaps the value and the data-gw-undo value and calls prevent default.
     * @param el
     * @param args
     * @param e
     */
    GwInputs.prototype.undo = function (el, args, e) {
        if (el.hasAttribute("data-gw-undo")) {
            var tempValue = el.value;
            el.value = el.getAttribute("data-gw-undo") || "";
            el.setAttribute("data-gw-undo", tempValue);
            e.preventDefault();
            this.notifySystemsOfInputValueChange(el, "undo", args, e);
        }
    };
    /**
     * Takes a addonDiv and attempts to align it to an input inside of a given parent div.
     *
     * Attempts to align it to the left edge of the input it's displayed for.
     * - If it's offscreen right, then aligns it to the right of the input.
     * Similarly with positioning below the input, or above it.
     *
     * @param parent - the value widget
     * @param input - the dom element for the picker to be aligned to
     * @param addonDiv - the dom element being aligned
     *
     * @link - gwResizer.windowHeight, gwResizer.windowWidth
     * @private
     */
    GwInputs.prototype.preventPickerBeingOffscreen = function (parent, input, addonDiv, alignRight, alignTop) {
        if (alignRight === void 0) { alignRight = false; }
        if (alignTop === void 0) { alignTop = false; }
        var boundaries = {
            top: 0,
            bottom: window.innerHeight,
            left: 0,
            right: window.innerWidth
        };
        var inputRect = input.getBoundingClientRect();
        var pickerRect = addonDiv.getBoundingClientRect();
        // -------- Setup ------------
        var pickerWidth = pickerRect.width;
        var bodyWidth = gwResizer_1.gwResizer.windowWidth;
        var leftPosWhenAlignedLeft = inputRect.left + "px";
        var leftPosWhenAlignedRight = (inputRect.right - pickerWidth) + "px";
        var pickerHeight = pickerRect.height;
        var bodyHeight = gwResizer_1.gwResizer.windowHeight;
        var bottomPosWhenAboveInput = (bodyHeight - inputRect.top) + "px";
        var topPosWhenBelowInput = inputRect.bottom + "px";
        // ------- Horizontal Alignment --------
        var fitsWhenLeft = (inputRect.left + pickerWidth <= bodyWidth) && inputRect.left >= boundaries.left;
        var fitsWhenRight = (inputRect.right - pickerWidth >= 0) && inputRect.right <= boundaries.right;
        var linesUpHorizontally = (alignRight && fitsWhenRight) || (!alignRight && fitsWhenLeft);
        var neitherSideOnScreen = !fitsWhenRight && !fitsWhenRight;
        // If the default alignment works, or both edges of the input are off the screen, use default alignment
        if (linesUpHorizontally || neitherSideOnScreen) {
            addonDiv.style.left = alignRight ? leftPosWhenAlignedRight : leftPosWhenAlignedLeft;
        }
        else {
            addonDiv.style.left = fitsWhenLeft ? leftPosWhenAlignedLeft : leftPosWhenAlignedRight;
        }
        addonDiv.style.right = "auto";
        // --------- Vertical Alignment ---------
        var fitsWhenAbove = (inputRect.top - pickerHeight >= 0) && inputRect.top <= bodyHeight;
        var fitsWhenBelow = (inputRect.bottom + pickerHeight <= bodyHeight) && inputRect.bottom >= 0;
        var linesUpVertically = (alignTop && fitsWhenAbove) || (!alignTop && fitsWhenBelow);
        var neitherEdgeOnScreen = !fitsWhenAbove && !fitsWhenBelow;
        // If the default alignment works, or both edges of the input are off the screen, use default alignment
        if (linesUpVertically || neitherEdgeOnScreen) {
            this.renderAddOnDiv(addonDiv, alignTop, topPosWhenBelowInput, bottomPosWhenAboveInput);
        }
        else {
            this.renderAddOnDiv(addonDiv, fitsWhenAbove, topPosWhenBelowInput, bottomPosWhenAboveInput);
        }
    };
    GwInputs.prototype.renderAddOnDiv = function (targetDiv, renderAbove, topPosWhenBelow, bottomPosWhenAbove) {
        if (renderAbove) {
            targetDiv.style.top = "auto";
            targetDiv.style.bottom = bottomPosWhenAbove;
        }
        else {
            targetDiv.style.top = topPosWhenBelow;
            targetDiv.style.bottom = "auto";
        }
    };
    GwInputs.prototype.getTrueFalseOrNullFromDomAttrValue = function (val) {
        if (!gwUtil_1.gwUtil.hasValue(val)) {
            return null;
        }
        if (val === false || val === "false") {
            return false;
        }
        return true;
    };
    /**
     * Setting an input's value to true or false can have unexpected outcomes, in different browsers, but mainly just because
     * true and false become the strings "true" and "false" or true becomes empty string, etc. So this method handles all of the possible
     * cases, also checking the 'checked' property.
     * @param el
     * @returns {boolean}
     */
    GwInputs.prototype.getValueAsBoolean = function (el) {
        var val = this.getTrueFalseOrNullFromDomAttrValue(el.getAttribute("value"));
        if (val !== null) {
            return val;
        }
        var checked = this.getTrueFalseOrNullFromDomAttrValue(el.checked);
        if (checked !== null) {
            return checked;
        }
        return false;
    };
    /**
     * see getValueAsBoolean, for the reasons behind needing this method.
     * Eventually fired gwEvents.forceGlobalEvent(el, "change")
     * @param node
     * @param args: if args.ignoreChangeEvent is true, then forceGlobalEvent will not be called.
     * @param e
     */
    GwInputs.prototype.toggleBooleanValue = function (node, args, e) {
        var input;
        if (args.id) {
            input = gwUtil_1.gwUtil.getDomNodeByName(args.id) || gwUtil_1.gwUtil.getDomNode("#" + args.id);
        }
        else {
            input = node;
        }
        if (!input) {
            return;
        }
        var toggledValue = !this.getValueAsBoolean(input);
        input.setAttribute("value", "" + toggledValue);
        input.checked = toggledValue;
        if (!args.ignoreChangeEvent) {
            gwEvents_1.gwEvents.forceGlobalEvent(input, "change");
        }
    };
    /**
     * Clears the invalid value status from the ValueWidget parent of the given Node
     */
    GwInputs.prototype.clearInvalidValueStatus = function (node) {
        $(node).closest("div.gw-ValueWidget").removeClass("gw-ValueWidget--invalid");
    };
    /**
     * Adds an invalid value status from the Valuewidget parent of the given Node
     */
    GwInputs.prototype.addInvalidValueStatus = function (node) {
        $(node).closest("div.gw-ValueWidget").addClass("gw-ValueWidget--invalid");
    };
    /**
     * Return the type of the input as a simple string. Often this is just "input.type", but also looks
     * for the special cases of select controls (result is "select") and textarea (result is "text")
     * @param input an HTML input, select or textarea element
     * @returns {string|null} type, as a string, or null if the given element is not an input
     */
    GwInputs.prototype.inputType = function (input) {
        if (input.tagName === "SELECT") {
            return "select";
        }
        else if (input.tagName === "OPTION") {
            return "option";
        }
        else if (input.tagName === "TEXTAREA") {
            return "text";
        }
        else if (input.tagName === "INPUT") {
            return input.type;
        }
        else {
            return null;
        }
    };
    /**
     * Find the index of the select option that was originally selected. Assumes no multiselect.
     * @param select an HTMLSelectElement
     * @returns {number} the index of the option that was originally selected, or 0 if none were selected
     */
    GwInputs.prototype.defaultSelectedIndex = function (select) {
        var result = 0;
        gwUtil_1.gwUtil.forEach(select.options, function (option, key, coll, i) {
            if (option.defaultSelected) {
                result = i;
            }
        });
        return result;
    };
    /**
     * Given a single radio button input, finds all other radio inputs with the same name and returns them
     * as a JQuery collection
     * @param radio a radio input
     */
    GwInputs.prototype.radioButtonsInGroup = function (radio) {
        return gwUtil_1.gwUtil.getDomNodesByAttr("name", radio.name);
    };
    /**
     * Search the page for the input with the given name. If found, return its DOM node. Otherwise return null
     */
    GwInputs.prototype.getInputByName = function (name) {
        return gwUtil_1.gwUtil.getDomNodeByName(name);
    };
    GwInputs.prototype.inputEventNotifySystems = function (el, args, e) {
        this.notifySystemsOfInputValueChange(el, null, args, e);
    };
    GwInputs.prototype.pasteEventNotifySystems = function (el, args, e) {
        if (el.hasAttribute("data-gw-currency-info")) {
            gwCurrency_1.gwCurrency.pasteOnCurrencyInput(el, args, e);
        }
    };
    GwInputs.prototype.copyEventNotifySystems = function (el, args, e) {
        if (el.hasAttribute("data-gw-input-mask")) {
            this.copyOnInputMask(el, args, e);
        }
        if (el.hasAttribute("data-gw-currency-info")) {
            gwCurrency_1.gwCurrency.copyOnCurrencyInput(el, args, e);
        }
    };
    GwInputs.prototype.notifySystemsOfInputValueChange = function (el, ignoreSystem, args, e) {
        if (ignoreSystem !== "autocomplete" && el.hasAttribute("data-gw-autocomplete")) {
            gwTextValue_1.gwTextValue.autocomplete(el);
        }
        if (ignoreSystem !== "inputmask" && el.hasAttribute("data-gw-input-mask")) {
            this.valueChangedSoProcessInputMask(el);
        }
        if (ignoreSystem !== "picker" && ignoreSystem !== "datepicker") {
            gwDateValue_1.gwDateValue.notifyPickerOfInputChange(el);
        }
        if (ignoreSystem !== "currencyinfo" && el.hasAttribute("data-gw-currency-info")) {
            gwCurrency_1.gwCurrency.valueChangedSoProcessCurrencyInfo(el);
        }
        var enclosingWidget = gwEvents_1.gwEvents.findEnclosingValueWidget(el);
        if (enclosingWidget) {
            gwUtil_1.gwUtil.eventLog("notifySystemsOfInputValueChange: setPendingChangesOnElement: ", enclosingWidget);
            gwEvents_1.gwEvents.setPendingChangesOnElement(enclosingWidget);
        }
        gwForm_1.gwForm.elementChanged(el);
    };
    GwInputs.prototype.hasDigitsOnlyMask = function (el) {
        return el.hasAttribute("data-gw-digit-mask");
    };
    GwInputs.prototype.clearElementWithInputMaskValue = function (el) {
        this.setValueOnElementWithInputMask(el, null);
    };
    GwInputs.prototype.setValueOnElementWithInputMask = function (el, val) {
        if (val === null) {
            val = "";
        }
        val = "" + val;
        el.value = val;
        el.setAttribute("data-gw-prev", val);
    };
    /**
     * We use this to handle the times where a placeholder has been translated in a way that renders it an illegal mask value.
     * We only return the ph if it's the same length as the mask, otherwise, we return the mask
     * @param {GwInputElement} el
     * @param {string} mask
     * @returns {string}
     */
    GwInputs.prototype.getPlaceholderValueOrMaskIfPlaceholderIsIncorrectLength = function (el, mask) {
        var ph = el.hasAttribute("placeholder") ? el.getAttribute("placeholder") : mask;
        return (ph && ph.length === mask.length) ? ph : mask;
    };
    /**
     * Fired for any input that has data-gw-input-mask.
     * Uses logic based on the contents of the input mask, and if the mask allows only numerical input,
     * to allow only certain input from the user
     * @param el - an input element
     * @param args - not used
     * @param e - not used
     */
    GwInputs.prototype.valueChangedSoProcessInputMask = function (el) {
        if (!el) {
            return;
        }
        if (el.type === "password") {
            return;
        }
        var mask = el.getAttribute("data-gw-input-mask");
        if (!mask) {
            return;
        }
        var placeholderCharacter = el.getAttribute("data-gw-input-mask-placeholder")
            || this.DEFAULT_INPUT_MASK_PLACEHOLDER_CHAR;
        var currentFullInputValue = el.value;
        if (!gwUtil_1.gwUtil.hasValue(currentFullInputValue) || currentFullInputValue.length === 0) {
            this.clearElementWithInputMaskValue(el);
            return;
        }
        currentFullInputValue = gwUtil_1.gwUtil.convertAllWhitespaceToStandard(currentFullInputValue);
        var previousFullInputValue = el.getAttribute("data-gw-prev") || currentFullInputValue;
        var userAddedACharacter = currentFullInputValue.length - previousFullInputValue.length >= 0;
        var placeholderCharMatcher; // These two will change based on whether this mask is isDigitsOnlyMask
        var validInputCharRegex;
        var isDigitsOnlyMask = this.hasDigitsOnlyMask(el);
        var runningCursorOffset = 0;
        if (gwJic_1.gwJic.isJIC(el)) {
            var valueRemainingAfterEraRemoved = gwJic_1.gwJic.possiblyHandleEraValue(currentFullInputValue, el);
            if (valueRemainingAfterEraRemoved.length === 0) {
                this.clearElementWithInputMaskValue(el);
                return;
            }
            runningCursorOffset = valueRemainingAfterEraRemoved.length - currentFullInputValue.length;
            currentFullInputValue = valueRemainingAfterEraRemoved;
        }
        if (isDigitsOnlyMask) {
            // Match all letters plus placeholder character
            placeholderCharMatcher = new RegExp("([A-Za-z" + gwUtil_1.gwUtil.escapeForRegExp(placeholderCharacter) + "])", "g");
            validInputCharRegex = /\d/g; // Match all digits
            // If it's a numbers only mask, then we allow the placeholder to be localized differently than the mask
            // The mask will be used by systems like date input to handle logic, but the placeholder will
            // be used to fill in the input value while the user is inputting.
            mask = this.getPlaceholderValueOrMaskIfPlaceholderIsIncorrectLength(el, mask);
        }
        else {
            // Match only the single placeholder character
            placeholderCharMatcher = new RegExp(gwUtil_1.gwUtil.escapeForRegExp(placeholderCharacter), "g");
            validInputCharRegex = /./g; // Match everything
        }
        var placeholderMaskChars = {}; // by default is #, if mask isDigitsOnlyMask, then it's also any letters
        var staticMaskChars = {}; // Anything in the input mask that is not a phChar
        // Build sets of placeholder characters and special character based on the inputMask and isDigitsOnlyMask flag
        gwUtil_1.gwUtil.forEach(mask, function (c) {
            if (c.match(placeholderCharMatcher)) {
                placeholderMaskChars[c] = true;
            }
            else {
                staticMaskChars[c] = true;
            }
        });
        var cursorPos = el.selectionStart;
        var finalValueForElement = "";
        var iVal = 0;
        var iMask = 0;
        var maskChar;
        var valChar;
        var currentMaskCharIsStatic;
        var currentValueCharIsStatic;
        var currentValueCharIsPlaceholder;
        var currentValCharIsPlaceholderSpecialOrValid;
        var possiblyMoveCursor = function (i, amount) {
            if (cursorPos === i + 1 && userAddedACharacter) {
                runningCursorOffset += amount;
            }
        };
        var skipValueChar = function () {
            possiblyMoveCursor(iVal, -1);
            iVal++;
        };
        var advanceBothChars = function () {
            iVal++;
            iMask++;
        };
        var testDateValueCapping = function (valueIndexAtCursorPos) {
            if (!gwDateValue_1.gwDateValue.shouldCapDateTimeUserInput()) {
                return;
            }
            var nonLocalizedDateMask = el.getAttribute("data-gw-input-mask");
            if (!nonLocalizedDateMask) {
                return;
            }
            var dateMaskChar = nonLocalizedDateMask[valueIndexAtCursorPos];
            // If the character the user just typed replaces the second of matching 2 masks, then we'll try to run some date or month capping
            if (nonLocalizedDateMask[valueIndexAtCursorPos - 1] !== dateMaskChar) {
                return;
            }
            var capValue;
            if (dateMaskChar === "M") {
                capValue = 12;
            }
            else if (dateMaskChar === "d") {
                capValue = 31; //NOTE: to make this logic real, as in days in months, we'd have to always have the full date input by the user, which we don't, and run leap year logic
            }
            else if (dateMaskChar === "m" || dateMaskChar === "s") {
                capValue = 59;
            }
            else if (dateMaskChar === "h") {
                capValue = 23;
                if (gwUtil_1.gwUtil.hasClass(el, "gw-is12Hour")) {
                    capValue = 12;
                }
            }
            else {
                return;
            }
            var pairIntValue = parseInt(currentFullInputValue.substring(valueIndexAtCursorPos - 1, valueIndexAtCursorPos + 1));
            if (pairIntValue > capValue) {
                currentFullInputValue = currentFullInputValue.substring(0, valueIndexAtCursorPos - 1) + capValue + currentFullInputValue.substring(valueIndexAtCursorPos + 1);
            }
        };
        /**
         * Will check for various date time specific logic:
         * -Capping values
         * -Autocompleting single digit days and months
         * -Autocompleting 2 digit years based on server settings
         */
        var runDateTimeSpecificLogic = function () {
            if (!isDigitsOnlyMask || !userAddedACharacter) {
                return;
            }
            var valueIndexAtCursorPos = cursorPos - 1;
            var characterJustTyped = currentFullInputValue[valueIndexAtCursorPos];
            if (!gwUtil_1.gwUtil.hasValue(characterJustTyped)) {
                return;
            }
            // If the typed character isn't special, then we'll just check on day month capping
            if (!staticMaskChars[characterJustTyped]) {
                testDateValueCapping(valueIndexAtCursorPos);
                return;
            }
            var possiblyFillInSingleDigitDateTimeValues = function () {
                // Test if the next character in the value matches the mask, and the character after that is a special character
                if (!placeholderMaskChars[currentFullInputValue[valueIndexAtCursorPos + 1]] || !staticMaskChars[currentFullInputValue[valueIndexAtCursorPos + 2]]) {
                    return;
                }
                // At this point, the value looks something like 7/d/mm/yyyy with the user's cursor between the / and the d
                // So now we see if we should convert a single digit value into a zero leading value
                var intCharVal = parseInt(currentFullInputValue[valueIndexAtCursorPos - 1]);
                if (isNaN(intCharVal)) {
                    return;
                }
                currentFullInputValue = currentFullInputValue.substring(0, valueIndexAtCursorPos - 1) + "0" + intCharVal + currentFullInputValue.substring(valueIndexAtCursorPos + 2);
                // Now jump the cursor past the mask special character, and let the logic loop do the rest
                cursorPos++;
                return true;
            };
            var possiblyFillOut2DigitYear = function () {
                // Test if the next 2 characters in the value match the mask and are ph
                if (!placeholderMaskChars[currentFullInputValue[valueIndexAtCursorPos + 1]] || !placeholderMaskChars[currentFullInputValue[valueIndexAtCursorPos + 2]]) {
                    return;
                }
                //At this point the val looks like 7yyy or 77yy
                //if the 3rd one matches, then the user has only typed 1 of the 4 year characters, then we'll fill the 0
                if (placeholderMaskChars[currentFullInputValue[valueIndexAtCursorPos + 3]]) {
                    currentFullInputValue = currentFullInputValue.substring(0, valueIndexAtCursorPos - 1) + "0" + currentFullInputValue[valueIndexAtCursorPos - 1] + currentFullInputValue.substring(valueIndexAtCursorPos);
                    // Bump the index and the cursor, so the remaining logic can run as though the user had typed the 2nd year char
                    valueIndexAtCursorPos++;
                    cursorPos++;
                }
                var dateTwoString = currentFullInputValue.substring(valueIndexAtCursorPos - 2, valueIndexAtCursorPos);
                //At this point the val looks only like 07yy or 45yy, etc
                var dateTwoDigit = parseInt(dateTwoString);
                if (isNaN(dateTwoDigit)) {
                    return;
                }
                var yearLead = gwDateValue_1.gwDateValue.getTwoDigitYearEarly();
                // If two digit date is above a certain value, then assume one century, if it's below, assume another
                if (dateTwoDigit > gwDateValue_1.gwDateValue.getTwoDigitYearThreshold()) {
                    yearLead = gwDateValue_1.gwDateValue.getTwoDigitYearLate();
                }
                if (isNaN(yearLead)) {
                    return;
                }
                var finalYear = yearLead + dateTwoString;
                currentFullInputValue = currentFullInputValue.substring(0, valueIndexAtCursorPos - 2) + finalYear + currentFullInputValue.substring(valueIndexAtCursorPos + 3);
                cursorPos += 2;
            };
            // In order to account for situations where the mask character are at the end of string
            // Instead of special casing the logic to account for an undefined index,
            // we'll add a values separator to the end of the string, so the logic is the same no matter where its parsed,
            // And then remove the extra character from the end of the string when we're done.
            currentFullInputValue += characterJustTyped;
            // If the Fill in single digit datetime values returns false, then we'll check for logic we can run on the year
            if (!possiblyFillInSingleDigitDateTimeValues()) {
                possiblyFillOut2DigitYear();
            }
            // Remove the character we added before running the Fill methods
            currentFullInputValue = currentFullInputValue.slice(0, -1);
        };
        runDateTimeSpecificLogic();
        if (!mask) {
            return;
        }
        // NOTE: the logic in this while loop could be combined for less code, but I think the defined sections just read and debug more clearly
        while (iMask < mask.length) {
            maskChar = mask[iMask];
            valChar = currentFullInputValue[iVal];
            currentMaskCharIsStatic = staticMaskChars[maskChar];
            currentValueCharIsStatic = staticMaskChars[valChar];
            currentValueCharIsPlaceholder = placeholderMaskChars[valChar];
            if (valChar === undefined) {
                finalValueForElement += mask.substring(iMask);
                break;
            }
            currentValCharIsPlaceholderSpecialOrValid = currentValueCharIsPlaceholder || currentValueCharIsStatic || valChar.match(validInputCharRegex);
            if (!currentValCharIsPlaceholderSpecialOrValid || currentValueCharIsPlaceholder) {
                skipValueChar();
                continue;
            }
            if (currentValueCharIsStatic) {
                if (valChar === maskChar) {
                    finalValueForElement += maskChar;
                    advanceBothChars();
                    continue;
                }
                // valChar is special, but doesn't match the mask, so ignore it
                skipValueChar();
                continue;
            }
            if (currentMaskCharIsStatic) {
                possiblyMoveCursor(iMask, 1);
                finalValueForElement += maskChar;
                iMask++;
                if (currentValueCharIsPlaceholder) {
                    iVal++;
                }
                continue;
            }
            // valChar is a valid input, and the maskChar is a ph, so all is good
            finalValueForElement += valChar;
            advanceBothChars();
        }
        // If all that's left in the input is the mask, then blank it, and let the PH kick in.
        if (finalValueForElement === mask) {
            finalValueForElement = "";
        }
        this.setValueOnElementWithInputMask(el, finalValueForElement);
        // If this input element has focus, then we'll manipulate its selection range
        if (document.activeElement === el) {
            el.setSelectionRange(cursorPos + runningCursorOffset, cursorPos + runningCursorOffset);
        }
        // ****** ALL CODE FROM HERE TO END OF METHOD RELATES ONLY TO DATEVALUE WIDGETS *******
        // If this is a date input, and there is a matching time input, then we do extra logic to support pasting full date-times into the date input
        if (currentFullInputValue.length > mask.length + 1) {
            if (gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget--dateInput")) {
                var timeInput = this.getTimeSelectForInput(el);
                if (timeInput && timeInput.hasAttribute("data-gw-input-mask")) {
                    // Take the overflow, since it's more than a single character, and set it as the value in the timeInput
                    timeInput.value = currentFullInputValue.substring(mask.length).trim();
                    this.notifySystemsOfInputValueChange(timeInput);
                }
            }
            else if (gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget--timeInput")) {
                // If the originally input value contains one of the localized am/pm then the user could have pasted the value in, so set the select to it.
                var ampmInput = this.getAmPmInputForInput(el);
                if (ampmInput) {
                    var option1 = gwDateValue_1.gwDateValue.getAmString();
                    var option2 = gwDateValue_1.gwDateValue.getPmString();
                    if (option1 && option2) {
                        var option1Tester = new RegExp("((" + option1.toUpperCase() + ")|(" + option1.toLowerCase() + "))");
                        if (option1Tester.test(currentFullInputValue)) {
                            ampmInput.value = option1;
                        }
                        else {
                            var option2Tester = new RegExp("((" + option2.toUpperCase() + ")|(" + option2.toLowerCase() + "))");
                            if (option2Tester.test(currentFullInputValue)) {
                                ampmInput.value = option2;
                            }
                        }
                    }
                }
            }
        }
        else if (currentFullInputValue.length === mask.length + 1) {
            if (gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget--timeInput")) {
                var ampmInput = this.getAmPmInputForInput(el);
                if (ampmInput) {
                    // If the single overflow character equals the first letter of one of the meridian options, we'll select it
                    // basically allowing the user a shortcut way to toggle AMPM without having to tab out to it.
                    var option1 = gwDateValue_1.gwDateValue.getAmString();
                    var option2 = gwDateValue_1.gwDateValue.getPmString();
                    var option1FirstChar = option1[0].toLowerCase();
                    var option2FirstChar = option2[0].toLowerCase();
                    var overflowChar = currentFullInputValue[currentFullInputValue.length - 1].toLowerCase();
                    if (overflowChar === option1FirstChar) {
                        ampmInput.value = option1;
                    }
                    else if (overflowChar === option2FirstChar) {
                        ampmInput.value = option2;
                    }
                }
            }
        }
    };
    /**
     * @private
     * returns the select element that matches the pattern of el.name +_ampm
     * @param el
     * @returns {*}
     */
    GwInputs.prototype.getAmPmInputForInput = function (el) {
        return $("#" + el.name.replace("_time", "") + "_ampm")[0];
    };
    GwInputs.prototype.getTimeSelectForInput = function (el) {
        return $("#" + el.name + "_time")[0];
    };
    /**
     * Called by the copy/cut event on inputs with input masks.
     * If the element has a select for am/pm, then copy/cut appends the value of the select to the clipboardData
     * only if the right hand side of the input selection extends to the end of the input.
     *
     * @param el
     * @param args
     * @param e
     */
    GwInputs.prototype.copyOnInputMask = function (el, args, e) {
        var val = el.value;
        var selectionStart = el.selectionStart;
        var selectionEnd = el.selectionEnd;
        var timeEl;
        var appendTime = false;
        var eraJIC = null;
        if (gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget--dateInput")) {
            if (selectionEnd === selectionStart || (selectionStart <= 0 && selectionEnd >= val.length)) {
                appendTime = true;
                eraJIC = gwJicHelper_1.gwJicHelper.getEraInputValue(el); //TODO: move this onto JIC maybe
            }
            timeEl = this.getTimeSelectForInput(el);
        }
        else if (gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget--timeInput")) {
            timeEl = el;
        }
        var finalVal = val;
        // If they have nothing selected, give them the whole value
        // Otherwise, just get the selected data.
        if (selectionEnd !== selectionStart) {
            finalVal = finalVal.substring(selectionStart, selectionEnd);
        }
        if (timeEl) {
            if (appendTime) {
                finalVal = finalVal + " " + timeEl.value;
            }
            var sel = this.getAmPmInputForInput(el);
            if (sel) {
                // Test if we have selected to the end of the text in the time input, or if the date input has told us to appendTime
                // If we have, then add the select.value localized am/pm to it
                if (appendTime || selectionEnd === selectionStart || (selectionStart <= 0 && selectionEnd >= val.length)) {
                    finalVal = finalVal + " " + sel.value;
                }
            }
        }
        if (eraJIC) {
            finalVal = eraJIC + " " + finalVal;
        }
        var clipboardData = e.clipboardData || window.clipboardData;
        if (clipboardData !== undefined && clipboardData !== null) {
            clipboardData.setData("text", finalVal);
        }
        else {
            gwUtil_1.gwUtil.devlog("clipboardData object not present on event or window");
        }
        // If this is a cut, then we need to manually delete the selected area since we'll be preventingDefault
        if (e.type === "cut") {
            el.value = val.substring(0, selectionStart) + val.substring(selectionEnd, val.length);
            el.setSelectionRange(selectionStart, selectionStart);
            this.notifySystemsOfInputValueChange(el, "inputmask");
        }
    };
    /**
     * Runs before server event is fired.
     * if clearTrailingMaskCharacters is true then:
     * - Trim off any trailing characters in the input's value that match the input mask.
     */
    GwInputs.prototype.beforeFireEvent = function () {
        var _this = this;
        if (this.clearTrailingMaskCharacters) {
            gwUtil_1.gwUtil.forEach($("input[data-gw-input-mask]"), function (el) { return el.value = _this.getValueWithMaskTrimmed(el); });
        }
    };
    /**
     * Returns either the value of the element, or if it has an input mask, the value with any trailing input masks chars removed
     * @param el
     * @returns {*}
     */
    GwInputs.prototype.getValueWithMaskTrimmed = function (el) {
        var mask = el.getAttribute("data-gw-input-mask");
        if (!mask) {
            return el.value;
        }
        var val = el.value;
        if (!gwUtil_1.gwUtil.hasValue(val)) {
            return "";
        }
        if (this.hasDigitsOnlyMask(el)) {
            // Digits only masks with placeholders fill in the placeholder values, not the input mask
            // So we need to trim off the placeholder here instead of the input mask
            mask = this.getPlaceholderValueOrMaskIfPlaceholderIsIncorrectLength(el, mask);
        }
        if (!mask) {
            return "";
        }
        var lastIndexInValToInclude = val.length;
        gwUtil_1.gwUtil.forEachReverse(val, function (ch, key, coll, i) {
            if (ch !== mask[i]) {
                return gwTypes_1.GW_BREAKER;
            }
            lastIndexInValToInclude--;
            return;
        });
        return val.substring(0, lastIndexInValToInclude);
    };
    /**
     * Checks if the given input mask is "active" - that is will it actually guide user input? Some input masks
     * have no placeholder characters are just intended as a hint to the user.
     *
     * This function only works for explicitly specified PCF input masks, which always use the default input mask
     * placeholder character.
     * @param {string} inputMask the input mask
     * @returns {boolean} true if it is an active mask
     */
    GwInputs.prototype.isActiveInputMask = function (inputMask) {
        return gwUtil_1.gwUtil.hasValue(inputMask) && inputMask.indexOf(this.DEFAULT_INPUT_MASK_PLACEHOLDER_CHAR) >= 0;
    };
    /** Exposed as gw.api.Util.getValue, see gw.api */
    GwInputs.prototype.getValueById = function (id) {
        return $("[name='" + id + "']").val();
    };
    /** Exposed as gw.api.Util.getValues, see gw.api */
    GwInputs.prototype.getValuesByIds = function (ids) {
        var _this = this;
        return ids.map(function (id) { return _this.getValueById(id); });
    };
    /** Exposed as gw.api.Util.setValue, see gw.api */
    GwInputs.prototype.setValueById = function (id, value) {
        var currentValue = this.getValueById(id);
        if (currentValue !== value) {
            $("[name='" + id + "']").val(value);
            var node = gwUtil_1.gwUtil.getDomNodeByName(id);
            if (node) {
                // fire change event to trigger either postOnChange or Reflection if it is configured
                gwEvents_1.gwEvents.forceGlobalEvent(node, "change");
            }
        }
    };
    /** Exposed as gw.api.Util.setValues, see gw.api */
    GwInputs.prototype.setValuesByIds = function (valuesById) {
        var _this = this;
        this.validateSetValuesConfig(valuesById);
        gwUtil_1.gwUtil.forEach(valuesById, function (val, id) {
            _this.setValueById(id, val);
        });
    };
    GwInputs.prototype.validateSetValuesConfig = function (valuesById) {
        var _this = this;
        var previousPOCExist = false;
        gwUtil_1.gwUtil.forEach(valuesById, function (val, id) {
            var input = _this.getInputByName(id);
            if (!input) {
                return;
            }
            var widgetNode = gwEvents_1.gwEvents.findEnclosingWidget(input);
            if (!widgetNode) {
                return;
            }
            if (_this.hasPostOnChange(widgetNode)) {
                if (previousPOCExist) {
                    console.warn("calling setValues on more than one fields with postOnChange is not supported");
                }
                else {
                    previousPOCExist = true;
                }
            }
            // reflection will not work properly after postOnChange
            if (gwReflection_1.gwReflection.isReflectionTrigger(widgetNode) && previousPOCExist) {
                console.warn("calling setValues on more than one fields with postOnChange/reflection is not supported");
            }
        });
    };
    GwInputs.prototype.focusFirstInput = function (container) {
        gwFocus_1.gwFocus.forceFocus($(":input", container).first()[0], false);
    };
    GwInputs.prototype.closeOpenInputs = function (event) {
        gwDateValue_1.gwDateValue.hideDatePicker();
        gwTextValue_1.gwTextValue.closeAutocomplete(event);
        gwHelpText_1.gwHelpText.closeHelpText();
    };
    /**
     * Verify the inputValue is digit only. All non-digit characters will be stripped out.
     *
     * @param {HTMLInputElement} inputElement
     * @param {GwMap} args
     */
    GwInputs.prototype.verifyDigitOnly = function (inputElement, args) {
        if (inputElement.value) {
            inputElement.value = inputElement.value.replace(/\D/g, "");
        }
    };
    /**
     * return true if an input has postOnChange configured.
     * @param el
     */
    GwInputs.prototype.hasPostOnChange = function (el) {
        return (el && el.getAttribute("data-gw-change") === "refresh");
    };
    return GwInputs;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwInputs = GwInputs;
exports.gwInputs = new GwInputs();


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_create__ = __webpack_require__(263);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_create__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_creator__ = __webpack_require__(63);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_creator__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_local__ = __webpack_require__(292);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_2__src_local__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_matcher__ = __webpack_require__(149);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_3__src_matcher__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_mouse__ = __webpack_require__(293);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_4__src_mouse__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_namespace__ = __webpack_require__(89);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_5__src_namespace__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_namespaces__ = __webpack_require__(90);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_6__src_namespaces__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_point__ = __webpack_require__(64);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_7__src_point__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_select__ = __webpack_require__(147);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_8__src_select__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_selectAll__ = __webpack_require__(294);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_9__src_selectAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_selection_index__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_10__src_selection_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_selector__ = __webpack_require__(91);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_11__src_selector__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__ = __webpack_require__(148);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_selection_style__ = __webpack_require__(152);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_13__src_selection_style__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_touch__ = __webpack_require__(295);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_14__src_touch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_touches__ = __webpack_require__(296);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_15__src_touches__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_window__ = __webpack_require__(92);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_16__src_window__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_selection_on__ = __webpack_require__(93);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__["a"]; });




















/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = newInterval;
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwStorage_1 = __webpack_require__(24);
var gwAnimation_1 = __webpack_require__(57);
var GwFocus = /** @class */ (function () {
    function GwFocus() {
        /**
         * @private
         * Key for localStorage.
         * @type {string}
         */
        this.CURR_FOCUS_KEY = "currentFocusSelector";
        /**
         * @private
         * Key for localStorage.
         * @type {string}
         */
        this.LAST_FOCUS_KEY = "lastFocusSelector";
        /**
         * @private
         * The cache for the current focused node.
         * We cache it to prevent having to do an ID lookup from localStorage everytime.
         * But it means we need to clear the cache on full and partial page reloads.
         * Only accessed via gw.navigation.setCurrentFocus and getCurrentFocus
         */
        this.currentFocusNode = null;
        /**
         * ibid.
         */
        this.lastFocusNode = null;
        this.defaultFocusableMap = {
            a: true,
            button: true,
            img: true,
            input: true,
            select: true,
            textarea: true
        };
    }
    /**
     * @public
     * Returns either the cached node in currentFocusNode, or pulls the stored id from localStorage and does a DOM lookup.
     * @returns {*}
     */
    GwFocus.prototype.getCurrentFocus = function () {
        if (!this.currentFocusNode) {
            var selector = gwStorage_1.gwStorage.get(this.CURR_FOCUS_KEY);
            if (selector) {
                this.currentFocusNode = document.querySelector(selector);
            }
        }
        return this.currentFocusNode;
    };
    /**
     * @public
     * Sets the currentFocus node. And gets the id or name attribute from the node, storing it in local storage.
     * If the node has no id or name attribute, throws a warning, as this is likely an error state.
     * @param node
     */
    GwFocus.prototype.setCurrentFocus = function (node) {
        gwUtil_1.gwUtil.removeClass(".gw-focus", "gw-focus");
        if (!node) {
            this.clearFocus();
            return;
        }
        this.setLastFocus(this.currentFocusNode);
        this.currentFocusNode = node;
        var selector = gwUtil_1.gwUtil.getUniqueSelector(node);
        if (!selector) {
            //TODO: this is firing for even small elements, like in pickers, that we wouldn't restore focus to, so needs better thinking
            //gwUtil.devlog("cannot construct unique selector for focusable node. This will prevent the node from having focus restored to it.: ", node);
        }
        gwUtil_1.gwUtil.addClass(this.currentFocusNode, "gw-focus");
        gwStorage_1.gwStorage.set(this.CURR_FOCUS_KEY, selector);
    };
    /**
     * Removes focus and focus styling from all nodes
     */
    GwFocus.prototype.clearFocus = function () {
        if (document.activeElement.blur !== undefined) {
            document.activeElement.blur();
        }
        this.currentFocusNode = null;
        this.lastFocusNode = null;
        gwStorage_1.gwStorage.set(this.CURR_FOCUS_KEY, null);
        gwStorage_1.gwStorage.set(this.LAST_FOCUS_KEY, null);
        gwUtil_1.gwUtil.removeClass(".gw-focus", "gw-focus");
    };
    /**
     * @public
     * Holds a reference to the last focused node.
     * @returns {*}
     */
    GwFocus.prototype.getLastFocus = function () {
        if (!this.lastFocusNode) {
            var lastFocusSelector = gwStorage_1.gwStorage.get(this.LAST_FOCUS_KEY);
            if (lastFocusSelector) {
                this.lastFocusNode = document.querySelector(lastFocusSelector);
            }
        }
        return this.lastFocusNode;
    };
    /**
     * @public
     * Sets the last focused node.
     * @param node
     */
    GwFocus.prototype.setLastFocus = function (node) {
        if (!node || !this.focusableUsingTabIndex(node)) {
            return;
        }
        this.lastFocusNode = node;
        gwStorage_1.gwStorage.set(this.LAST_FOCUS_KEY, gwUtil_1.gwUtil.getUniqueSelector(node));
    };
    /**
     * @private
     * Given a node, returns an array of focusable children via querySelectorAll tabindex.
     * And filters the array for various properties and styles that would make it "invisible".
     * @param node
     * @returns {[DOMNodes]}
     */
    GwFocus.prototype.getFocusable = function (node) {
        var _this = this;
        if (node) {
            if (node.style.visibility === "hidden" || node.style.display === "none") {
                return [];
            }
            var candidates = node.querySelectorAll("input, textarea, select, [tabindex]");
            return Array.prototype.filter.call(candidates, function (el) {
                return _this.canSelfBeFocusedBasedOnHtmlState(el);
            });
        }
        return [];
    };
    /**
     * @private
     * used by getFocusable and isFocusable, to determine if an element meets the criteria of visibility and size to be focused.
     * @param el - an HTML DOM element.
     * @returns {boolean}
     */
    GwFocus.prototype.canSelfBeFocusedBasedOnHtmlState = function (el) {
        //TODO: cooper. I hate having to do all these checks, and getComputedStyle is slow
        // But the jquery one liners either do too much or not enough.
        if (!this.focusableUsingTabIndex(el)) {
            return false;
        }
        if (el.offsetWidth === 0) {
            return false;
        }
        if (el.offsetHeight === 0) {
            return false;
        }
        var style = window.getComputedStyle(el);
        if (style.visibility === "hidden") {
            return false;
        }
        if (style.display === "none") {
            return false;
        }
        if (style.width && style.width.indexOf("0") === 0) {
            return false;
        }
        if (style.height && style.height.indexOf("0") === 0) {
            return false;
        }
        return true;
    };
    GwFocus.prototype.allowsFocusBasedOnDisabledOrReadonly = function (el) {
        if (el.hasAttribute("disabled") || gwUtil_1.gwUtil.hasClass(el, "gw-disabled")) {
            return false;
        }
        if (el.hasAttribute("readonly") && !el.hasAttribute("data-gw-readonly-focusable")) {
            return false;
        }
        return true;
    };
    /**
     * @private
     * Check if element is focusable based on tabIndex.  If the tabIndex is not explicitly specified
     * on the element, check a default focusable map to determine if the element should be focusable.
     */
    GwFocus.prototype.focusableUsingTabIndex = function (el) {
        if (!el) {
            return false;
        }
        if (!this.allowsFocusBasedOnDisabledOrReadonly(el)) {
            return false;
        }
        if (el.hasAttribute("tabIndex")) {
            return el.tabIndex >= 0;
        }
        return this.defaultFocusableMap[el.nodeName.toLowerCase()] || false;
    };
    GwFocus.prototype.focusableOnClick = function (el) {
        if (this.defaultFocusableMap[el.nodeName.toLowerCase()]) {
            return true;
        }
        return !!this.findFocusableNodeForClick(el);
    };
    /**
     * @public
     * Returns true if the node, or anyone of it's children is focusable.
     * @param node
     * @param allowChildren whether to search down for a focusable element to consider the node focusable
     * @returns {boolean}
     */
    GwFocus.prototype.isFocusable = function (node, allowChildren) {
        if (allowChildren === void 0) { allowChildren = true; }
        if (node === null) {
            return false;
        }
        return this.canSelfBeFocusedBasedOnHtmlState(node) || (allowChildren && this.getFocusable(node).length > 0);
    };
    /**
     * When an element is clicked, we search up the DOM for something with a tabIndex
     * to focus. In IE, everything receives a focusIn event, so we need to search
     * for what elements we support focus on.
     * @param targetNode
     * @returns {*}
     */
    GwFocus.prototype.findFocusableNodeForClick = function (targetNode) {
        var parent = targetNode;
        while (parent) {
            if (!this.allowsFocusBasedOnDisabledOrReadonly(parent)) {
                return null;
            }
            //In IE we get to the Document itself, which does not support hasAttribute
            if ((this.defaultFocusableMap[parent.nodeName.toLowerCase()]) ||
                (parent.hasAttribute
                    && parent.hasAttribute("tabIndex")
                    && +parent.getAttribute("tabIndex") >= 0)) {
                return parent;
            }
            parent = parent.parentElement;
        }
        return null;
    };
    GwFocus.prototype.processNewFocus = function (el, animateOnFocus) {
        if (animateOnFocus === void 0) { animateOnFocus = false; }
        gwAnimation_1.gwAnimation.killAnimation("focus", this.getCurrentFocus());
        if (animateOnFocus) {
            gwAnimation_1.gwAnimation.addAnimation(el, "focus");
        }
        this.setCurrentFocus(el);
        el.focus();
    };
    /**
     * @public
     * This call takes a class or Id string, or a node, and sets focus to it if it has a tab index.
     * If it does not have a tabindex it begins recursively drilling down to find the first child of child with a tabindex
     * @param classIdOrNode: argument passed to getDomNode
     * @param animateOnFocus: Whether the DOM element should "bounce" to show it has been focused
     * @returns {boolean} returns true to stop the recursive calls.
     */
    GwFocus.prototype.forceFocus = function (classIdOrNode, animateOnFocus) {
        if (animateOnFocus === void 0) { animateOnFocus = false; }
        var el = gwUtil_1.gwUtil.getDomNode(classIdOrNode);
        if (!el || el === document.documentElement) {
            return false;
        }
        if (this.focusableUsingTabIndex(el)) {
            this.processNewFocus(el, animateOnFocus);
            return true;
        }
        var child = this.getFocusable(el)[0];
        if (child) {
            this.processNewFocus(child, animateOnFocus);
            return true;
        }
        var children = el.children;
        for (var i = 0; i < children.length; i++) {
            if (this.forceFocus(children[i], animateOnFocus)) {
                return true;
            }
        }
        return false;
    };
    /**
     * @public
     * Needs to be called after full and partial page reload to restore the focus correctly.
     * Clears current node caches then forces focus onto the the currentFocus
     * @param asyncTimer: if present, and a number, then will delay calling restore focus for n milleseconds.
     * This is mainly for debugging, but it's likely there will come a time where we have async logic running
     * after page reload, and restore focus will need to wait until it's done. Though when that happens,
     * this should probably become a callback to the given async method.
     */
    GwFocus.prototype.restoreFocus = function (isFullPageReload, asyncTimer) {
        if (asyncTimer === void 0) { asyncTimer = -1; }
        this.currentFocusNode = null;
        this.lastFocusNode = null;
        if (asyncTimer >= 0) {
            setTimeout(this.restoreFocus.bind(this, isFullPageReload), asyncTimer);
            return;
        }
        var focusNode = this.getCurrentFocus() || this.getLastFocus();
        if (focusNode) {
            this.forceFocus(focusNode, isFullPageReload);
        }
    };
    return GwFocus;
}());
exports.GwFocus = GwFocus;
exports.gwFocus = new GwFocus();


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_bisect__ = __webpack_require__(135);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bisect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_ascending__ = __webpack_require__(36);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__src_ascending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_bisector__ = __webpack_require__(136);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_2__src_bisector__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_cross__ = __webpack_require__(239);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__src_cross__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_descending__ = __webpack_require__(240);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_4__src_descending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_deviation__ = __webpack_require__(138);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_5__src_deviation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_extent__ = __webpack_require__(140);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_6__src_extent__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_histogram__ = __webpack_require__(241);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_7__src_histogram__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_threshold_freedmanDiaconis__ = __webpack_require__(244);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_8__src_threshold_freedmanDiaconis__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_threshold_scott__ = __webpack_require__(245);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_9__src_threshold_scott__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_threshold_sturges__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_10__src_threshold_sturges__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_max__ = __webpack_require__(246);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_11__src_max__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_mean__ = __webpack_require__(247);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_12__src_mean__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_median__ = __webpack_require__(248);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_13__src_median__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_merge__ = __webpack_require__(249);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_14__src_merge__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_min__ = __webpack_require__(145);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_15__src_min__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_pairs__ = __webpack_require__(137);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_16__src_pairs__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_permute__ = __webpack_require__(250);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_17__src_permute__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_quantile__ = __webpack_require__(87);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_18__src_quantile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__src_range__ = __webpack_require__(142);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_19__src_range__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__src_scan__ = __webpack_require__(251);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_20__src_scan__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__src_shuffle__ = __webpack_require__(252);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_21__src_shuffle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__src_sum__ = __webpack_require__(253);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_22__src_sum__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__src_ticks__ = __webpack_require__(143);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_23__src_ticks__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__src_transpose__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_24__src_transpose__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__src_variance__ = __webpack_require__(139);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_25__src_variance__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__src_zip__ = __webpack_require__(254);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_26__src_zip__["a"]; });





























/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var Gw = /** @class */ (function () {
    function Gw() {
        this.globals = {};
        this.inits = {};
        this.draggable = {};
        this.sockets = {};
        this.browserActions = {}; // This is set in UtilityBrowserActions.ht
        this.displaykeyvalues = null;
        this.api = null;
    }
    /**
     * objects passed to this method will appear on the gw.globals object,
     * but more importantly, will be available to inline methods such as data-gw-click="gwMouse.enter".
     * The class GwMouse builds a singleton, registers its system name as gwMouse, and then calls this
     * method passing the singleton as the argument
     *
     * This process is automatically handled by using a typescript class and having it extend GwRegisteredSystem.
     * GwRegisteredSystem constructor will call this method.
     *
     * @param {GwRegisteredSystem} global
     */
    Gw.prototype.registerGlobalSystem = function (global) {
        if (this.globals.hasOwnProperty(global.getSystemName())) {
            throw new Error("Attempting to register an global system object with a system name that's already been registered: " + global.getSystemName());
        }
        this.globals[global.getSystemName()] = global;
    };
    /**
     * This method registers an object to be notified on every page reload, partial or full.
     * It calls "init" on object passed as an argument.
     *
     * This process is automatically handled by the constructor method in GwInitializableSystem
     *
     * This method should NOT be used for the global systems that are ORDER DEPENDANT. These systems should extend
     * GwOrderDependantInitializableSystem, and be manually placed in order in gwApp.getInitializationOrderSpecificSystems
     * @param {GwInitializableSystem} system
     */
    Gw.prototype.registerInitializableSystem = function (system) {
        if (this.inits.hasOwnProperty(system.getSystemName())) {
            throw new Error("Attempting to register an initialization system object with a system name that's already been registered: " + system.getSystemName());
        }
        this.inits[system.getSystemName()] = system;
    };
    Gw.prototype.registerDraggableSystem = function (draggable) {
        if (this.draggable.hasOwnProperty(draggable.getSystemName())) {
            throw new Error("Attempting to register a draggable system object with a system name that's already been registered: " + draggable.getSystemName());
        }
        this.draggable[draggable.getSystemName()] = draggable;
    };
    Gw.prototype.registerWebsocketSystem = function (socketSystem) {
        if (this.sockets.hasOwnProperty(socketSystem.getSystemName())) {
            throw new Error("Attempting to register a socket system object with a system name that's already been registered: " + socketSystem.getSystemName());
        }
        this.sockets[socketSystem.getSystemName()] = socketSystem;
    };
    Gw.prototype.initializeNonOrderSpecificSystems = function (isFullPageReload, partialReloadReasons) {
        gwUtil_1.gwUtil.forEach(this.inits, function (systemObj) { return systemObj.init(isFullPageReload, partialReloadReasons); });
    };
    return Gw;
}());
exports.Gw = Gw;
exports.gw = new Gw();
window.gw = exports.gw;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwOrderDependantInitializableSystem = /** @class */ (function (_super) {
    __extends(GwOrderDependantInitializableSystem, _super);
    function GwOrderDependantInitializableSystem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GwOrderDependantInitializableSystem;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwOrderDependantInitializableSystem = GwOrderDependantInitializableSystem;


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return root; });
/* harmony export (immutable) */ __webpack_exports__["a"] = Selection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__select__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectAll__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__data__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enter__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__exit__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__merge__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__order__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sort__ = __webpack_require__(272);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__call__ = __webpack_require__(273);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__nodes__ = __webpack_require__(274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__node__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__size__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__empty__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__each__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__attr__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__style__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__property__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__classed__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__text__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__html__ = __webpack_require__(283);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__raise__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__lower__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__append__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__insert__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__remove__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__clone__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__datum__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__on__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__dispatch__ = __webpack_require__(291);































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: __WEBPACK_IMPORTED_MODULE_0__select__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_1__selectAll__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_2__filter__["a" /* default */],
  data: __WEBPACK_IMPORTED_MODULE_3__data__["a" /* default */],
  enter: __WEBPACK_IMPORTED_MODULE_4__enter__["b" /* default */],
  exit: __WEBPACK_IMPORTED_MODULE_5__exit__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_6__merge__["a" /* default */],
  order: __WEBPACK_IMPORTED_MODULE_7__order__["a" /* default */],
  sort: __WEBPACK_IMPORTED_MODULE_8__sort__["a" /* default */],
  call: __WEBPACK_IMPORTED_MODULE_9__call__["a" /* default */],
  nodes: __WEBPACK_IMPORTED_MODULE_10__nodes__["a" /* default */],
  node: __WEBPACK_IMPORTED_MODULE_11__node__["a" /* default */],
  size: __WEBPACK_IMPORTED_MODULE_12__size__["a" /* default */],
  empty: __WEBPACK_IMPORTED_MODULE_13__empty__["a" /* default */],
  each: __WEBPACK_IMPORTED_MODULE_14__each__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_15__attr__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_16__style__["a" /* default */],
  property: __WEBPACK_IMPORTED_MODULE_17__property__["a" /* default */],
  classed: __WEBPACK_IMPORTED_MODULE_18__classed__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_19__text__["a" /* default */],
  html: __WEBPACK_IMPORTED_MODULE_20__html__["a" /* default */],
  raise: __WEBPACK_IMPORTED_MODULE_21__raise__["a" /* default */],
  lower: __WEBPACK_IMPORTED_MODULE_22__lower__["a" /* default */],
  append: __WEBPACK_IMPORTED_MODULE_23__append__["a" /* default */],
  insert: __WEBPACK_IMPORTED_MODULE_24__insert__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_25__remove__["a" /* default */],
  clone: __WEBPACK_IMPORTED_MODULE_26__clone__["a" /* default */],
  datum: __WEBPACK_IMPORTED_MODULE_27__datum__["a" /* default */],
  on: __WEBPACK_IMPORTED_MODULE_28__on__["b" /* default */],
  dispatch: __WEBPACK_IMPORTED_MODULE_29__dispatch__["a" /* default */]
};

/* harmony default export */ __webpack_exports__["b"] = (selection);


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_value__ = __webpack_require__(95);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_value__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_array__ = __webpack_require__(159);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_array__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_basis__ = __webpack_require__(98);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__src_basis__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__ = __webpack_require__(157);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_date__ = __webpack_require__(160);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_4__src_date__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_number__ = __webpack_require__(65);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_5__src_number__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_object__ = __webpack_require__(161);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_6__src_object__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_round__ = __webpack_require__(301);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_7__src_round__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_string__ = __webpack_require__(162);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_8__src_string__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_transform_index__ = __webpack_require__(302);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_zoom__ = __webpack_require__(305);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_10__src_zoom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_rgb__ = __webpack_require__(156);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_hsl__ = __webpack_require__(306);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_lab__ = __webpack_require__(307);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_13__src_lab__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_hcl__ = __webpack_require__(308);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(309);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_quantize__ = __webpack_require__(310);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_16__src_quantize__["a"]; });



















/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CREATED */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return STARTING; });
/* unused harmony export STARTED */
/* unused harmony export RUNNING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENDED; });
/* harmony export (immutable) */ __webpack_exports__["g"] = init;
/* harmony export (immutable) */ __webpack_exports__["h"] = set;
/* harmony export (immutable) */ __webpack_exports__["f"] = get;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_timer__ = __webpack_require__(66);



var emptyOn = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["e"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["d" /* timer */])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["c" /* timeout */])(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__["c" /* timeout */])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwEvents_1 = __webpack_require__(3);
var gwDisplayKey_1 = __webpack_require__(16);
var gwUtil_1 = __webpack_require__(0);
var gwConfig_1 = __webpack_require__(80);
var GwAjax = /** @class */ (function (_super) {
    __extends(GwAjax, _super);
    function GwAjax() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ajaxRequestCount = 0;
        //Reverse order for handling, with custom handlers pushed on top.
        _this.serverErrorHandlers = [
            _this.badResponse.bind(_this),
            _this.httpError.bind(_this),
            _this.timedOut.bind(_this),
            _this.loggedOut.bind(_this),
            _this.alertDisplayable.bind(_this)
        ];
        return _this;
    }
    GwAjax.prototype.getSystemName = function () {
        return "gwAjax";
    };
    /**
     * Returns true if there any requests pending
     */
    GwAjax.prototype.hasPendingAjaxRequests = function () {
        return this.ajaxRequestCount !== 0;
    };
    /**
     * Gets the current CSRF token for a new request to the server.
     */
    GwAjax.prototype.getCsrfToken = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("csrfToken");
    };
    /**
     * @public
     * utility method for making a custom Ajax request to the server. If the call succeeds the given callback
     * is called, with the response, status text and Ajax request object as arguments. If the call fails the
     * optional error callback is called with optional GwAjaxResponseStatus and optional response as arguments; it should just be used
     * to clean up but if certain errorCallback wants to take over displaying the message it can return GwResponseErrorHandleResult.DONE
     * to indicate no standard error display is needed after the errorCallback. Any actual error handling will be dealt with
     * by the standard "handleFailedRequest" routine.
     */
    GwAjax.prototype.ajaxRequest = function (parameters, successCallback, errorCallback) {
        var _this = this;
        parameters[gwUtil_1.gwUtil.CSRF_PARAM_NAME] = this.getCsrfToken();
        var props = {
            url: window.location.href,
            data: parameters,
            dataType: "json",
            type: "POST",
            beforeSend: function () {
                _this.ajaxRequestCount++;
            },
            success: function (response, status, request) {
                _this.ajaxRequestCount--;
                _this.onRequestSuccess(request, response, successCallback, errorCallback);
            },
            error: function (request, errorType, httpErrorString) {
                _this.ajaxRequestCount--;
                _this.onRequestError(request, errorType, httpErrorString, errorCallback);
            },
            timeout: gwConfig_1.gwConfig.serverTimeoutMillis()
        };
        $.ajax(props);
    };
    /**
     * Called on a successful response from the server. Inspects the response for errors, if none are present hands
     * the response off to the registered callback.
     */
    GwAjax.prototype.onRequestSuccess = function (request, response, successCallback, errorCallback) {
        var errorType = this.determineErrorType(response, null);
        if (errorType === 0 /* OK */) {
            successCallback(response);
        }
        else {
            this.onRequestError(request, null, response.exceptionText, errorCallback, response);
        }
    };
    /**
     * Called on a failed request to the server, either because the request itself failed or because
     * the server responded that an error occurred during processing.
     *
     * Gives the caller's ErrorCallback a chance to handle the issue. If it isn't handled,
     * the general error handling takes over.
     */
    GwAjax.prototype.onRequestError = function (request, errorStatus, httpErrorString, errorCallback, response) {
        var errorType = this.determineErrorType(response, errorStatus);
        var handled;
        if (errorCallback) {
            handled = errorCallback(request, response, errorType, httpErrorString);
        }
        if (handled !== 0 /* DONE */) {
            this.handleFailedRequest(request, response, errorType, httpErrorString);
        }
    };
    GwAjax.prototype.determineErrorType = function (response, status) {
        if (status) {
            switch (status) {
                case "timeout":
                    return 5 /* TIMEOUT */;
                default:
                    return 4 /* FATAL_ERROR */;
            }
        }
        if (response) {
            if (response.loggedOut) {
                return 2 /* LOGOUT */;
            }
            if (response.displayableError) {
                return 3 /* DISPLAYABLE_ERROR */;
            }
            return 0 /* OK */;
        }
        return 4 /* FATAL_ERROR */;
    };
    /**
     * Adds a custom error handler that will be called when an ajax request fails.
     */
    GwAjax.prototype.addServerErrorHandler = function (errorHandler) {
        if (this.serverErrorHandlers.indexOf(errorHandler) >= 0) {
            return errorHandler;
        }
        this.serverErrorHandlers.push(errorHandler);
        return errorHandler;
    };
    /**
     * Removes the given error handler from the current set of handlers.
     */
    GwAjax.prototype.removeServerErrorHandler = function (errorHandler) {
        if (!errorHandler) {
            return;
        }
        var index = this.serverErrorHandlers.indexOf(errorHandler);
        if (index >= 0) {
            this.serverErrorHandlers.splice(index, 1);
        }
    };
    /**
     * Handles a failed Ajax request, calling any registered error handlers. An Ajax request is considered
     * "failed" if the server did not respond at all, either a timeout occurs, or some other 500 is returned
     * by the server.
     */
    GwAjax.prototype.handleFailedRequest = function (request, response, errorType, httpErrorString) {
        if (this.callServerErrorHandlers(request, response, errorType, httpErrorString)) {
            return;
        }
        gwUtil_1.gwUtil.devlog("Unable to handle server error, ", [request, response, errorType, httpErrorString]);
    };
    GwAjax.prototype.callServerErrorHandlers = function (request, response, errorType, httpErrorString) {
        for (var i = this.serverErrorHandlers.length - 1; i > 0; i--) {
            try {
                var errorHandler = this.serverErrorHandlers[i];
                var result = errorHandler(request, response, errorType, httpErrorString);
                if (result === 0 /* DONE */) {
                    return true;
                }
            }
            catch (e) {
                // Continue
            }
        }
        return false;
    };
    GwAjax.prototype.timedOut = function (request, response, errorType) {
        if (errorType === 5 /* TIMEOUT */) {
            alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.HTTPRequestTimedOut"));
            return 0 /* DONE */;
        }
        return 1 /* UNABLE_TO_PROCESS */;
    };
    GwAjax.prototype.loggedOut = function (request, response) {
        if (response && response.loggedOut) {
            gwEvents_1.gwEvents.disableNavigationConfirmationUntilUserCancelsConfirm();
            alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.AjaxRequestSessionExpired"));
            window.location.href = response.entryPoint;
            return 0 /* DONE */;
        }
        return 1 /* UNABLE_TO_PROCESS */;
    };
    GwAjax.prototype.httpError = function (request, response, errorType, httpErrorString) {
        if (errorType === 4 /* FATAL_ERROR */) {
            alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.HTTPRequestFailed", request.status, httpErrorString || ""));
            return 0 /* DONE */;
        }
        return 1 /* UNABLE_TO_PROCESS */;
    };
    GwAjax.prototype.alertDisplayable = function (request, response) {
        if (response && response.exceptionText) {
            alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.AjaxRequestServerError", response.exceptionText));
            return 0 /* DONE */;
        }
        return 1 /* UNABLE_TO_PROCESS */;
    };
    GwAjax.prototype.badResponse = function (request, response, errorType) {
        alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.HTTPRequestBadResponse", request.status, errorType));
        return 0 /* DONE */;
    };
    return GwAjax;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwAjax = GwAjax;
exports.gwAjax = new GwAjax();


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Handles the localization of strings via "display keys" - string identifiers that map to localized string
 * values sent from the server. The display key values are loaded via a separate request to a special request
 * handler, which will create a gw.displaykeyvalues object which has a key for each available language code.
 * The values are objects whose keys are display key strings (for example Web.Client.XXX) and whose values are
 * the localized strings. A localized string may contain argument substitutions of the form {0}, {1} etc. These
 * are replaced by the extra arguments to the "get" function e.g. calling get("Web.Client.XXX", "Y"), where
 * Web.Client.XXX maps to "Problem with {0}" would return "Problem with Y".
 */
var gwUtil_1 = __webpack_require__(0);
var gw_1 = __webpack_require__(10);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwDisplayKey = /** @class */ (function (_super) {
    __extends(GwDisplayKey, _super);
    function GwDisplayKey() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.languageCode = null;
        return _this;
    }
    GwDisplayKey.prototype.getSystemName = function () {
        return "gwDisplayKey";
    };
    GwDisplayKey.prototype.orderSpecificInit = function () {
        var previous = this.languageCode;
        var languageCode = gwUtil_1.gwUtil.getUtilityInfo("gw-language");
        if (!languageCode) {
            throw new Error("Missing language configuration element");
        }
        this.languageCode = languageCode;
        if (previous && previous !== this.languageCode) {
            gwUtil_1.gwUtil.fireCustomEvent("languageChange", { language: this.languageCode });
        }
    };
    GwDisplayKey.prototype.get = function (key) {
        var varArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            varArgs[_i - 1] = arguments[_i];
        }
        // If this is empty, then it hasn't loaded yet.
        if (!gw_1.gw.displaykeyvalues) {
            gwUtil_1.gwUtil.devlog("No displaykeyvalues loaded. This is due to a missing displaykeyvalues file. Possibly due to server error, or checksum failure.");
            return "[Missing]";
        }
        var defaultLanguageCode = gw_1.gw.displaykeyvalues.defaultLanguageCode;
        var code = this.languageCode || defaultLanguageCode;
        var formatString = gw_1.gw.displaykeyvalues[code][key];
        var formatStringArguments = Array.prototype.slice.call(arguments, 1);
        var substitutionRegex = /\{(\d+)\}/g;
        if (formatString === undefined && code !== defaultLanguageCode) {
            formatString = gw_1.gw.displaykeyvalues[defaultLanguageCode][key];
        }
        if (formatString === undefined) {
            return "Missing translation for " + key;
        }
        return formatString.replace(substitutionRegex, function (match, p1) { return formatStringArguments[parseInt(p1)]; });
    };
    return GwDisplayKey;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwDisplayKey = GwDisplayKey;
exports.gwDisplayKey = new GwDisplayKey();


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_color__ = __webpack_require__(96);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_lab__ = __webpack_require__(299);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__ = __webpack_require__(300);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__["a"]; });





/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = projection;
/* harmony export (immutable) */ __webpack_exports__["b"] = projectionMutator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__clip_antimeridian__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__clip_circle__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__clip_rectangle__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compose__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__identity__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__rotation__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__transform__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__fit__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__resample__ = __webpack_require__(404);











var transformRadians = Object(__WEBPACK_IMPORTED_MODULE_7__transform__["b" /* transformer */])({
  point: function(x, y) {
    this.stream.point(x * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], y * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
  }
});

function transformRotate(rotate) {
  return Object(__WEBPACK_IMPORTED_MODULE_7__transform__["b" /* transformer */])({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = __WEBPACK_IMPORTED_MODULE_0__clip_antimeridian__["a" /* default */], // clip angle
      x0 = null, y0, x1, y1, postclip = __WEBPACK_IMPORTED_MODULE_4__identity__["a" /* default */], // clip extent
      delta2 = 0.5, projectResample = Object(__WEBPACK_IMPORTED_MODULE_9__resample__["a" /* default */])(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */], point[1] * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */]];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? Object(__WEBPACK_IMPORTED_MODULE_1__clip_circle__["a" /* default */])(theta = _ * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */]) : (theta = null, __WEBPACK_IMPORTED_MODULE_0__clip_antimeridian__["a" /* default */]), reset()) : theta * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */];
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, __WEBPACK_IMPORTED_MODULE_4__identity__["a" /* default */]) : Object(__WEBPACK_IMPORTED_MODULE_2__clip_rectangle__["a" /* default */])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], phi = _[1] % 360 * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], recenter()) : [lambda * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */], phi * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */]];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], deltaPhi = _[1] % 360 * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */], deltaGamma = _.length > 2 ? _[2] % 360 * __WEBPACK_IMPORTED_MODULE_5__math__["r" /* radians */] : 0, recenter()) : [deltaLambda * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */], deltaPhi * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */], deltaGamma * __WEBPACK_IMPORTED_MODULE_5__math__["h" /* degrees */]];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = Object(__WEBPACK_IMPORTED_MODULE_9__resample__["a" /* default */])(projectTransform, delta2 = _ * _), reset()) : Object(__WEBPACK_IMPORTED_MODULE_5__math__["u" /* sqrt */])(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_8__fit__["a" /* fitExtent */])(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_8__fit__["c" /* fitSize */])(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_8__fit__["d" /* fitWidth */])(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_8__fit__["b" /* fitHeight */])(projection, height, object);
  };

  function recenter() {
    projectRotate = Object(__WEBPACK_IMPORTED_MODULE_3__compose__["a" /* default */])(rotate = Object(__WEBPACK_IMPORTED_MODULE_6__rotation__["b" /* rotateRadians */])(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwBreaker = /** @class */ (function () {
    function GwBreaker() {
    }
    return GwBreaker;
}());
exports.GwBreaker = GwBreaker;
exports.GW_BREAKER = new GwBreaker();


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Transition;
/* harmony export (immutable) */ __webpack_exports__["b"] = transition;
/* harmony export (immutable) */ __webpack_exports__["c"] = newId;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attr__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attrTween__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__delay__ = __webpack_require__(318);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration__ = __webpack_require__(319);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ease__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__merge__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__on__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__remove__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__select__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__selectAll__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__selection__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__style__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__styleTween__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__text__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__transition__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__tween__ = __webpack_require__(67);



















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["m" /* selection */])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["m" /* selection */].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: __WEBPACK_IMPORTED_MODULE_10__select__["a" /* default */],
  selectAll: __WEBPACK_IMPORTED_MODULE_11__selectAll__["a" /* default */],
  filter: __WEBPACK_IMPORTED_MODULE_6__filter__["a" /* default */],
  merge: __WEBPACK_IMPORTED_MODULE_7__merge__["a" /* default */],
  selection: __WEBPACK_IMPORTED_MODULE_12__selection__["a" /* default */],
  transition: __WEBPACK_IMPORTED_MODULE_16__transition__["a" /* default */],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: __WEBPACK_IMPORTED_MODULE_8__on__["a" /* default */],
  attr: __WEBPACK_IMPORTED_MODULE_1__attr__["a" /* default */],
  attrTween: __WEBPACK_IMPORTED_MODULE_2__attrTween__["a" /* default */],
  style: __WEBPACK_IMPORTED_MODULE_13__style__["a" /* default */],
  styleTween: __WEBPACK_IMPORTED_MODULE_14__styleTween__["a" /* default */],
  text: __WEBPACK_IMPORTED_MODULE_15__text__["a" /* default */],
  remove: __WEBPACK_IMPORTED_MODULE_9__remove__["a" /* default */],
  tween: __WEBPACK_IMPORTED_MODULE_17__tween__["a" /* default */],
  delay: __WEBPACK_IMPORTED_MODULE_3__delay__["a" /* default */],
  duration: __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* default */],
  ease: __WEBPACK_IMPORTED_MODULE_5__ease__["a" /* default */]
};


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = noop;
function noop() {}


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwTypes_1 = __webpack_require__(20);
var gwEvents_1 = __webpack_require__(3);
var gwUtil_1 = __webpack_require__(0);
var GwKeyListener_1 = __webpack_require__(85);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwEventDescription_1 = __webpack_require__(61);
var GwKeys = /** @class */ (function (_super) {
    __extends(GwKeys, _super);
    function GwKeys() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @private
         * Used to translate special characters to the equivalent keyCode
         */
        _this.keyCodeMap = {
            ";": 186,
            "=": 187,
            ",": 188,
            "-": 189,
            ".": 190,
            "/": 191,
            "`": 192,
            "[": 219,
            "\\": 220,
            "]": 221,
            "'": 222
        };
        /**
         * @private
         * Used to map shortcut key words to keyCode for use with shortcuts
         */
        _this.shortcutKeyWordToKeyCodeMap = {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        };
        /**
         * @private
         * Stores keyboard shortcuts sent down from the server via a client command. The shortcuts are stored
         * as a map of arrays where the keys to the map are scopes (MAIN/WORKSHEET) and the arrays contain the
         * actual listeners. The listeners have a createEventDescription function, which is called if a matching
         * key event is detected. This function searches for the widget with the id specified by the server and
         * finds its data-gw-click attribute (which may be directly on the element, or hidden in a sub element)
         * to determine the full event description
         * @type {Object}
         */
        _this.serverShortcutKeyListeners = {};
        /**
         * @private
         * We ignore any of these keycodes if they appear inside of the keyup event
         * @type {{16: boolean, 17: boolean, 18: boolean, 91: boolean, 93: boolean}}
         */
        _this.ignoredKeyCodes = {
            16: true,
            17: true,
            18: true,
            91: true,
            93: true // right meta
        };
        /**
         * @private
         * If an element has focus and triggers a keyup event, this map will be used if the element doesn't explicitly
         * define a data-gw-keyup method So if an element has a data-gw-click method, then when keycode 13 fires (the
         * enter key) the on click method will fire. This is so we can implement things like space bar toggling radio
         * buttons, etc. These can also take shift, alt, ctrl, and meta key modifiers by setting shift: true,
         * alt: true, etc.
         */
        //TODO, cooper, the reactors can probably just become a single method. I just wasn't sure of the design if we might need to check more than 1.
        _this.genericKeyReactors = [];
        /**
         * Contextual key listeners, who only fire if they key combination was fired within an element of the given contextClass
         */
        _this.contextualKeyListeners = [];
        /**
         * @private
         * These global shortcuts are only evaluated if the the focused element does not listen to the given keycode.
         * These are processed for shift, alt, ctrl, and meta key modifiers, but historically the gw shortcuts only used
         * alt and shift
         */
        //TODO: cooper, all keyboard shortcuts need to either get broken out, or be overrideable by customers
        _this.globalShortcutKeyListeners = [];
        return _this;
    }
    GwKeys.prototype.getSystemName = function () {
        return "gwKeys";
    };
    GwKeys.prototype.init = function (isFullReload) {
        if (isFullReload) {
            this.genericKeyReactors = [
                new GwKeyListener_1.GwKeyListener("13").withReactors("click").useCreateEventDescription("reactors"),
                new GwKeyListener_1.GwKeyListener("32").withReactors("click").useCreateEventDescription("reactors") // space bar
            ];
            this.contextualKeyListeners = [
                new GwKeyListener_1.GwKeyListener("37").withAlt().withShift().withMethodName("gwListView.left").withEnableDefault().withContextClass("gw-ListViewWidget"),
                new GwKeyListener_1.GwKeyListener("38").withAlt().withShift().withMethodName("gwListView.up").withEnableDefault().withContextClass("gw-ListViewWidget"),
                new GwKeyListener_1.GwKeyListener("39").withAlt().withShift().withMethodName("gwListView.right").withEnableDefault().withContextClass("gw-ListViewWidget"),
                new GwKeyListener_1.GwKeyListener("40").withAlt().withShift().withMethodName("gwListView.down").withEnableDefault().withContextClass("gw-ListViewWidget")
            ];
            this.globalShortcutKeyListeners = [
                new GwKeyListener_1.GwKeyListener("37").withMethodName("gwNavigation.left").withEnableDefault(),
                new GwKeyListener_1.GwKeyListener("38").withMethodName("gwNavigation.up").withEnableDefault(),
                new GwKeyListener_1.GwKeyListener("39").withMethodName("gwNavigation.right").withEnableDefault(),
                new GwKeyListener_1.GwKeyListener("40").withMethodName("gwNavigation.down").withEnableDefault(),
                // Overrides for "undo", the input.undo method will handle preventingDefault if the input supports custom undo
                new GwKeyListener_1.GwKeyListener("90").withCtrl().withMethodName("gwInputs.undo").withEnableDefault(),
                new GwKeyListener_1.GwKeyListener("90").withMeta().withMethodName("gwInputs.undo").withEnableDefault(),
                new GwKeyListener_1.GwKeyListener("73").withShift().withAlt().withMethodName("gwInternalTools.showPcfStructure").withInternalTool(),
                new GwKeyListener_1.GwKeyListener("87").withShift().withAlt().withMethodName("gwInternalTools.showFullPcfStructure").withInternalTool(),
                new GwKeyListener_1.GwKeyListener("76").withShift().withAlt().withMethodName("gwInternalTools.reloadPCF").withInternalTool(),
                new GwKeyListener_1.GwKeyListener("69").withShift().withAlt().withMethodName("gwInternalTools.editCurrentPageInStudio").withInternalTool(),
                new GwKeyListener_1.GwKeyListener("72").withShift().withAlt().withMethodName("gwApp.openShortcutHelp").withInternalTool(),
                new GwKeyListener_1.GwKeyListener("37").withShift().withAlt().withMethodName("gwNavigation.goWest"),
                new GwKeyListener_1.GwKeyListener("38").withShift().withAlt().withMethodName("gwNavigation.goNorth"),
                new GwKeyListener_1.GwKeyListener("39").withShift().withAlt().withMethodName("gwNavigation.goCenter"),
                new GwKeyListener_1.GwKeyListener("40").withShift().withAlt().withMethodName("gwNavigation.goSouth"),
                new GwKeyListener_1.GwKeyListener("27").withMethodName("gwEvents.escapeKeyPressed") //est
            ];
        }
    };
    /**
     * Used by server side shortcuts to track down the target of the shortcut and return it
     */
    GwKeys.prototype.findServerShortcutKeyTarget = function (id) {
        var widgetNode = gwUtil_1.gwUtil.getDomNode("#" + id);
        var subWidgetNode = null;
        if (!widgetNode ||
            widgetNode.hasAttribute("data-gw-shortcut") ||
            widgetNode.hasAttribute("data-gw-click") ||
            widgetNode.hasAttribute("data-gw-key")) {
            return widgetNode;
        }
        gwUtil_1.gwUtil.forEach($(widgetNode).find("[data-gw-shortcut], [data-gw-click],[data-gw-key]"), function (el) {
            var attr = el.dataset.gwShortcut || el.dataset.gwClick || el.dataset.gwKey;
            var description = GwEventDescription_1.GwEventDescription.parseEventDescription(el, attr);
            if (description && description.id === id) {
                subWidgetNode = el;
                return gwTypes_1.GW_BREAKER;
            }
            else if (attr === "toggleSubMenu") {
                // Assume current element is the target
                subWidgetNode = el;
                return gwTypes_1.GW_BREAKER;
            }
            return; // Keep looking
        });
        return subWidgetNode;
    };
    GwKeys.prototype.addServerKeyboardShortcut = function (shortcutMapKey, eventId) {
        if (!shortcutMapKey) {
            return;
        }
        var useAlt;
        var useShift;
        var keyCode;
        var useCtrl = false; // Control is not currently supported for server side keyShortcuts
        var keyArray = shortcutMapKey.split("::"); // Key is composed of scope and shortcut key and a boolean for openSubMenus
        var shortcutScope = keyArray[0].toUpperCase();
        var shortcutKey = keyArray[1].toUpperCase();
        var openMenuOnShortcut = keyArray[2] === "true";
        if (shortcutKey === "ENTER") {
            useAlt = false;
            useShift = false;
            keyCode = 13;
        }
        else {
            useAlt = true; // Alt is implicit for server defined shortcuts
            // Check for Shift modifier
            if (shortcutKey.indexOf("SHIFT") === 0) {
                useShift = true;
                shortcutKey = shortcutKey.replace("SHIFT", "");
            }
            keyCode = this.getShortcutToKeyCode(shortcutKey).toString();
        }
        var entry = new GwKeyListener_1.GwKeyListener("" + keyCode)
            .withServerEventId(eventId)
            .withShortcutKey(shortcutKey)
            .useCreateEventDescription("server")
            .withOpenMenuOnShortcut(openMenuOnShortcut);
        if (useShift) {
            entry.withShift();
        }
        if (useAlt) {
            entry.withAlt();
        }
        if (useCtrl) {
            entry.withCtrl();
        }
        this.serverShortcutKeyListeners[shortcutScope] = this.serverShortcutKeyListeners[shortcutScope] || [];
        this.serverShortcutKeyListeners[shortcutScope].push(entry);
    };
    GwKeys.prototype.clearServerKeyboardShortcuts = function () {
        this.serverShortcutKeyListeners = {};
    };
    GwKeys.prototype.getServerKeyboardShortcutCharacters = function () {
        var _this = this;
        var characters = {};
        if (this.serverShortcutKeyListeners) {
            Object.keys(this.serverShortcutKeyListeners).forEach(function (scope) {
                _this.serverShortcutKeyListeners[scope].filter(function (shortcut) {
                    // Only allow single character shortcuts.  Multichar shortcut keys are assumed to
                    // be special shortcut keys - e.g. ENTER
                    return shortcut.shortcutKey.length === 1;
                }).forEach(function (shortcut) {
                    characters[shortcut.shortcutKey] = true;
                });
            });
        }
        return Object.keys(characters);
    };
    /**
     * Checks whether a contextual key listener is setup for the current node. If there is a matching
     * spec for the keypress, we see if it is in the designated context, if so returning it as the
     * key listener for this event
     */
    GwKeys.prototype.findMatchingContextualKeyListener = function (e, node, keyCode) {
        var matchingKeyListeners = this.findMatchingKeyListeners(e, this.contextualKeyListeners, keyCode);
        var matchedKeyListener = null;
        gwUtil_1.gwUtil.forEach(matchingKeyListeners, function (entry) {
            if (entry.contextClass) {
                if (gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(node, entry.contextClass) !== null) {
                    matchedKeyListener = entry;
                    return gwTypes_1.GW_BREAKER;
                }
            }
            return;
        });
        return matchedKeyListener;
    };
    /**
     * Returns the keyCode of the associated shortcut.  First we check keycodes to see if there's a keycode
     * shortcut.  If we find no keycode match, we assume the shortcut is a single letter shortcut key.
     *
     * For a single letter shortcut key we usually return the ASCII character code.  However, the shortcut does
     * not always match the keyCode for a given character.  e.g. - the keycode for '.' is 190.  '.'.charCodeAt(0) is 46
     * @param shortcut
     * @returns {Number}
     */
    GwKeys.prototype.getShortcutToKeyCode = function (shortcut) {
        return this.shortcutKeyWordToKeyCodeMap[shortcut] || this.keyCodeMap[shortcut] || shortcut.charCodeAt(0);
    };
    /**
     * Checks server shortcut keys and returns a key listener if it finds a match.
     * Checks current panel Scope to determine the priority of shortcut listeners.
     * If the current scope is South, center is never checked. If Center, south is never checked.
     *
     * @param e
     * @param keyCode
     */
    GwKeys.prototype.findMatchingServerShortcutKeyListener = function (e, keyCode) {
        var currentScope = gwEvents_1.gwEvents.getCurrentScope();
        if (currentScope === "SOUTH" /* SOUTH */) {
            // If the scope is south, don't even check center panel for shortcuts
            return this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["SOUTH" /* SOUTH */], keyCode) ||
                this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["WEST" /* WEST */], keyCode) ||
                this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["NORTH" /* NORTH */], keyCode);
        }
        // If the scope is not south, then don't bother checking south
        return this.findMatchingKeyListener(e, this.serverShortcutKeyListeners[currentScope], keyCode) ||
            this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["CENTER" /* CENTER */], keyCode) ||
            this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["WEST" /* WEST */], keyCode) ||
            this.findMatchingKeyListener(e, this.serverShortcutKeyListeners["NORTH" /* NORTH */], keyCode);
    };
    /**
     * @private
     * Finds the first key listener that matches the given key event in the supplied array of key listener
     * objects, or returns null if none match. A key listener must have a keyCode and may have various other
     * flags such as alt, shift, ctrl, meta, internalTool and enableDefault.
     * @param e: the event
     * @param keyListeners: an array of objects to be matched via keyCode and modifier keys.
     * @param keyCode: the keyCode from the event.
     * @returns {object}
     */
    GwKeys.prototype.findMatchingKeyListener = function (e, keyListeners, keyCode) {
        return this.findMatchingKeyListeners(e, keyListeners, keyCode)[0] || null;
    };
    /**
     * @private
     * Finds all key listeners, in order, that match the given key event in the supplied array of key listener
     * objects, or returns an empty array if none match. A key listener must have a keyCode and may have various other
     * flags such as alt, shift, ctrl, meta, internalTool and enableDefault.
     * @param e: the event
     * @param keyListeners: an array of objects to be matched via keyCode and modifier keys.
     * @param keyCode: the keyCode from the event.
     * @returns {object}
     */
    GwKeys.prototype.findMatchingKeyListeners = function (e, keyListeners, keyCode) {
        var results = [];
        if (keyListeners) {
            var shift = e.shiftKey;
            var alt = e.altKey;
            var ctrl = e.ctrlKey;
            var meta = e.metaKey;
            for (var i = 0; i < keyListeners.length; i++) {
                var entry = keyListeners[i];
                if ((!entry.internalTool || gwEvents_1.gwEvents.internalToolsEnabled())
                    && (!meta === !entry.meta)
                    && (!ctrl === !entry.ctrl)
                    && (!shift === !entry.shift)
                    && (!alt === !entry.alt)
                    && (keyCode === entry.keyCode)) {
                    results.push(entry);
                }
            }
        }
        return results;
    };
    return GwKeys;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwKeys = GwKeys;
exports.gwKeys = new GwKeys();


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gw_1 = __webpack_require__(10);
var gwUtil_1 = __webpack_require__(0);
var gwDisplayKey_1 = __webpack_require__(16);
var gwForm_1 = __webpack_require__(25);
var gwScroll_1 = __webpack_require__(27);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwStorage = /** @class */ (function (_super) {
    __extends(GwStorage, _super);
    function GwStorage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.username = "default_user";
        _this.retryCount = 0;
        /**
         * Used by registerRestoreFunctions to allow any component to register a method to be called
         * @type {{}}
         */
        _this.componentRestoreFunctions = {};
        /**
         * Holds a parsed cache object of the entire user storage, to prevent multiple gets from having to JSON.parse each time.
         * Is invalidated on full page reload and localstorage clear.
         */
        _this.userStorageCache = null;
        return _this;
    }
    GwStorage.prototype.getSystemName = function () {
        return "gwStorage";
    };
    /**
     * Right now this gets called on full page and partial page. Technically, we could do something smart where we
     * only fire the restore ui function for a diffed element, but I'm trying to avoid early optimization.
     * @optimize
     */
    GwStorage.prototype.orderSpecificInit = function (fullPageReload) {
        if (fullPageReload) {
            this.userStorageCache = null;
        }
        this.setCurrentUser();
        //call every function registered by a component that needs to restore local client only settings
        gwUtil_1.gwUtil.forEach(this.componentRestoreFunctions, function (restoreFunc, componentName) {
            var componentObject = gw_1.gw.globals[componentName];
            if (componentObject) {
                componentObject[restoreFunc](); //TODO: make an interface for this
            }
        });
    };
    //TODO: should be able to remove restore registration now
    // /**
    //  * @public
    //  * Allows any component to register a method to be called on UI partial or full page load. During the storage.init method.
    //  * Mainly this is just helpful so each component with client side state doesn't have to initialize itself.
    //  * But all this function ends up doing is just calling gw.componentName.func(); So technically, anything could happen
    //  * in that method. But a component shouldn't have to do anything other than pull from local storage.
    //  * @param componentName: String, the name of component object on the gw global object. ie: gw[componentName]
    //  * @param funcName: String, the name of the method on the gw[componentName] to be called.
    //  */
    // registerComponentRestoreFunction (componentName: string, funcName: string): void {
    //     this.componentRestoreFunctions[componentName] = funcName;
    // }
    /**
     * @private
     * Takes a dot delimited path or pathArray and returns the value at the path on the given object.
     * If any path chunks are undefined, then it creates the object and adds it to the provided storage object
     * @param path
     * @param userStorageObject
     * @returns {*}
     */
    GwStorage.prototype.getValueAtDotPath = function (path, userStorageObject, returnFirstUndefined) {
        if (returnFirstUndefined === void 0) { returnFirstUndefined = false; }
        var arr = Array.isArray(path) ? path : path.split(".");
        var obj = userStorageObject;
        for (var i = 0; i < arr.length; i++) {
            var pathPart = arr[i];
            var objectAtPathPart = obj[pathPart];
            if (objectAtPathPart === undefined || objectAtPathPart === null) {
                //Instead of replacing it with an empty object we'll just return undefined.
                //This allows different methods to use getValueAtDotPath for different needs.
                if (returnFirstUndefined) {
                    return undefined;
                }
                objectAtPathPart = {};
                obj[pathPart] = objectAtPathPart;
            }
            obj = objectAtPathPart;
        }
        return obj;
    };
    /**
     * @private
     * @param path
     * @returns {{key: String, pathArray: String[]}}
     */
    GwStorage.prototype.getKeyAndPathArray = function (path) {
        var arr = Array.isArray(path) ? path : path.split(".");
        var key = arr.pop();
        return { key: key, pathArray: arr }; //TODO: cooper TS
    };
    /**
     * @private
     * Returns the userStorage cache if it exists, or if not, goes and gets it. If still undefined, then creates a new object and returns it.
     * @returns {*}
     */
    GwStorage.prototype.getStorageForUser = function () {
        if (!this.userStorageCache) {
            var storage = localStorage.getItem(this.getStoragePathForUser());
            if (storage) {
                this.userStorageCache = JSON.parse(storage) || {};
            }
            else {
                this.userStorageCache = {};
            }
        }
        return this.userStorageCache;
    };
    /**
     * @private
     * Takes an object, stores it in the userStorageCache, and sets the object at the currentUser key in local storage, after stringifying it.
     * If the set operation throws an error, then it begins a retry loop of catching error, freeing up storage, setting value again.
     * @param obj
     */
    GwStorage.prototype.setStorageForUser = function (obj, errorStatePath, errorStateValue) {
        this.userStorageCache = obj;
        var error;
        try {
            localStorage.setItem(this.getStoragePathForUser(), JSON.stringify(obj));
        }
        catch (e) {
            error = e;
            gwUtil_1.gwUtil.devlog(e.message);
        }
        if (error) {
            this.storageIsFull(error);
            gwUtil_1.gwUtil.devlog("Trying to set storage again after error after clearing up local storage space. RETRY COUNT: ", this.retryCount);
            this.set(errorStatePath, errorStateValue);
            return;
        }
        this.retryCount = 0;
    };
    /**
     * @private
     * This is triggered on attempting to set storage and localStorage throws a full error of error code 22.
     * This method takes the loopCount and increments it, then tries various options to free up local storage space.
     * Based on the value of the loopCount.
     * 1. Deletes other local user storage.
     * 2. Deletes all dirty data storage.
     * 3. Deletes all local storage.
     * 4. Throws its hands up.
     * @param errLoopCount
     * @param e
     */
    GwStorage.prototype.storageIsFull = function (e) {
        this.retryCount++;
        //clear any other users
        if (this.retryCount === 1) {
            //delete all other users
            for (var key in localStorage) {
                if (key !== this.getCurrentUser()) {
                    window.localStorage.removeItem(key);
                }
            }
        }
        else if (this.retryCount === 2) {
            //deleting all data for other users didn't help us, so delete likely large chunks.
            this.remove(gwForm_1.gwForm.dirtyIdMapKey); // Dirty Data Storage
            this.remove(gwScroll_1.gwScroll.scrollKey); // Scroll Position Storage
        }
        else if (this.retryCount === 3) {
            //who knows what went wrong, so we'll wipe the whole thing just to be certain.
            window.localStorage.clear();
            this.userStorageCache = null;
        }
        else {
            //blowup, as we were unable to free up enough local space for the current set.
            throw e;
        }
    };
    /**
     * @public
     * Sets a key value pair in local storage at a dotDelimted path. k<String>, v<*>
     *     Calls setStorageForUser
     * @param dotPath: dot delimted path.
     * @param value: any valid JSON stringify-able value
     */
    GwStorage.prototype.set = function (dotPath, value) {
        if (!("localStorage" in window)) {
            return;
        }
        this.retryCount = this.retryCount || 0;
        var keyAndPathArr = this.getKeyAndPathArray(dotPath);
        var pathArray = keyAndPathArr.pathArray;
        var finalKey = keyAndPathArr.key;
        var userStorageObject = this.getStorageForUser();
        var obj = this.getValueAtDotPath(pathArray, userStorageObject);
        if (value === null || value === "null" || value === undefined || value === "undefined") {
            delete obj[finalKey];
        }
        else {
            obj[finalKey] = value;
        }
        this.setStorageForUser(userStorageObject, dotPath, value);
    };
    /**
     * @public
     * get a value at key in local storage. k<String>, v<String> but the set and get are modified to allow
     * booleans to be set and get as actual booleans, for ease of use.
     * @param dotPath: String, unique
     * @return {*}: if value is "true" or "false" will convert to boolean. if "null" will convert to null;
     */
    GwStorage.prototype.get = function (dotPath) {
        if (!("localStorage" in window)) {
            return;
        }
        var value = this.getValueAtDotPath(dotPath, this.getStorageForUser(), true);
        return gwUtil_1.gwUtil.convertIfString(value);
    };
    GwStorage.prototype.toggleFlag = function (dotPath, optDefault) {
        //TODO, @optimize. This could pull and set on the same object to be faster.
        var currVal = this.get(dotPath);
        if (!gwUtil_1.gwUtil.hasValue(currVal)) {
            currVal = optDefault;
        }
        this.set(dotPath, !currVal);
        return !currVal;
    };
    /**
     * Helper method to remove a value. Just calls .set with null
     * @param dotPath
     */
    GwStorage.prototype.remove = function (dotPath) {
        this.set(dotPath, null);
    };
    /**
     * @private
     * @returns {*}
     */
    GwStorage.prototype.getStoragePathForUser = function () {
        return this.getCurrentUser();
    };
    /**
     * @public
     * Stores the current user name.
     * @param user
     */
    GwStorage.prototype.setCurrentUser = function (user) {
        //TODO: add way to get actual user name someday.
        this.username = user || this.username;
    };
    /**
     * @public
     * @returns {*}
     */
    GwStorage.prototype.getCurrentUser = function () {
        return this.username;
    };
    /**
     * @public
     * Deletes local storage for the current username.
     */
    GwStorage.prototype.clearStorage = function () {
        if (!window.confirm(gwDisplayKey_1.gwDisplayKey.get("Web.Client.ConfirmClearLocalStorage"))) {
            return;
        }
        this.userStorageCache = null;
        localStorage.removeItem(this.getStoragePathForUser());
        location.reload(false);
    };
    /**
     * @debug
     */
    GwStorage.prototype.debug_MaxOutStorage = function (doNotReset) {
        if (doNotReset === void 0) { doNotReset = false; }
        var maxTest = "MaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTestMaxOutStorageTest";
        var shouldBreak = false;
        var lastSafeString;
        for (var i = 0; i < 10; i++) {
            lastSafeString = maxTest;
            try {
                maxTest = maxTest + maxTest;
            }
            catch (e) {
                shouldBreak = true;
            }
            if (shouldBreak) {
                break;
            }
        }
        var lastTime = +new Date();
        var thisTime;
        for (var i = 0; i < 200; i++) {
            gwUtil_1.gwUtil.devlog("Maxing Out Storage: ", i);
            thisTime = +new Date();
            if (thisTime - lastTime > 1000) {
                break;
            }
            lastTime = thisTime;
            this.set("MaxOutStorageTest" + i + Math.random(), lastSafeString);
        }
        if (!doNotReset) {
            localStorage.clear();
        }
    };
    return GwStorage;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwStorage = GwStorage;
exports.gwStorage = new GwStorage();


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwInputs_1 = __webpack_require__(5);
var gwStorage_1 = __webpack_require__(24);
var gwUtil_1 = __webpack_require__(0);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwForm = /** @class */ (function (_super) {
    __extends(GwForm, _super);
    function GwForm() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dirtyIdMapKey = "Forms_DirtyIdMap";
        _this.changedClass = "gw-changed";
        _this.editControllerAttr = "data-gw-edit-id";
        _this.doNotTrackDirtyDataClass = "gw-noTrack";
        _this._editableControllers = null;
        return _this;
    }
    GwForm.prototype.getSystemName = function () {
        return "gwForm";
    };
    GwForm.prototype.init = function (isFullPage) {
        this.refreshEditControllersInStorage();
        this.recheckDirtyStatusOfInputs(false);
        this._editableControllers = null;
    };
    // ============ public helper methods =================
    GwForm.prototype.testIfInputHasChangedValue = function (el) {
        var results = this.checkIfDirtyByType(el);
        if (!results) {
            return false;
        }
        return results.changed;
    };
    GwForm.prototype.isDirty = function () {
        return this.recheckDirtyStatusOfInputs(true);
    };
    // =========== methods internal to the form systems ============
    /**
     * @param el
     * @returns {*}
     */
    GwForm.prototype.getValueSynonym = function (el) {
        var type = gwInputs_1.gwInputs.inputType(el);
        if (type === "text") {
            return el.value;
        }
        else if (type === "radio" || type === "checkbox") {
            return el.checked;
        }
        else if (type === "select" || type === "option") {
            if (type === "option") {
                el = this.getElWithIdMatchingName(el);
            }
            return gwInputs_1.gwInputs.defaultSelectedIndex(el);
        }
        return null;
    };
    /**
     * @private
     * iterates over all the dirtyIdMapKey edit contexts. If it's currently on the screen then iterates all inputs
     * listed, and compares their original value vs their current value.
     */
    GwForm.prototype.recheckDirtyStatusOfInputs = function (testForAnyDirty) {
        var _this = this;
        var dirtyMap = gwStorage_1.gwStorage.get(this.dirtyIdMapKey);
        var foundAnyDirty = false;
        gwUtil_1.gwUtil.forEach(dirtyMap, function (inputElementsObject, editControllerId) {
            var screenEl = gwUtil_1.gwUtil.getDomNodeByAttr(_this.editControllerAttr, editControllerId);
            if (!screenEl) {
                return; //continue;
            }
            gwUtil_1.gwUtil.forEach(inputElementsObject, function (elementDefaultValue, elementId) {
                var inputEl = gwUtil_1.gwUtil.getDomNodeByAttr("name", elementId, screenEl);
                if (inputEl) {
                    var dirty = _this.getValueSynonym(inputEl) !== elementDefaultValue;
                    if (testForAnyDirty && dirty) {
                        foundAnyDirty = true;
                        return;
                    }
                    gwUtil_1.gwUtil.conditionalAddRemoveClass(dirty, inputEl, _this.changedClass);
                }
            });
        });
        return foundAnyDirty;
    };
    GwForm.prototype.checkDirtySingleSelect = function (el) {
        var element = el;
        var defIndex = 0;
        for (var i = 0; i < element.options.length; i++) {
            if (element.options[i].defaultSelected) {
                defIndex = i;
                break;
            }
        }
        var changed = (defIndex !== element.selectedIndex);
        var val = element.options[defIndex].value;
        return { el: element, changed: changed, val: val };
    };
    GwForm.prototype.checkDirtyMultiSelect = function (el) {
        var element = el;
        var opt;
        var changed = false;
        var val = "";
        for (var i = 0; i < element.options.length; i++) {
            opt = element.options[i];
            changed = changed || (opt.selected !== opt.defaultSelected);
            if (opt.defaultSelected) {
                val += element.options[i].value + ";";
            }
        }
        return { el: element, changed: changed, val: val };
    };
    /**
     * @private
     * @param el
     */
    GwForm.prototype.checkIfDirtyByType = function (el) {
        var type = gwInputs_1.gwInputs.inputType(el);
        if (!type) {
            return null;
        }
        var changed = false;
        var val = null;
        if (type === "text") {
            changed = el.value !== el.defaultValue;
            val = el.defaultValue;
        }
        else if (type === "radio" || type === "checkbox") {
            changed = el.checked !== el.defaultChecked;
            val = el.defaultChecked;
            el = this.getElWithIdMatchingName(el);
        }
        else if (type === "select" || type === "option") {
            if (type === "option") {
                el = this.getElWithIdMatchingName(el);
            }
            var element = el;
            if (element.multiple) {
                return this.checkDirtyMultiSelect(el);
            }
            else {
                return this.checkDirtySingleSelect(el);
            }
        }
        else {
            gwUtil_1.gwUtil.devlog("WARNING: gw.form.checkIfDirtyByType handed an element that doesn't conform to expected type: ", el);
        }
        return { el: el, changed: changed, val: val };
    };
    GwForm.prototype.getElWithIdMatchingName = function (el) {
        var type = el.tagName.toLowerCase();
        if (type === "option") {
            return $(el).closest("select")[0];
        }
        return $(el).closest("#" + el.getAttribute("name"))[0] || el;
    };
    /**
     * @public
     * Called by the onChange and onInput event listener in events.js;
     * @param el
     */
    GwForm.prototype.elementChanged = function (el) {
        // If an input element doesn't have a name, then it's not part of the form field
        if (!el.hasAttribute("name") || gwUtil_1.gwUtil.hasClass(el, this.doNotTrackDirtyDataClass)) {
            return;
        }
        var changedAndVal = this.checkIfDirtyByType(el);
        if (!changedAndVal) {
            return;
        }
        if (changedAndVal.changed) {
            this.setElementAsDirty(changedAndVal.el, changedAndVal.val);
        }
        else {
            this.setElementAsClean(changedAndVal.el);
        }
    };
    /**
     * @public
     * Called by cmds.js to set editController dirty data to clear, when form.js runs init.
     * @param spaceDelimitedIds
     */
    GwForm.prototype.setEditableControllers = function (spaceDelimitedIds) {
        this._editableControllers = spaceDelimitedIds;
    };
    /**
     * @public
     */
    GwForm.prototype.refreshEditControllersInStorage = function () {
        var storageMap = gwStorage_1.gwStorage.get(this.dirtyIdMapKey);
        if (!storageMap) {
            return;
        }
        this._editableControllers = this._editableControllers || "";
        var ids = this._editableControllers.split(" ");
        var allowedIdMap = {};
        //Make a map of all the allowed editController ids.
        gwUtil_1.gwUtil.forEach(ids, function (id) {
            allowedIdMap[id] = true;
        });
        var foundDiff = false;
        //Remove any stored data for an edit controller not listed in allowed ids
        gwUtil_1.gwUtil.forEach(storageMap, function (data, key) {
            if (!allowedIdMap[key]) {
                foundDiff = true;
                storageMap[key] = null;
            }
        });
        if (foundDiff) {
            gwStorage_1.gwStorage.set(this.dirtyIdMapKey, storageMap);
        }
    };
    /**
     * @public
     * Wipes all stored dirty data information.
     */
    GwForm.prototype.clearAllDirtyData = function () {
        gwStorage_1.gwStorage.remove(this.dirtyIdMapKey);
    };
    /**
     * @private
     * @param screenEl
     * @returns {string} dirtyMapId.editId.elementIdOrName
     */
    GwForm.prototype.getScreenDotPath = function (screenEl) {
        if (!screenEl) {
            return "";
        }
        var editId = screenEl.getAttribute(this.editControllerAttr);
        if (!editId) {
            gwUtil_1.gwUtil.devlog("WARNING Screen Widget missing an edit id", screenEl);
        }
        return this.dirtyIdMapKey + "." + editId;
    };
    /**
     * @private
     * @param el - Dom element
     * @returns {string} dot delimited path of dirtyIdMap.editId.elementIdOrName
     */
    GwForm.prototype.getScreenBasedDotPathForElement = function (el) {
        var screen = $(el).closest(".gw-ScreenWidget")[0];
        if (!screen) {
            return "";
        }
        var elementId = el.getAttribute("name") || el.getAttribute("id");
        return this.getScreenDotPath(screen) + "." + elementId;
    };
    GwForm.prototype.getChangeTargetElement = function (el) {
        // In the case of a multi-select, add the changed class directly to the select element
        if (el.type === "select-multiple") {
            return el;
        }
        else {
            return this.getElWithIdMatchingName(el);
        }
    };
    /**
     * @private
     */
    GwForm.prototype.setElementAsDirty = function (el, val) {
        var dotPath = this.getScreenBasedDotPathForElement(el);
        if (dotPath) {
            gwStorage_1.gwStorage.set(dotPath, val);
            gwUtil_1.gwUtil.addClass(this.getChangeTargetElement(el), this.changedClass);
        }
    };
    /**
     * @private
     * @param el
     */
    GwForm.prototype.setElementAsClean = function (el) {
        var dotPath = this.getScreenBasedDotPathForElement(el);
        if (dotPath) {
            gwStorage_1.gwStorage.remove(dotPath);
            gwUtil_1.gwUtil.removeClass(this.getChangeTargetElement(el), this.changedClass);
        }
    };
    return GwForm;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwForm = GwForm;
exports.gwForm = new GwForm();


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Handler of all "dropdown" menu systems. All objects involved in menus are MenuItemWidgets, but are differentiated
 * based on a number of factors: parent container, whether it's in a submenu or is a top level menu.
 * Dropdown menus can be on stand alone buttons, in toolbars, in header cells, navigation tabs, left navigation, etc.
 * The one thing they have in common is their structure:
 *
 *      <div class="gw-action--outer"> // Handles any mouseenter, mouseleave, focus, or blur
 *          <div class="gw-action--inner">LABEL</div> fires the primary action if any when clicked
 *          <div class="gw-action--expand-button">ICON</div> toggles the subMenu when clicked
 *          <div class="gw-subMenu">
 *              ...children
 *          </div>
 *      </div>
 *
 * Note: One oddity: calling openSubMenu only registers the subMenu to be opened. We have to call "closeAllMenus" at various
 * points in the event chain. So only after closing all menus, do we then call make makeMenuVisibleInDom on the stored subMenu,
 * which then makes it and all of it's ancestor menus visible.
 *
 * See menus.scss for SASS mixins.
 * @type {{}}
 */
var gwTypes_1 = __webpack_require__(20);
var gwNavigation_1 = __webpack_require__(86);
var gwUtil_1 = __webpack_require__(0);
var gwFocus_1 = __webpack_require__(8);
var GwInitializableSystem_1 = __webpack_require__(4);
var gwEvents_1 = __webpack_require__(3);
var GwMenus = /** @class */ (function (_super) {
    __extends(GwMenus, _super);
    function GwMenus() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.menuVerticalScrollAmount = "";
        /**
         * id and element
         * if a menu is toggled open, it needs to register itself so the mouse event doesn't close it as part of closing all the menus
         * @type {{}}
         */
        _this.storedMenuToOpenAfterClosingOthers = {};
        /**
         * map of id:el
         * @type {{[id]:[el]}}
         */
        _this.currentlyOpenMenus = {};
        /**
         * Store the groupname of the currently open top level menu group
         * @type {string}
         */
        _this.topLevelGroupMenuOpen = "";
        return _this;
    }
    GwMenus.prototype.getSystemName = function () {
        return "gwMenus";
    };
    GwMenus.prototype.init = function () {
        gwNavigation_1.gwNavigation.registerNavClasses(["gw-action--outer", "gw-action--inner", "gw-action--expand-button"], exports.gwMenus);
    };
    // Menu boundaries
    GwMenus.prototype.getBoundaries = function () {
        return {
            top: 0,
            bottom: window.innerHeight,
            left: 0,
            right: window.innerWidth
        };
    };
    /**
     * @private
     * Returns the first node, including the node itself, that is gw-action--outer with .gw-hasChildren.
     *
     * Has a safety check depth of 10. This means that if you actually have a focusable element 10 layers deep
     * inside of the outer, then it won't get there.
     * @param node - DOM Element
     * @param nullIfFoundActionButNoChildren - if true will return null when a gw-action--outer is found with no children,
     * otherwise the closest .gw-action--outer with children will be returned.
     * @returns {DOM Elmement or null}
     */
    GwMenus.prototype.getSelfOrFirstParentActionOptionallyWithChildren = function (node, nullIfFoundActionButNoChildren) {
        if (nullIfFoundActionButNoChildren === void 0) { nullIfFoundActionButNoChildren = false; }
        var safety = 10;
        var testNode = node;
        while (testNode && (safety-- > 0)) {
            if (gwUtil_1.gwUtil.hasClass(testNode, "gw-action--outer")) {
                if (gwUtil_1.gwUtil.hasClass(testNode, "gw-hasChildren")) {
                    return testNode;
                }
                if (nullIfFoundActionButNoChildren) {
                    return null;
                }
            }
            testNode = testNode.parentElement;
        }
        return null;
    };
    /**
     * Should only be called by the global mouseenter event.
     * If this method was triggered by a browser attempting to be "helpful" and calling mouseover when you touch down, then this becomes a noop
     * @param node
     */
    GwMenus.prototype.openSubMenuMouseEnter = function (node) {
        if (!node.hasAttribute("data-gw-menu-hover") || gwEvents_1.gwEvents.isCurrentlyInTouchEvent()) {
            return;
        }
        this.openSubMenu(node, "mouseenter");
    };
    GwMenus.prototype.isSubMenusBelow = function (menuElement) {
        return gwUtil_1.gwUtil.hasClass(menuElement, "gw-putSubMenusBelow");
    };
    /**
     * @private
     * Takes a DOM element and makes it's subMenu visible, then walks up the dom and makes any ancestor menus visible as well.
     * - if gw-putSubMenusBelow class is present, then moves the subMenu to render like a top NavBar would
     * - otherwise it renders like a subMenu would, to the right of the menu item, top aligned.
     * - finds the first child element with gw-subMenu, and adds the class gw-open to it.
     * - It then runs logic to determine if the subMenu would be off the screen, and if it is, aligns it to the otherside of that axis
     * - Looks for a parent menu, and makes a recursive call passing the parent as an argument.
     * @param el
     * @returns {null}
     */
    GwMenus.prototype.makeMenuVisibleInDom = function (el) {
        var _this = this;
        var subMenusBelow = this.isSubMenusBelow(el);
        var subMenu = el.querySelector(".gw-subMenu");
        if (!subMenu) {
            return;
        }
        var staticMenus = gwUtil_1.gwUtil.hasClass(el, "gw-staticMenus");
        gwUtil_1.gwUtil.addClass(el, "gw-hasOpenSubMenu");
        gwUtil_1.gwUtil.addClass(subMenu, "gw-open");
        // If menus are set to display: none when hidden, then querying their bounds in the current frame
        // returns null results. So we push the query into the next animation frame, which will have the correct values
        // and also serve to batch some of the multiple calls.
        window.requestAnimationFrame(function () {
            if (!staticMenus) {
                _this.resetHiddenMenus(subMenu);
                var parentRect = el.getBoundingClientRect();
                // subMenu may be modified within the current animation frame; this means the height of the boundClientRect
                // may be reset to 0.  Manually calculate height of the menu.
                var subMenuHeight = _this.getSubMenuHeight(subMenu);
                var subMenuWidth = _this.getSubMenuWidth(subMenu);
                var boundaries = _this.getBoundaries();
                // -- Handle menu location east and west -- //
                var subMenuLeftEdge = 0;
                if (parentRect.right + subMenuWidth > boundaries.right) {
                    if (subMenusBelow) {
                        subMenuLeftEdge = parentRect.right - subMenuWidth;
                    }
                    else {
                        subMenuLeftEdge = parentRect.left - subMenuWidth;
                    }
                }
                else {
                    if (subMenusBelow) {
                        subMenuLeftEdge = parentRect.left;
                    }
                    else {
                        subMenuLeftEdge = parentRect.right;
                    }
                }
                // Handle case where left edge of menu is offscreen to the left by shifting it to the left edge of the window
                subMenuLeftEdge = Math.max(subMenuLeftEdge, 0);
                // If it's not already being rendering below and it overlaps the parent menu, shift it down (so the parent menu
                // is visible)
                if (!subMenusBelow && (subMenuLeftEdge < parentRect.right) && (subMenuLeftEdge + subMenuWidth > parentRect.left)) {
                    subMenusBelow = true;
                }
                subMenu.style.left = subMenuLeftEdge + "px";
                if (subMenuHeight > (boundaries.bottom - boundaries.top)) {
                    _this.buildScrollingMenu(subMenu, boundaries, subMenu.style.left);
                }
                else {
                    _this.resetMenuArrows(subMenu);
                    _this.buildNonScrollingMenu(subMenu, boundaries, subMenuHeight, subMenusBelow, parentRect);
                }
            }
        });
        if (!staticMenus) {
            this.currentlyOpenMenus[el.id] = el;
            if (gwUtil_1.gwUtil.hasClass(el, "gw-isTopLevelMenu")) {
                this.topLevelGroupMenuOpen = this.getMenuGroup(el);
                return;
            }
            var possibleParent = $(el).parents(".gw-hasChildren")[0];
            if (possibleParent) {
                this.makeMenuVisibleInDom(possibleParent);
            }
        }
    };
    GwMenus.prototype.isMultiColumnMenu = function (menu) {
        return gwUtil_1.gwUtil.hasClass(menu.firstElementChild, "gw-menu-col");
    };
    GwMenus.prototype.getSubMenuWidth = function (subMenu) {
        var subMenuWidth = 0;
        // Using .clientWidth or .offsetWidth fluctuates in value by 1 pixel in Chrome in Windows
        // under certain cases (e.g. - in PX for AF menus when AF located in hamburger menu happens to be in
        // the right place at the right width for this to manifest as the menu alternating rendering from left
        // to right)
        // getBoundingClientRect does not seem to have the same issue.
        if (subMenu.children && subMenu.children.length > 0) {
            if (this.isMultiColumnMenu(subMenu)) {
                gwUtil_1.gwUtil.forEach(subMenu.children, function (subMenuColumn) {
                    subMenuWidth = subMenuWidth + Math.ceil(subMenuColumn.getBoundingClientRect().width);
                });
            }
            else {
                subMenuWidth = Math.ceil(subMenu.getBoundingClientRect().width);
            }
        }
        return subMenuWidth;
    };
    GwMenus.prototype.getSubMenuHeight = function (subMenu) {
        var _this = this;
        var subMenuHeight = 0;
        if (subMenu.children && subMenu.children.length > 0) {
            if (this.isMultiColumnMenu(subMenu)) {
                // When menu containers specify numEntriesPerColumn, column(s) are generated
                // based on the number of total menu entries; grab the tallest column and use its height.
                // Note, because a single "entry" can contain multiple menu items in the form of flattened menus,
                // the first column is not guaranteed to be the tallest column.
                var tallestColumnHeight_1 = 0;
                gwUtil_1.gwUtil.forEach(subMenu.children, function (subMenuColumn) {
                    var columnHeight = _this.getSubMenuHeight(subMenuColumn);
                    if (columnHeight > tallestColumnHeight_1) {
                        tallestColumnHeight_1 = columnHeight;
                    }
                });
                return tallestColumnHeight_1;
            }
            else {
                gwUtil_1.gwUtil.forEach(subMenu.children, function (child) {
                    subMenuHeight = subMenuHeight + child.offsetHeight;
                });
            }
        }
        return subMenuHeight;
    };
    GwMenus.prototype.resetHiddenMenus = function (menu) {
        $(menu.children).removeClass("gw-hidden-menu");
    };
    GwMenus.prototype.resetMenuArrows = function (menu) {
        $(menu).find("> div.gw-scrolling-menu-arrow").remove();
        $(menu).removeClass("gw-subMenu--scrolling");
    };
    GwMenus.prototype.buildScrollingMenu = function (menu, panelBoundaries, subMenuLeftStyle) {
        var _this = this;
        var menuId = this.getMenuId(menu);
        var upArrowId = menuId + "_menuUp";
        var downArrowId = menuId + "_menuDown";
        var menuWidth = menu.offsetWidth;
        var newUpArrow = false;
        var newDownArrow = false;
        // --- Build or reuse up arrow --- //
        var upArrow = $(menu).find("#" + upArrowId)[0];
        if (!upArrow) {
            upArrow = this.buildArrow(upArrowId, "gw-menu--up-arrow", "Up" /* up */, "" + menuWidth);
            upArrow.style.top = "0px";
            $(upArrow).addClass("gw-disabled");
            $(upArrow).appendTo(menu);
            newUpArrow = true;
        }
        upArrow.style.left = subMenuLeftStyle;
        // --- Build or reuse down arrow --- //
        var downArrow = $(menu).find("#" + downArrowId)[0];
        if (!downArrow) {
            downArrow = this.buildArrow(downArrowId, "gw-menu--down-arrow", "Down" /* down */, "" + menuWidth);
            downArrow.style.bottom = "0px";
            $(downArrow).appendTo(menu);
            newDownArrow = true;
        }
        downArrow.style.left = subMenuLeftStyle;
        // --- Add hover scrolling support --- //
        if (newUpArrow) {
            $(upArrow).hover(function () {
                if (!gwUtil_1.gwUtil.hasClass(upArrow, "gw-disabled")) {
                    _this.menuVerticalScrollAmount = "-=15"; // TODO: make scroll speed configurable?
                    _this.scroll(menu, upArrow, downArrow);
                }
            }, function () {
                _this.menuVerticalScrollAmount = "";
            });
        }
        if (newDownArrow) {
            $(downArrow).hover(function () {
                if (!gwUtil_1.gwUtil.hasClass(downArrow, "gw-disabled")) {
                    _this.menuVerticalScrollAmount = "+=15"; // TODO: make scroll speed configurable?
                    _this.scroll(menu, upArrow, downArrow);
                }
            }, function () {
                _this.menuVerticalScrollAmount = "";
            });
        }
        menu.style["top"] = panelBoundaries.top + "px";
        menu.style["bottom"] = panelBoundaries.bottom + "px";
        menu.style["height"] = panelBoundaries.bottom - panelBoundaries.top + "px";
        $(menu).addClass("gw-subMenu--scrolling");
    };
    GwMenus.prototype.scroll = function (scrollContainer, upArrow, downArrow) {
        var _this = this;
        $(scrollContainer).animate({
            scrollTop: this.menuVerticalScrollAmount
        }, 100, "linear", function () {
            if (_this.menuVerticalScrollAmount !== "") {
                _this.scroll(scrollContainer, upArrow, downArrow);
                _this.updateUpArrowStatus(scrollContainer, upArrow);
                _this.updateDownArrowStatus(scrollContainer, downArrow);
            }
        });
    };
    GwMenus.prototype.updateUpArrowStatus = function (menu, upArrow) {
        if (menu.scrollTop <= 0) {
            gwUtil_1.gwUtil.addClass(upArrow, "gw-disabled");
        }
        else {
            gwUtil_1.gwUtil.removeClass(upArrow, "gw-disabled");
        }
    };
    GwMenus.prototype.updateDownArrowStatus = function (menu, downArrow) {
        if (menu.offsetHeight === menu.scrollHeight) {
            return; // Occurs on initial state.  Kick out in this case
        }
        if ((menu.scrollTop + menu.offsetHeight) >= menu.scrollHeight) {
            gwUtil_1.gwUtil.addClass(downArrow, "gw-disabled");
        }
        else {
            gwUtil_1.gwUtil.removeClass(downArrow, "gw-disabled");
        }
    };
    GwMenus.prototype.buildArrow = function (id, arrowClass, direction, width) {
        var arrow = $("<div id=\"" + id + "\" class=\"" + arrowClass + " gw-scrolling-menu-arrow\" " +
            "data-gw-click=\"gwMenus.scrollMenu" + direction + "\">" +
            "<div class=\"gw-icon\"></div>" +
            "</div>")[0];
        $(arrow).width(width);
        return arrow;
    };
    GwMenus.prototype.buildNonScrollingMenu = function (menu, boundaries, totalMenuHeight, subMenusBelow, parentRect) {
        // Vertical position
        if (subMenusBelow) {
            if (parentRect.bottom + totalMenuHeight > boundaries.bottom) {
                if ((parentRect.top - totalMenuHeight) >= boundaries.top) {
                    // render above parent
                    menu.style.top = (parentRect.top - totalMenuHeight) + "px";
                }
                else {
                    menu.style.top = (boundaries.bottom - totalMenuHeight) + "px";
                }
            }
            else {
                menu.style.top = parentRect.bottom + "px";
            }
        }
        else if (parentRect.top + totalMenuHeight > boundaries.bottom) {
            // Not enough room below to render full menu
            if (parentRect.top - totalMenuHeight >= boundaries.top) {
                // There's enough room above, render upward
                menu.style.top = parentRect.bottom - menu.clientHeight + "px";
            }
            else {
                // This aligns the bottom of the menu with the bottom of the screen,
                // to ensure we don't push it somewhere weird
                menu.style.top = boundaries.bottom - menu.clientHeight + "px";
            }
        }
        else {
            menu.style.top = parentRect.top + "px";
        }
    };
    GwMenus.prototype.scrollMenuUp = function (arrow, args, e) {
        this.scrollMenu(arrow, "Up" /* up */);
    };
    GwMenus.prototype.scrollMenuDown = function (arrow, args, e) {
        this.scrollMenu(arrow, "Down" /* down */);
    };
    GwMenus.prototype.scrollMenu = function (arrow, direction) {
        if (gwUtil_1.gwUtil.hasClass(arrow, "gw-disabled")) {
            return;
        }
        var scroller = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(arrow, "gw-subMenu");
        if (!scroller) {
            return;
        }
        var scrollAmount = this.calculateScrollAmount(scroller, direction);
        scroller.scrollTop += scrollAmount;
        // --- Manage enabled/disabled state for both arrows --- //
        var otherArrow = this.getOtherArrow(arrow);
        var upArrow;
        var downArrow;
        if (gwUtil_1.gwUtil.hasClass(arrow, "gw-menu--up-arrow")) {
            upArrow = arrow;
            downArrow = otherArrow;
        }
        else {
            upArrow = otherArrow;
            downArrow = arrow;
        }
        this.updateUpArrowStatus(scroller, upArrow);
        this.updateDownArrowStatus(scroller, downArrow);
    };
    GwMenus.prototype.calculateScrollAmount = function (scroller, direction) {
        // TODO: Currently just use the height of the first menu item.
        // Could be changed to calculate the next menu item up or down.
        var menuItems = $(scroller).find(".gw-action--outer");
        var scrollAmount = menuItems[0].offsetHeight;
        if (direction === "Up" /* up */) {
            return -scrollAmount;
        }
        else {
            return scrollAmount;
        }
    };
    GwMenus.prototype.getOtherArrow = function (arrow) {
        var arrows = $(arrow.parentElement).find("> .gw-scrolling-menu-arrow");
        if (arrows.length === 2) {
            return arrow === arrows[0] ? arrows[1] : arrows[0];
        }
        throw new Error("scroll arrows error");
    };
    GwMenus.prototype.getMenuId = function (menu) {
        var enclosingMenu = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(menu, "gw-action--outer");
        if (!enclosingMenu) {
            throw new Error("unable to locate enclosing menu");
        }
        return enclosingMenu.id;
    };
    /**
     * Sets 'storedMenuToOpenAfterClosingOthers', after checking various open menu logic:
     * 1. if this is from a mouseover event, and the el is top level, check to see if there is an open top
     *    menu group that is already open.  If the el's menu group menu does not match, kick out.  If it's
     *    not a top level menu, it means it is an open submenu and we can go ahead and call fetchMenuIfNeeded
     * 2. store the menu to be opened
     * 3. if this is a mouse click event, kick out.  Rely on events.doAfterAnyClick to handle closing and then opening
     *    opening the menu stored in step 2.
     * 4. if not a click (mouse over or keyboard), close all menus and open the stored menu
     *
     * If the event type is click, then this method defers all open and closing to the doAfterAnyClick methodf
     * @param classIdTagOrNode - a clickable element either inside a gw-action--outer node, or the node itself.
     * @param eventType - (Optional) the event type associated with the method call. mouseover and click have special handling
     * @returns {null}
     */
    GwMenus.prototype.openSubMenu = function (classIdTagOrNode, eventType) {
        var el = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        var parent = this.getSelfOrFirstParentActionOptionallyWithChildren(el, false);
        if (!parent || gwUtil_1.gwUtil.hasClass(parent, "gw-disabled")) {
            return;
        }
        if (eventType === "mouseenter") {
            // If this is from a mouseover, and is a top level parent, check to see if if the toplevel's menu group
            // matches the current topLevelGroupMenu.  If it does not match, then do not open its sub menus.
            if (gwUtil_1.gwUtil.hasClass(parent, "gw-isTopLevelMenu")) {
                var menuGroup = this.getMenuGroup(parent);
                if (this.topLevelGroupMenuOpen !== menuGroup) {
                    return;
                }
            }
            this.fetchMenuIfNeeded(parent);
        }
        this.storedMenuToOpenAfterClosingOthers = { id: parent.id, el: parent };
        if (eventType === "click") {
            //NOTE: if open subMenu was called as a result of a click, then doAfterAnyClick will handle the final call to
            //openStoredMenu. Which is confusing, but needs to be handled so that global clicking can close menus efficiently
            return;
        }
        this.closeAllMenus();
        this.openStoredMenu();
    };
    /**
     * @private Gets the menu group from the passed in element.  If no group is specifiec, returns "NoGroup"
     * @param el
     * @returns {string|string}
     */
    GwMenus.prototype.getMenuGroup = function (el) {
        return el.getAttribute("data-gw-menu-group") || "NoGroup";
    };
    /**
     * Fired after any click event, or inside of openSubMenu, if the call came from a mouseover event.
     * Iterates over all currentlyOpenMenus and closes them.
     */
    GwMenus.prototype.closeAllMenus = function () {
        var _this = this;
        gwUtil_1.gwUtil.forEach(this.currentlyOpenMenus, function (el) {
            _this.closeSubMenu(el);
        });
        this.currentlyOpenMenus = {};
    };
    GwMenus.prototype.closeAllMenusContainedBy = function (parentElem) {
        var _this = this;
        if (!parentElem || (Object.keys(this.currentlyOpenMenus).length > 100)) {
            this.closeAllMenus();
            return;
        }
        gwUtil_1.gwUtil.forEach(this.currentlyOpenMenus, function (el) {
            if ($.contains(parentElem, el)) {
                _this.closeSubMenu(el);
            }
        });
    };
    /**
     * Takes the storedMenuToOpenAfterClosing element, and if it exists, fires makeMenuVisibleInDom on it.
     * -If the storedMenuToOpenAfterClosingOthers.restoreFocusSelector exists
     * then calls setFocusToClosestFocusableSelfOrParent on it
     */
    GwMenus.prototype.openStoredMenu = function () {
        var el = this.storedMenuToOpenAfterClosingOthers.el;
        if (!el) {
            return;
        }
        var restoreFocusSelector = this.storedMenuToOpenAfterClosingOthers.restoreFocusSelector;
        this.storedMenuToOpenAfterClosingOthers = {};
        this.makeMenuVisibleInDom(el);
        if (restoreFocusSelector) {
            var restoreFocusEl = document.querySelector(restoreFocusSelector);
            gwNavigation_1.gwNavigation.setFocusToClosestFocusableSelfOrParent(restoreFocusEl);
        }
    };
    /**
     * @public
     * Takes the first result of getDomNodes. And then runs getSelfOrFirstParentActionOptionallyWithChildren to find a gw-action--outer element.
     * Removes the gw-open class from the first child with gw-subMenu found
     * -If the currentFocus is found to be effectively a direct child of the subMenu, then calls setFocusToClosestFocusableSelfOrParent on it
     * @param classIdTagOrNode
     */
    GwMenus.prototype.closeSubMenu = function (classIdTagOrNode) {
        var _this = this;
        var el = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        var parent = this.getSelfOrFirstParentActionOptionallyWithChildren(el, true);
        if (!parent) {
            return;
        }
        delete this.currentlyOpenMenus[parent.id];
        gwUtil_1.gwUtil.removeClass(parent, "gw-hasOpenSubMenu");
        gwUtil_1.gwUtil.removeClass(parent.getElementsByClassName("gw-open"), "gw-open");
        if (gwUtil_1.gwUtil.hasClass(parent, "gw-isTopLevelMenu")) {
            this.topLevelGroupMenuOpen = "";
        }
        var currentFocus = gwFocus_1.gwFocus.getCurrentFocus();
        if (!currentFocus) {
            this.storedMenuToOpenAfterClosingOthers.restoreFocusSelector = null;
            return;
        }
        if (!this.storedMenuToOpenAfterClosingOthers.restoreFocusSelector) {
            this.storedMenuToOpenAfterClosingOthers.restoreFocusSelector
                = gwUtil_1.gwUtil.getUniqueSelector(currentFocus);
        }
        //If the parent's subMenu has direct action--outers that are focused, or the inners or expands
        // inside of those action--outers are focused, then move focus up
        var subMenu = document.querySelector("#" + parent.id + " > .gw-subMenu");
        if (!subMenu) {
            return;
        }
        var focusParent = gwUtil_1.gwUtil.hasAnyClass(currentFocus, ["gw-action--inner", "gw-action--expand-button"])
            ? currentFocus.parentElement : null;
        gwUtil_1.gwUtil.forEach(subMenu.children, function (itrEl) {
            if (itrEl.id === currentFocus.id || (focusParent != null && itrEl.id === focusParent.id)) {
                if (_this.storedMenuToOpenAfterClosingOthers.id !== itrEl.id) {
                    gwNavigation_1.gwNavigation.setFocusToClosestFocusableSelfOrParent(currentFocus);
                }
                return gwTypes_1.GW_BREAKER;
            }
            return;
        });
    };
    /**
     * @public
     * Takes the first result of getDomNodes. And then runs getSelfOrFirstParentActionto find a gw-action--outer element.
     * Chooses between openSubMenu and closeSubMenu based on the presence of the gw-open class on the
     * first child found with gw-subMenu class
     * @param classIdTagOrNode
     */
    GwMenus.prototype.toggleSubMenu = function (classIdTagOrNode, eventType) {
        var parent = this.getSelfOrFirstParentActionOptionallyWithChildren(gwUtil_1.gwUtil.getDomNode(classIdTagOrNode), true);
        if (!parent) {
            return;
        }
        var subMenu = parent.querySelector(".gw-subMenu");
        if (!subMenu) {
            return;
        }
        if (gwUtil_1.gwUtil.hasClass(subMenu, "gw-open")) {
            if (gwEvents_1.gwEvents.isCurrentlyInTouchEvent()) {
                // If currently in a touch event, then the mouse click is going to close all menus, so we need to restore to the grandparent menu if there is one...long story
                var grandparent = this.getSelfOrFirstParentActionOptionallyWithChildren(parent.parentElement, true);
                if (grandparent) {
                    this.storedMenuToOpenAfterClosingOthers = { id: grandparent.id, el: grandparent };
                }
            }
            this.closeSubMenu(parent);
        }
        else {
            this.fetchMenuIfNeeded(parent);
            this.openSubMenu(parent, eventType);
        }
    };
    GwMenus.prototype.toggleFromShortcut = function (na, args) {
        exports.gwMenus.toggleSubMenu(args.target, "key");
        gwFocus_1.gwFocus.forceFocus(args.target);
    };
    /**
     * @private
     * Fetches the subMenu for the given on-demand MenuItem if needed
     * @param outer
     */
    GwMenus.prototype.fetchMenuIfNeeded = function (outer) {
        var _this = this;
        if (gwUtil_1.gwUtil.hasValue(outer.dataset.gwSubmenuOndemand)) {
            var deferredMenuItem = $(outer).find(".gw-deferred-menuItem");
            if (deferredMenuItem && deferredMenuItem.length > 0) {
                if (this.isSubMenusBelow(outer)) {
                    deferredMenuItem[0].style.width = outer.offsetWidth + "px";
                }
                else {
                    // Renders to the side, match the height of the parent menu
                    deferredMenuItem[0].style.height = outer.offsetHeight + "px";
                }
            }
            delete outer.dataset.gwSubmenuOndemand;
            gwUtil_1.gwUtil.renderDeferredChildren(outer.id, function () {
                // Success; open the menu again to ensure that the menu placement is correctly calculated
                _this.openSubMenu(outer);
            }, function () {
                // Error; restore submenu on demand flag so we can try again later, let menu system know no menus open
                outer.dataset.gwSubmenuOndemand = "true";
                _this.closeAllMenus();
            });
        }
    };
    /**
     * @public
     * This returns a fully formed div with identical structure to the MenuItemWidgets built out by the server, which are then
     * customized by the inline events system. Its purpose is to add client side menu options that the server should not know
     * anything about, like "change to theme x" or "clear local storage".
     * Keep in mind, that any element added to the dom client side, will need to be readded on full and partial page reload.
     *
     * @param id: String: inline id attribute
     * @param label: String: text for the MenuItem label
     * @param click: String: Optional, the string normally values to data-gw-click in server templates. ie 'fireEvent' or 'gwUtil.toggleClass target:#blah'.
     * @param children: Array of Objects: Optional. {id:String, label:String, click:String, children:Array of Objects};
     * @returns {DOMElement, identical to MenuItemWidget}
     */
    GwMenus.prototype.createMenuItemDiv = function (id, label, click, children) {
        var menuItemClasses = ["gw-MenuItemWidget", "gw-action--outer"];
        var menuItemAttr = { id: id };
        if (children && children.length) {
            menuItemClasses.push("gw-hasChildren");
            menuItemAttr["data-gw-menu-hover"] = "true";
            menuItemAttr["data-gw-mouseenter"] = "gwMenus.openSubMenuMouseEnter";
        }
        var menuItem = gwUtil_1.gwUtil.createDiv(menuItemClasses, menuItemAttr);
        var actionInnerAttr = {};
        if (click) {
            actionInnerAttr["data-gw-click"] = click;
            actionInnerAttr["onclick"] = "gw.globals.gwEvents.onElementEvent(event, this)";
            actionInnerAttr["tabindex"] = "0";
        }
        var actionInner = gwUtil_1.gwUtil.createDiv("gw-action--inner", actionInnerAttr);
        menuItem.appendChild(actionInner);
        actionInner.appendChild(gwUtil_1.gwUtil.createDiv("gw-icon"));
        actionInner.appendChild(gwUtil_1.gwUtil.createDiv("gw-label", undefined, undefined, label));
        if (children && children.length) {
            var expandDivAttr = {
                "data-gw-click": "toggleSubMenu target:#" + id,
                onclick: "gw.globals.gwEvents.onElementEvent(event, this)",
                tabindex: "0"
            };
            var expandDiv = gwUtil_1.gwUtil.createDiv("gw-action--expand-button", expandDivAttr);
            menuItem.appendChild(expandDiv);
            expandDiv.appendChild(gwUtil_1.gwUtil.createDiv(["gw-icon", "gw-icon--expand"]));
            var subMenu_1 = gwUtil_1.gwUtil.createDiv("gw-subMenu", undefined, {
                right: "100%",
                left: "auto",
                top: "0px",
                bottom: "auto"
            });
            menuItem.appendChild(subMenu_1);
            gwUtil_1.gwUtil.forEach(children, function (props) {
                subMenu_1.appendChild(exports.gwMenus.createMenuItemDiv(props.id, props.label, props.click, props.children));
            });
        }
        return menuItem;
    };
    /**
     * @private
     * Helper method to determine whether a menu item node is in a submenu.
     * @param outer - a Menu Item node with the gw-action--outer css class.
     * @returns {boolean}
     */
    GwMenus.prototype.isInSubMenu = function (outer) {
        return (!!outer.parentElement && gwUtil_1.gwUtil.hasClass(outer.parentElement, "gw-subMenu"));
    };
    GwMenus.prototype.isInStaticMenus = function (outer) {
        return gwUtil_1.gwUtil.hasClass(outer, "gw-staticMenus");
    };
    /**
     * @private
     * Helper method to return the gw-action--outer node by passing one of the focusable children to it,
     * currently expected to be the gw-action--inner or the gw-action--expand-button.
     * @param node
     * @returns {DOM Element}
     */
    GwMenus.prototype.getOuterFromInnerOrExpand = function (node) {
        return $(node).parents(".gw-action--outer")[0];
    };
    /**
     * @private
     * Helper method to return the gw-action--outer that is holding the submenu..that is holding the focusable node.
     * It does this simply by making 2 calls to getouterFromInnerOrExpand.
     * @param node - a DOM node, expected to be the gw-action--inner, or gw-action--expand-button.
     * @returns {DOM Element}
     */
    GwMenus.prototype.getParentOuterFromInnerOrExpand = function (node) {
        return this.getOuterFromInnerOrExpand(this.getOuterFromInnerOrExpand(node));
    };
    /**
     * @private
     * Method should only be executed by the gwNavigation system, when a matching navigation method is found.
     * Follows logic to determine whether a MenuItem is in a submMenu, or is a top item.
     * if in submenu: then it moves focus down to the next MenuItem. If at the bottom, then does nothing
     * if is top item: like in a tab bar: then it opens the top item's sub menu, and sets focus to the first MenuItem
     * @param node
     */
    GwMenus.prototype.down = function (node) {
        if (!node) {
            return;
        }
        var outer = this.getOuterFromInnerOrExpand(node);
        var inSubMenu = this.isInSubMenu(outer);
        var inStaticMenu = this.isInStaticMenus(outer);
        var isTopMenu = !inSubMenu && !inStaticMenu;
        // This could be a tabBar type menu item widget, where we want down to open its submenu
        if (gwUtil_1.gwUtil.hasClass(outer, "gw-hasChildren")) {
            if (isTopMenu) {
                this.openSubMenu(outer);
                gwFocus_1.gwFocus.forceFocus(outer.querySelector(".gw-subMenu"));
                return;
            }
        }
        if (inSubMenu || inStaticMenu) {
            var outerSibling = gwNavigation_1.gwNavigation.getNextFocusableSibling(outer);
            if (outerSibling) {
                gwFocus_1.gwFocus.forceFocus(outerSibling);
                return;
            }
        }
        if (inStaticMenu) {
            // See if the parent has a sibling to move down to.
            var parent_1 = this.getParentOuterFromInnerOrExpand(node);
            if (parent_1) {
                var parentNext = gwNavigation_1.gwNavigation.getNextFocusableSibling(parent_1);
                if (parentNext) {
                    gwFocus_1.gwFocus.forceFocus(parentNext);
                }
            }
        }
    };
    /**
     * @private
     * Method should only be executed by the gwNavigation system, when a matching navigation method is found.
     * Follows logic to determine whether a MenuItem is in a submMenu, or is a top item.
     * if in submenu: then it moves the focus up to the previous Menu Item. If it's at the top of the submenu,
     * then it closes the sub menu and puts focus on the gw-action--outer that held the subMenu.
     * if is top item: like in a tab bar: then it's a noop.
     * @param node
     */
    GwMenus.prototype.up = function (node) {
        var outer = this.getOuterFromInnerOrExpand(node);
        var inSubMenu = this.isInSubMenu(outer);
        var inStaticMenu = this.isInStaticMenus(outer);
        if (gwUtil_1.gwUtil.hasClass(outer, "gw-hasChildren")) {
            this.closeSubMenu(outer);
        }
        if (inSubMenu || inStaticMenu) {
            var outerSibling = gwNavigation_1.gwNavigation.getPrevFocusableSibling(outer);
            if (outerSibling) {
                gwFocus_1.gwFocus.forceFocus(outerSibling);
                return;
            }
        }
        if (inSubMenu) {
            var parent_2 = this.getParentOuterFromInnerOrExpand(node);
            if (parent_2) {
                this.closeSubMenu(parent_2);
                gwFocus_1.gwFocus.forceFocus(parent_2);
            }
        }
    };
    /**
     * @private
     * Method should only be executed by the gwNavigation system, when a matching navigation method is found.
     * Follows logic to determine whether a MenuItem is in a submMenu, or is a top item.
     * if in submenu: then it opens the MenuItem's subMenu and sets focus to the first element. If there is no subMenu, then noop.
     * if is top item: like in a tab bar: then it moves focus to the next MenuItem sibling in the tab bar.
     * @param node
     */
    GwMenus.prototype.right = function (node) {
        var outer = this.getOuterFromInnerOrExpand(node);
        if (!this.isInSubMenu(outer) && !this.isInStaticMenus(outer)) {
            gwFocus_1.gwFocus.forceFocus(gwNavigation_1.gwNavigation.getNextFocusableSibling(outer));
            this.closeSubMenu(outer);
            return;
        }
        if (gwUtil_1.gwUtil.hasClass(outer, "gw-hasChildren")) {
            //NOTE: this will feel weird if the subMenu has been anchored opposite side due to otherwise being positioned off screen.
            // But there just isn't a clean intuitive way to inform the user that the left and right arrow functionality has swapped,
            // So I'm not changing key functionality based on anchor position.
            this.openSubMenu(outer);
            gwFocus_1.gwFocus.forceFocus(outer.querySelector(".gw-subMenu"));
        }
    };
    /**
     * @private
     * Method should only be executed by the gwNavigation system, when a matching navigation method is found.
     * Follows logic to determine whether a MenuItem is in a submMenu, or is a top item.
     * if in submenu: then it closes the subMenu and puts focus onto the gw-action--outer that held the subMenu.
     * if is top item: like in a tab bar: then it moves focus to the previous MenuItem sibling in the tab bar.
     * @param node
     */
    GwMenus.prototype.left = function (node) {
        var outer = this.getOuterFromInnerOrExpand(node);
        var inSubMenu = this.isInSubMenu(outer);
        var inStaticMenu = this.isInStaticMenus(outer);
        if (!inSubMenu && !inStaticMenu) {
            gwFocus_1.gwFocus.forceFocus(gwNavigation_1.gwNavigation.getPrevFocusableSibling(outer));
            this.closeSubMenu(outer);
            return;
        }
        this.closeSubMenu(outer);
        var parent = this.getParentOuterFromInnerOrExpand(node);
        if (parent) {
            this.closeSubMenu(parent);
            gwFocus_1.gwFocus.forceFocus(parent);
        }
    };
    return GwMenus;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwMenus = GwMenus;
exports.gwMenus = new GwMenus();


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwStorage_1 = __webpack_require__(24);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var gwPrefPanel_1 = __webpack_require__(28);
var gwMessages_1 = __webpack_require__(224);
/**
 * System to store and restore scroll position on Dom elements between server round-trips;
 * Before each server event it stores off any divs that have a scroll position other than 0 into local storage
 * and then on page refresh, uses events.js doCustomSystemWorkOnEveryNodeOnPageLoad to restore scroll position.
 * @type {{}}
 */
var GwScroll = /** @class */ (function (_super) {
    __extends(GwScroll, _super);
    function GwScroll() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.LOC_OBJECT_CLASS = ".gw-location-name";
        _this.DEST_HASH_ATTR = "data-gw-dest-hash";
        _this.SCREEN_WIDGET_CLASS = ".gw-ScreenWidget";
        _this.scrollKey = "scroll";
        return _this;
    }
    GwScroll.prototype.getSystemName = function () {
        return "gwScroll";
    };
    // NOTE: resizer.js onResize calls clearStoredScrollPositions
    GwScroll.prototype.orderSpecificInit = function (isFullPageReload, partialReloadDetails) {
        if (isFullPageReload) {
            this.clearStoredScrollPositions();
        }
        // The restore logic lives in the doCustomSystemWorkOnPageLoad in events.js
    };
    GwScroll.prototype.setScreenScrollTo0 = function (node) {
        var screen = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(node, this.SCREEN_WIDGET_CLASS);
        if (!screen) {
            return;
        }
        this.scrollElTo0(screen);
    };
    GwScroll.prototype.scrollElTo0 = function (node) {
        if (node) {
            node.scrollTop = 0;
            node.scrollLeft = 0;
            var key = this.getStorageKeyForNode(node);
            if (key) {
                this.setTopAndLeftInStorage(key);
            }
        }
    };
    GwScroll.prototype.getLocationObject = function () {
        return gwUtil_1.gwUtil.getDomNode(this.LOC_OBJECT_CLASS);
    };
    GwScroll.prototype.getDestinationHash = function () {
        var locObject = this.getLocationObject();
        if (!locObject) {
            return null;
        }
        return locObject.getAttribute(this.DEST_HASH_ATTR);
    };
    GwScroll.prototype.getStorageKeyForNode = function (node) {
        var nodeId = node.id;
        if (!nodeId) {
            return null;
        }
        var destHash = this.getDestinationHash();
        if (!destHash) {
            return null;
        }
        return this.scrollKey + "." + destHash + "." + nodeId;
    };
    /**
     * If a node has an id and either a scrollTop or a scrollLeft greater than 0, then store it in local storage
     * @param node
     */
    GwScroll.prototype.storeScrollForNode = function (node) {
        var keyId = this.getStorageKeyForNode(node);
        if (!keyId) {
            return;
        }
        var top = node.scrollTop || 0;
        var left = node.scrollLeft || 0;
        // If either top or left is greater than 0, then store the scroll positions.
        // Or if there's already a value stored, then this might be scrolling back to 0,0
        if (top + left > 0 || gwStorage_1.gwStorage.get(keyId)) {
            this.setTopAndLeftInStorage(keyId, top, left);
        }
    };
    GwScroll.prototype.setTopAndLeftInStorage = function (keyId, top, left) {
        top = top || 0;
        left = left || 0;
        gwStorage_1.gwStorage.set(keyId, { top: top, left: left });
    };
    /**
     * If a node has an id, and that id has an object stored in the scroll local storage,
     * then set the scrollTop and scrollLeft values of that node.
     * Called per node in events.js doCustomSystemWorkOnEveryNodeOnPageLoad
     * @param node
     */
    GwScroll.prototype.restoreScrollForNode = function (node) {
        var keyId = this.getStorageKeyForNode(node);
        if (!keyId) {
            return;
        }
        // If the scrollable node contains an error element, then don't restore scroll, and scroll to 0 instead
        if (node.querySelector(".gw-alert-error")) {
            if (gwPrefPanel_1.gwPrefPanel.getPrefValueById("scrollToTopOnError") && !gwMessages_1.gwMessages.willFocusElementOnNextPageLoad()) {
                this.scrollElTo0(node);
                return;
            }
        }
        var scrollStorage = gwStorage_1.gwStorage.get(keyId);
        if (scrollStorage) {
            node.scrollTop = scrollStorage.top;
            node.scrollLeft = scrollStorage.left;
        }
    };
    /**
     * sets the local storage for 'scroll' to an empty object.
     * Currently called by resizer.js onResize
     */
    GwScroll.prototype.clearStoredScrollPositions = function () {
        gwStorage_1.gwStorage.set(this.scrollKey, {});
    };
    /**
     * This is a relatively brute force implementation, as it just goes and gets every single div,
     * but it's simple and clean. Once day we may choose to have a "walkAllDomNodesBeforeServerEvent" method
     * and if we do that, this would become part of it.
     * @returns {*|jQuery|HTMLElement}
     */
    GwScroll.prototype.getScrollNodesInDom = function () {
        return gwUtil_1.gwUtil.getDomNodes("div");
    };
    /**
     * Calls storeScrollForNode on the results of getScrollNodesInDom
     * Currently called by beforeFireServerEvent in app.js
     */
    GwScroll.prototype.saveScrollPositions = function () {
        var nodes = this.getScrollNodesInDom();
        gwUtil_1.gwUtil.forEach(nodes, this.storeScrollForNode.bind(this));
    };
    return GwScroll;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwScroll = GwScroll;
exports.gwScroll = new GwScroll();


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwPreferences_1 = __webpack_require__(62);
var gwMenus_1 = __webpack_require__(26);
var gwForm_1 = __webpack_require__(25);
var gwDisplayKey_1 = __webpack_require__(16);
var gwInputs_1 = __webpack_require__(5);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var plApp_1 = __webpack_require__(29);
var gwResizer_1 = __webpack_require__(35);
var gwConfig_1 = __webpack_require__(80);
var gwEvents_1 = __webpack_require__(3);
var GwPrefPanel = /** @class */ (function (_super) {
    __extends(GwPrefPanel, _super);
    function GwPrefPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // ========== Init ===================
        /** Id of the preferences panel in the DOM */
        _this.PREF_PANEL_ID = "gw-PrefPanel";
        /** Key under which to store the pref panel values in the preferences system */
        _this.PREFERENCES_KEY = "gw-PrefPanel";
        /** Ids of any preference inputs whose values don't match the values in the preferences system */
        _this.dirtyPrefs = {};
        /** Timeout in milliseconds, longest time we're prepared to wait for a new theme file to load */
        _this.MAX_WAIT_FOR_THEME = 3000;
        return _this;
    }
    GwPrefPanel.prototype.getSystemName = function () {
        return "gwPrefPanel";
    };
    // ========== initializer methods ===================
    /**
     * @param isFullPageRefresh
     */
    GwPrefPanel.prototype.orderSpecificInit = function (isFullPageRefresh) {
        this.preferencesLoaded();
    };
    /**
     * should only be called by app.js
     * If the html.id matches the current theme preference then do nothing, and return false
     * Otherwise, build a link to the needed css file, insert it in the head
     * Return true, to inform the caller that the onload method will handle the page reload.
     * Then on load of the missing css file, change the html.id to the correct theme
     * and call gw.app.fireAfterPartialPageReload
     * @returns {boolean}
     */
    GwPrefPanel.prototype.checkAndHandleIfTopLevelWidgetIsOutOfDate = function () {
        var currentTheme = this.getPrefValueById("theme");
        var htmlEl = document.documentElement;
        if (htmlEl.id === currentTheme) {
            return false;
        }
        // If we never find the theme file, or it's taking too long, then just enable the app early
        var failsafe = setTimeout(function () {
            plApp_1.gwApp.fireAfterPartialPageReload({ reason: plApp_1.GwPartialReloadReason.THEME_CHANGE });
        }, this.MAX_WAIT_FOR_THEME);
        // Otherwise, the theme on the top level widget renderer is out of date
        var themeCssFile = document.createElement("link");
        themeCssFile.rel = "stylesheet";
        themeCssFile.type = "text/css";
        themeCssFile.href = "css/gen/" + currentTheme + ".css";
        themeCssFile.onload = function () {
            window.clearTimeout(failsafe);
            document.documentElement.id = "" + currentTheme; //This changes the theme over. We specifically don't want a stand alone method to do this, as in every other case, this is handled on the server.
            plApp_1.gwApp.fireAfterPartialPageReload({ reason: plApp_1.GwPartialReloadReason.THEME_CHANGE });
            gwUtil_1.gwUtil.fireCustomEvent("themeChange", { themeId: currentTheme });
        };
        document.getElementsByTagName("head")[0].appendChild(themeCssFile);
        return true;
    };
    /**
     * Updates one-off preferences not handled directly by other systems
     */
    GwPrefPanel.prototype.preferencesLoaded = function () {
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("disableFocusOutline"), "#gw-body", ".gw-disableFocusOutline");
        this.setDebugPrefs();
        this.setFontSize(this.getPrefValueById("fontSize"));
        this.setGlobalSpacing(this.getPrefValueById("globalSpacingModifier"));
        this.setAlternateActionsIcon(gwUtil_1.gwUtil.convertIfString(this.getPrefValueById("alternateActionsIcon")));
        this.setDatePrefs();
        this.setGeneralPrefs();
        this.setToolbarPrefs();
    };
    // ========== public methods ===================
    /**
     * Helper method so other systems can read data from the preferences system with only an id.
     * Handles all conversion of values, and also uses default values from the config system if
     * no preferences are found.
     * @param id
     * @returns {*}
     */
    GwPrefPanel.prototype.getPrefValueById = function (id) {
        var val = gwPreferences_1.gwPreferences.getPreference(this.PREFERENCES_KEY, id);
        if (gwUtil_1.gwUtil.hasValue(val)) {
            return gwUtil_1.gwUtil.convertIfString(val);
        }
        //Otherwise, get the default that came down with the configuration
        return gwUtil_1.gwUtil.convertIfString(this.getDefaultValueFromConfig(id));
    };
    /**
     * Opens the preferences panel, closes all open menus, and sets the UI state.
     */
    GwPrefPanel.prototype.open = function () {
        gwMenus_1.gwMenus.closeAllMenus();
        gwUtil_1.gwUtil.showOnDemandElement(this.PREF_PANEL_ID);
    };
    /**
     * Returns true if the preferences panel has any unsaved data.
     * @returns {boolean}
     */
    GwPrefPanel.prototype.isDirty = function () {
        return (Object.keys(this.dirtyPrefs).length > 0);
    };
    /**
     * Saves all settings. If there was dirty data, then calls refresh, if not, then just closes the
     */
    GwPrefPanel.prototype.save = function () {
        if (!this.getConfirmForDirtyFormData()) {
            return;
        }
        if (this.isDirty()) {
            this.internalSave();
            this.close();
            this.refresh();
        }
        else {
            this.close();
        }
    };
    /**
     * If there is dirty data, then reverts any changes made in the UI to whatever is stored in the preferences system.
     * Closes
     */
    GwPrefPanel.prototype.cancel = function () {
        this.resetAllModifiedPrefs();
        this.close();
    };
    /**
     * Reverts all values to original defaults
     */
    GwPrefPanel.prototype.reset = function () {
        var changes = this.getChangesRequiredToRestoreDefaults();
        if (Object.keys(changes).length === 0 || !window.confirm(gwDisplayKey_1.gwDisplayKey.get("Web.Client.PrefPanelConfirmReset"))) {
            return;
        }
        this.applyChangesToUi(changes);
    };
    GwPrefPanel.prototype.getChangesRequiredToRestoreDefaults = function () {
        var _this = this;
        var changes = {};
        var defaults = gwConfig_1.gwConfig.prefPanelDefaults();
        gwUtil_1.gwUtil.forEach(this.getAllPrefEls(), function (el) {
            var input = el;
            var currentValue = _this.getValueFromEl(input);
            var defaultValue = defaults[input.name] || (_this.isBooleanPref(input) ? false : "");
            if (currentValue !== defaultValue) {
                changes[_this.getIdFromEl(input)] = defaultValue;
            }
        });
        return changes;
    };
    GwPrefPanel.prototype.applyChangesToUi = function (changes) {
        var _this = this;
        gwUtil_1.gwUtil.forEach(changes, function (value, key) {
            var input = gwUtil_1.gwUtil.getDomNodeByName(key);
            if (_this.isBooleanPref(input)) {
                gwInputs_1.gwInputs.setCheckedOnInput(input, value);
            }
            else {
                gwUtil_1.gwUtil.setOptionOnSelect(input, value);
            }
            _this.change(input);
        });
    };
    /**
     * Called by data-gw-change handler. Compare the new value to the original value of the input to determine if
     * the data is dirty.
     * @param el
     */
    GwPrefPanel.prototype.change = function (el) {
        var wasDirty = this.isDirty();
        if (this.uiValueDiffersFromLast(el)) {
            this.dirtyPrefs[this.getIdFromEl(el)] = true;
        }
        else {
            delete this.dirtyPrefs[this.getIdFromEl(el)];
        }
        if (wasDirty !== this.isDirty()) {
            gwEvents_1.gwEvents.possiblyAddOnBeforeUnloadHandler();
        }
    };
    // ============= private button helper methods ========
    GwPrefPanel.prototype.getConfirmForDirtyFormData = function () {
        if (gwForm_1.gwForm.isDirty()) {
            return window.confirm(gwDisplayKey_1.gwDisplayKey.get("Web.Client.ConfirmPrefPanelWithDirtyForm"));
        }
        return true;
    };
    GwPrefPanel.prototype.resetAllModifiedPrefs = function () {
        if (this.isDirty()) {
            if (window.confirm(gwDisplayKey_1.gwDisplayKey.get("Web.Client.PrefPanelConfirmCancel"))) {
                gwUtil_1.gwUtil.forEach(this.getAllPrefEls(), this.cancelPrefValue.bind(this));
            }
        }
    };
    GwPrefPanel.prototype.internalSave = function () {
        var _this = this;
        gwUtil_1.gwUtil.forEach(this.dirtyPrefs, function (val, name) {
            var node = gwUtil_1.gwUtil.getDomNodeByName(name);
            if (node) {
                _this.saveUiValueToPreferences(node);
            }
        });
    };
    GwPrefPanel.prototype.close = function () {
        gwUtil_1.gwUtil.hideOnDemandElement(this.PREF_PANEL_ID);
        this.clearDirtyPrefs();
    };
    GwPrefPanel.prototype.refresh = function () {
        gwResizer_1.gwResizer.forceRecalcOnNextPartialPageLoad();
        gwUtil_1.gwUtil.refresh();
    };
    // ============= private methods
    /**
     * Helper method to save the value of a UI element to the preferences system
     * @param el preferences panel UI element
     */
    GwPrefPanel.prototype.saveUiValueToPreferences = function (el) {
        gwPreferences_1.gwPreferences.storePreference(this.PREFERENCES_KEY, this.getIdFromEl(el), this.getValueFromEl(el), this.PREFERENCES_KEY);
    };
    /**
     * @param true if use alternate icon for the MenuActionsWidget
     */
    GwPrefPanel.prototype.setAlternateActionsIcon = function (bool) {
        gwUtil_1.gwUtil.conditionalAddRemoveClass(bool, ".gw-MenuActionsWidget", ".gw-alternate-actions-icon");
    };
    GwPrefPanel.prototype.setToolbarPrefs = function () {
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("leftAlignTopToolbar"), "#gw-center-title-toolbar", ".gw-top-toolbar-left");
    };
    GwPrefPanel.prototype.setDatePrefs = function () {
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("smallDatePicker"), "#gw-body", ".gw-small-date-picker");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("complexDatePicker"), "#gw-body", ".gw-complex-date-picker");
    };
    GwPrefPanel.prototype.setDebugPrefs = function () {
        plApp_1.gwApp.shouldFlash = this.getPrefValueById("showDrawFlash");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("showWidgetTypesAsInlineTitles"), "#gw-root-form", "gw-debug-show-widget-types-as-inline-titles");
    };
    GwPrefPanel.prototype.setFontSize = function (fontSize) {
        if (gwUtil_1.gwUtil.hasValue(fontSize) && fontSize !== "default") {
            document.body.style.fontSize = fontSize + "px";
        }
        else {
            document.body.style.fontSize = null;
        }
    };
    GwPrefPanel.prototype.setGlobalSpacing = function (globalSpacingModifier) {
        if (gwUtil_1.gwUtil.hasValue(globalSpacingModifier) && globalSpacingModifier !== "default") {
            var fontSizeInPx = window.getComputedStyle(document.body, undefined).getPropertyValue("font-size");
            var fontSize = parseFloat(fontSizeInPx);
            document.documentElement.style.fontSize = parseFloat(globalSpacingModifier) * fontSize + "px";
        }
        else {
            document.documentElement.style.fontSize = null;
        }
    };
    GwPrefPanel.prototype.setGeneralPrefs = function () {
        gwUtil_1.gwUtil.conditionalAddRemoveAttr(this.getPrefValueById("disableBrowserAutocomplete"), "#gw-root-form", "autocomplete", "off");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.getPrefValueById("highlightDirtyData"), "#gw-root-form", "gw-highlight-changed-data");
    };
    GwPrefPanel.prototype.clearDirtyPrefs = function () {
        this.dirtyPrefs = {};
    };
    GwPrefPanel.prototype.uiValueDiffersFromLast = function (el) {
        return gwForm_1.gwForm.testIfInputHasChangedValue(el);
    };
    GwPrefPanel.prototype.getValueFromPreferences = function (el) {
        return this.getPrefValueById(this.getIdFromEl(el));
    };
    GwPrefPanel.prototype.getValueFromEl = function (el) {
        if (this.isBooleanPref(el)) {
            return gwUtil_1.gwUtil.convertIfString(el.checked);
        }
        return gwUtil_1.gwUtil.convertIfString(el.value);
    };
    GwPrefPanel.prototype.getDefaultValueFromConfig = function (id) {
        return gwConfig_1.gwConfig.prefPanelDefaults()[id];
    };
    GwPrefPanel.prototype.getIdFromEl = function (el) {
        return el.id || el.name;
    };
    GwPrefPanel.prototype.getAllPrefEls = function () {
        return gwUtil_1.gwUtil.getDomNodes(".gw-Pref--val");
    };
    /**
     * Used to differentiate between boolean preferences and list preferences, which store their values differently.
     * @param el
     * @returns {boolean}
     */
    GwPrefPanel.prototype.isBooleanPref = function (el) {
        return gwUtil_1.gwUtil.hasClass(el, "gw-Pref--boolean");
    };
    /**
     * Reverts all ui preferences to the corresponding values taken from the preferences system
     * @param el
     */
    GwPrefPanel.prototype.cancelPrefValue = function (el) {
        if (this.isBooleanPref(el)) {
            gwInputs_1.gwInputs.setCheckedOnInput(el, this.getValueFromPreferences(el));
        }
        else {
            gwUtil_1.gwUtil.setOptionOnSelect(el, this.getValueFromPreferences(el));
        }
    };
    return GwPrefPanel;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwPrefPanel = GwPrefPanel;
exports.gwPrefPanel = new GwPrefPanel();


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(236);
window.$ = $;
var d3 = __webpack_require__(237);
window.d3 = d3;
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwPrefPanel_1 = __webpack_require__(28);
var gwPerfAnalyzer_1 = __webpack_require__(60);
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var gwDisplayKey_1 = __webpack_require__(16);
var gwLocale_1 = __webpack_require__(58);
var gwConfig_1 = __webpack_require__(80);
var gwStorage_1 = __webpack_require__(24);
var gwPreferences_1 = __webpack_require__(62);
var gwServerEvents_1 = __webpack_require__(217);
var gwOps_1 = __webpack_require__(218);
var gw_1 = __webpack_require__(10);
var gwResizer_1 = __webpack_require__(35);
var gwFocus_1 = __webpack_require__(8);
var gwPageLoadBar_1 = __webpack_require__(128);
var gwMenus_1 = __webpack_require__(26);
var gwInputs_1 = __webpack_require__(5);
var gwScroll_1 = __webpack_require__(27);
var gwReflection_1 = __webpack_require__(54);
var gwSumReflection_1 = __webpack_require__(223);
var gwAjax_1 = __webpack_require__(15);
var GwPartialReloadReason;
(function (GwPartialReloadReason) {
    GwPartialReloadReason[GwPartialReloadReason["REPLACE_ITEMS"] = 0] = "REPLACE_ITEMS";
    GwPartialReloadReason[GwPartialReloadReason["REPLACE_BODY"] = 1] = "REPLACE_BODY";
    GwPartialReloadReason[GwPartialReloadReason["THEME_CHANGE"] = 2] = "THEME_CHANGE";
    GwPartialReloadReason[GwPartialReloadReason["ERROR"] = 3] = "ERROR";
})(GwPartialReloadReason = exports.GwPartialReloadReason || (exports.GwPartialReloadReason = {}));
var GwApp = /** @class */ (function (_super) {
    __extends(GwApp, _super);
    function GwApp() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.maxElementsToReplacePerFrame = 1000;
        _this.shouldFlash = false;
        _this.showDevLogs = false;
        _this.showEventLogs = false;
        _this.showEventTrace = false;
        _this.minScreenWidth = 640;
        _this.minScreenHeight = 480;
        _this.newSession = false;
        _this.enableWebsocket = false;
        _this.isNavigating = false;
        return _this;
    }
    GwApp.prototype.getSystemName = function () {
        return "gwApp";
    };
    GwApp.prototype.fireAfterFullPageReload = function () {
        this.abstractReload(true, {});
        this.registerAjaxForm();
    };
    GwApp.prototype.fireAfterPartialPageReload = function (details) {
        // When the method returns true, the panel will add any missing preferences needed,
        // and when the theme file is finished loading, will fire partial page reload
        if (details.reason !== GwPartialReloadReason.THEME_CHANGE && gwPrefPanel_1.gwPrefPanel.checkAndHandleIfTopLevelWidgetIsOutOfDate()) {
            return;
        }
        this.abstractReload(false, details);
        gwPerfAnalyzer_1.gwPerfAnalyzer.responseProcessed();
    };
    GwApp.prototype.fireAfterGwBodyReplace = function () {
        this.hideBody();
        this.fireAfterPartialPageReload({ reason: GwPartialReloadReason.REPLACE_BODY });
    };
    GwApp.prototype.showBody = function () {
        var body = document.querySelector("body");
        if (!body) {
            throw new Error("Unable to find a body element");
        }
        body.style.visibility = "visible";
        body.style.opacity = "1";
    };
    GwApp.prototype.hideBody = function () {
        var body = document.querySelector("body");
        if (!body) {
            throw new Error("Unable to find a body element");
        }
        body.style.visibility = null;
        body.style.opacity = null;
    };
    GwApp.prototype.resetInitOnlyValues = function () {
        this.newSession = false;
    };
    GwApp.prototype._dev_showBodyAfterReloadChunk = function () {
        this.showBody();
    };
    GwApp.prototype.popupAboutWindow = function () {
        /* Window sizing matches hard coded values in Ferrite */
        var url = window.location.href + "?handlerName=about";
        var features = "width=620, height=330";
        return window.open(url, "gwAboutPopupWindow", features);
    };
    GwApp.prototype.openShortcutHelp = function () {
        gwUtil_1.gwUtil.showOnDemandElement("gw-ShortcutPopupHelp");
    };
    GwApp.prototype.closeShortcutHelp = function () {
        gwUtil_1.gwUtil.hideOnDemandElement("gw-ShortcutPopupHelp");
    };
    /**
     * Prepares the app for Nav, which cancels all remaining initialization. If navigating within the Cluster,
     * the onbeforeunload is cleared. Otherwise, we only stop initialization if there is no
     * onbeforeunload registered.
     */
    GwApp.prototype.prepareForExitPointNavigation = function (isClusterNav) {
        if (isClusterNav === void 0) { isClusterNav = false; }
        if (isClusterNav) {
            gwEvents_1.gwEvents.clearBeforeUnload();
            this.isNavigating = true;
        }
        else {
            gwEvents_1.gwEvents.possiblyAddOnBeforeUnloadHandler();
            if (!gwEvents_1.gwEvents.isBeforeUnloadRegistered()) {
                this.isNavigating = true;
            }
        }
    };
    GwApp.prototype.getPreInitializationOrderSpecificSystems = function () {
        return [
            gwDisplayKey_1.gwDisplayKey,
            gwLocale_1.gwLocale,
            gwConfig_1.gwConfig,
            gwStorage_1.gwStorage,
            gwPreferences_1.gwPreferences,
            gwPrefPanel_1.gwPrefPanel,
            gwServerEvents_1.gwServerEvents,
            gwOps_1.gwOps
        ];
    };
    GwApp.prototype.getPostInitializationOrderSpecificSystems = function () {
        return [
            gwEvents_1.gwEvents,
            gwResizer_1.gwResizer,
            gwScroll_1.gwScroll
        ];
    };
    /**
     * @private
     * method used by both fullPage and partialPage reload. Passes the isFullPageReload
     * parameter in to any init method it calls, so the system or widget can do different things
     * based on whether it's a full or partial page reload.
     * @param isFullPageReload
     * @param partialReloadDetails an object containing a reason field and, if the reason is REPLACE_ITEMS,
     *        and ids field containing the ids of the items that were replaced
     */
    GwApp.prototype.abstractReload = function (isFullPageReload, partialReloadDetails) {
        var preSystems = this.getPreInitializationOrderSpecificSystems();
        for (var initIndex = 0; initIndex < preSystems.length; initIndex++) {
            var systemObj = preSystems[initIndex];
            systemObj.orderSpecificInit(isFullPageReload, partialReloadDetails);
        }
        if (this.isNavigating) {
            //If an init method has begun navigating, cut short.
            this.isNavigating = false;
            return;
        }
        // =================
        gw_1.gw.initializeNonOrderSpecificSystems(isFullPageReload, partialReloadDetails);
        // =================
        var postSystems = this.getPostInitializationOrderSpecificSystems();
        for (var initIndex = 0; initIndex < postSystems.length; initIndex++) {
            var systemObj = postSystems[initIndex];
            systemObj.orderSpecificInit(isFullPageReload, partialReloadDetails);
        }
        // ----------------------------------------------------------
        this.showBody();
        gwFocus_1.gwFocus.restoreFocus(isFullPageReload);
        gwEvents_1.gwEvents.enableEvents();
        gwPageLoadBar_1.gwPageLoadBar.go(100);
        this.resetInitOnlyValues(); // Needs to be last
        gwUtil_1.gwUtil.runAfterPageLoad();
    };
    /**
     * Fires before every server event.
     * Eventually, if many systems begin using this, it should be converted into a
     * "walkAllDomNodesBeforeServerEvent" where each node is passed into the methods defined in it.
     */
    GwApp.prototype.beforeEachFireEventToServer = function () {
        gwMenus_1.gwMenus.closeAllMenus();
        gwPreferences_1.gwPreferences.beforeServerRequest();
        gwInputs_1.gwInputs.beforeFireEvent();
        gwScroll_1.gwScroll.saveScrollPositions();
        gwReflection_1.gwReflection.clearCache();
        gwSumReflection_1.gwSumReflection.clearValues();
    };
    GwApp.prototype.registerAjaxForm = function () {
        var _this = this;
        var bodyPattern = /^\s*<div.*id='gw-body'/;
        var handleResponse = function (data, request) {
            gwPerfAnalyzer_1.gwPerfAnalyzer.responseReceived();
            /**
             * We are replacing the entire body with a single string
             */
            if (typeof data === "string") {
                if (!!data.match(bodyPattern)) {
                    gwUtil_1.gwUtil.replaceTarget("#gw-body", data);
                    _this.fireAfterGwBodyReplace();
                    return;
                }
            }
            else {
                /**
                 * If there are response targets, then we are going to only replace individual elements
                 */
                if (data.targets) {
                    // If this is a partial page refresh, then we wrap the updater in a timeout, to let the renderer
                    // TODO: not sure if this timeout is worth the possible oddness
                    setTimeout(function () {
                        var length = data.targets.length;
                        if (length === 0) {
                            // Nothing has changed
                            gwUtil_1.gwUtil.devlog("Response.targets had a length of 0: ", data);
                            exports.gwApp.fireAfterPartialPageReload({ reason: GwPartialReloadReason.REPLACE_ITEMS, ids: [] });
                            return;
                        }
                        gwUtil_1.gwUtil.replaceTargets(0, 0, 40 / length, data.targets);
                    }, 0);
                }
                if (data.errorpage) {
                    gwUtil_1.gwUtil.replaceTarget("#gw-body", data.errorpage);
                    gwEvents_1.gwEvents.enableEvents();
                    gwEvents_1.gwEvents.clearEventQueue();
                }
                return;
            }
            exports.gwApp.fireAfterPartialPageReload({ reason: GwPartialReloadReason.ERROR });
            gwAjax_1.gwAjax.handleFailedRequest(request, data, 1 /* UNEXPECTED_RESPONSE */, "unexpected_response");
        };
        var options = {
            success: function (data, errorType, request) {
                gwPageLoadBar_1.gwPageLoadBar.go(60);
                handleResponse(data, request);
            },
            error: function (request, errorType, httpErrorString) {
                _this.fireAfterPartialPageReload({ reason: GwPartialReloadReason.ERROR });
                gwAjax_1.gwAjax.onRequestError(request, errorType, httpErrorString);
                gwEvents_1.gwEvents.clearEventQueue();
            }
        };
        // Make timeout a dynamic property that always consults the configuration
        Object.defineProperty(options, "timeout", {
            get: gwConfig_1.gwConfig.serverTimeoutMillis.bind(gwConfig_1.gwConfig),
            enumerable: true,
            configurable: true
        });
        //TODO: maybe gwAjax should set this up, as the default error handling lives there.
        $("#gw-root-form").ajaxForm(options);
    };
    return GwApp;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwApp = GwApp;
exports.gwApp = new GwApp();
/**
 * This function executes when the full page is finished loading.
 * All DOM elements and scripts will be available.
 */
if (!window.GwTestEnv) {
    $(function () { return exports.gwApp.fireAfterFullPageReload(); });
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dispatch__ = __webpack_require__(261);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dispatch__["a"]; });



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_path__ = __webpack_require__(351);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_path__["a"]; });



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ __webpack_exports__["a"] = (function(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
});


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return slice; });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function constant() {
    return x;
  };
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwTypes_1 = __webpack_require__(20);
var gwMenus_1 = __webpack_require__(26);
var gwInputs_1 = __webpack_require__(5);
var gwUtil_1 = __webpack_require__(0);
var gwScroll_1 = __webpack_require__(27);
var plApp_1 = __webpack_require__(29);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var gwSouthPanel_1 = __webpack_require__(131);
var gwWestPanel_1 = __webpack_require__(225);
var GwResizer = /** @class */ (function (_super) {
    __extends(GwResizer, _super);
    function GwResizer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.clearResizer = null;
        _this.currentHamburger = null;
        _this.currentHamburgerSubMenu = null;
        _this.currentTabHolder = null;
        _this._windowHeight = -1;
        _this._windowWidth = -1;
        _this._forceRecalcOnNextPartialPageLoad = false;
        _this._resizeCallbacks = [];
        return _this;
    }
    GwResizer.prototype.getSystemName = function () {
        return "gwResizer";
    };
    GwResizer.prototype.orderSpecificInit = function (isFullPageReload, partialReloadDetails) {
        if (isFullPageReload) {
            window.addEventListener("resize", this.onResize.bind(this));
        }
        if (isFullPageReload || this._forceRecalcOnNextPartialPageLoad || this.containsTabChanges(partialReloadDetails)) {
            this._forceRecalcOnNextPartialPageLoad = false;
            this.recalcPanelSizing(isFullPageReload);
        }
        else {
            // Ensure center panel is correctly sized in case there were south panel changes
            this.recalcCenterPanel();
        }
    };
    Object.defineProperty(GwResizer.prototype, "windowHeight", {
        get: function () {
            if (this._windowHeight === -1) {
                this.updateWindowHeightAndWidth();
            }
            return this._windowHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GwResizer.prototype, "windowWidth", {
        get: function () {
            if (this._windowWidth === -1) {
                this.updateWindowHeightAndWidth();
            }
            return this._windowWidth;
        },
        enumerable: true,
        configurable: true
    });
    GwResizer.prototype.updateWindowHeightAndWidth = function () {
        this._windowHeight = Math.max(plApp_1.gwApp.minScreenHeight, window.innerHeight);
        this._windowWidth = Math.max(plApp_1.gwApp.minScreenWidth, window.innerWidth);
    };
    GwResizer.prototype.forceRecalcOnNextPartialPageLoad = function () {
        this._forceRecalcOnNextPartialPageLoad = true;
    };
    /**
     * Called by resize event.
     */
    GwResizer.prototype.recalcPanelSizing = function (isFullPageReload) {
        if (isFullPageReload === void 0) { isFullPageReload = false; }
        this.clearResizer = null;
        this.updateWindowHeightAndWidth();
        if (!isFullPageReload) {
            gwMenus_1.gwMenus.closeAllMenus();
            gwInputs_1.gwInputs.closeOpenInputs();
        }
        gwWestPanel_1.gwWestPanel.restoreWestPanelWidth(false);
        this.recalcCenterPanel();
        this.recalcTabBarSizing();
    };
    /**
     * Needs to be called any time the screen size changes, or the south or west panel change their size.
     */
    GwResizer.prototype.recalcCenterPanel = function () {
        var centerTopSection = document.getElementById("gw-center-top-section");
        if (!centerTopSection) {
            return;
        }
        var northPanelH = document.getElementById("gw-north-panel").getBoundingClientRect().height || 0;
        var centerPanelTopSectionH = centerTopSection.getBoundingClientRect().height || 0;
        var southPanelH = gwSouthPanel_1.gwSouthPanel.ensureHeightFits(this.windowHeight - (northPanelH + centerPanelTopSectionH));
        document.getElementById("gw-west-center").style.height = this.windowHeight - (northPanelH + southPanelH) + "px";
        document.getElementById("gw-center-bottom-section").style.height = this.windowHeight - (northPanelH + southPanelH + centerPanelTopSectionH) + "px";
    };
    GwResizer.prototype.recalcTabBarSizing = function () {
        this.currentTabHolder = gwUtil_1.gwUtil.getDomNode(".gw-TabBarWidget--tab-holder");
        if (!this.currentTabHolder) {
            return;
        }
        var iconHolder = gwUtil_1.gwUtil.getDomNode(".gw-TabBarWidget--icon-holder");
        if (!iconHolder) {
            return;
        }
        this.currentHamburger = gwUtil_1.gwUtil.getDomNode("#TabBarWidget--more-options");
        if (!this.currentHamburger) {
            return;
        }
        gwUtil_1.gwUtil.removeClass(this.currentHamburger, "gw-invisible");
        this.currentHamburgerSubMenu = this.currentHamburger.querySelector(".gw-subMenu");
        if (!this.currentHamburgerSubMenu) {
            return;
        }
        // Add all the tabs back into the tab bar, then calculate which ones have to go into the hamburger menu
        this.addTabsBack();
        var quickjump = gwUtil_1.gwUtil.getDomNode(".gw-QuickjumpWidget"); //TODO: this is also a brittle connection
        var rightWidth;
        if (quickjump) {
            rightWidth = quickjump.offsetWidth;
        }
        else {
            rightWidth = 0;
        }
        var dropOffLineRight = this.windowWidth - (iconHolder.offsetWidth + rightWidth) * 1.05; //Magic number just to prevent rounding issues on resizing the screen slowly back and forth
        var children = this.currentTabHolder.children;
        var addThese = [];
        for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            if (!child) {
                continue;
            }
            // We have to check this, because widgets with display: none, report a right rect of 0;
            if (child.offsetWidth <= 0) {
                continue;
            }
            if (child.getBoundingClientRect().right >= dropOffLineRight) {
                addThese.push(child);
            }
        }
        for (var i = 0; i < addThese.length; i++) {
            var child = addThese[i];
            this.currentHamburgerSubMenu.insertBefore(child, this.currentHamburgerSubMenu.firstChild);
        }
        this.processTabsInBarAndHamburger();
    };
    /**
     * Walks the currentHamburgerSubMenu.children and removes all classes relating to being in the top nav bar.
     * If the subMenu has no children, then hides the hamburger menu.
     */
    GwResizer.prototype.processTabsInBarAndHamburger = function () {
        gwUtil_1.gwUtil.forEach(this.currentHamburgerSubMenu.children, function (child) {
            gwUtil_1.gwUtil.removeClass(child, ["gw-putSubMenusBelow", "gw-isTopLevelMenu"]);
        });
        gwUtil_1.gwUtil.forEach(this.currentTabHolder.children, function (child) {
            gwUtil_1.gwUtil.addClass(child, ["gw-putSubMenusBelow", "gw-isTopLevelMenu"]);
        });
        gwUtil_1.gwUtil.conditionalAddRemoveClass(!this.currentHamburgerSubMenu.children.length, this.currentHamburger, "gw-invisible");
    };
    /**
     * Adds all tabs back into the tab bar
     */
    GwResizer.prototype.addTabsBack = function () {
        var _this = this;
        var addBack = [];
        gwUtil_1.gwUtil.forEach(this.currentHamburgerSubMenu.children, function (child) {
            addBack.push(child);
        });
        addBack.forEach(function (child) {
            _this.currentTabHolder.appendChild(child);
        });
        this.processTabsInBarAndHamburger();
    };
    /**
     * Called by the resize event listener on the window.
     */
    GwResizer.prototype.onResize = function () {
        var _this = this;
        if (this.clearResizer) {
            clearTimeout(this.clearResizer);
        }
        // This is just to make sure if the user yanks the screen size, we don't end up processing a stack of them, when we just need to do the last one.
        this.clearResizer = setTimeout(function () {
            _this.recalcPanelSizing();
            gwScroll_1.gwScroll.clearStoredScrollPositions();
            _this._resizeCallbacks.forEach(function (callback) { return callback(); });
        }, 0);
    };
    /**
     * Do the details of the given partial reload indicate that something in the tab bar area may have changed?
     * @param partialReloadDetails details of the partial page reload
     * @returns {boolean} true if any of the ids refer to items in the tab bar
     */
    GwResizer.prototype.containsTabChanges = function (partialReloadDetails) {
        if (partialReloadDetails.reason !== plApp_1.GwPartialReloadReason.REPLACE_ITEMS) {
            // Assume the worst
            return true;
        }
        var found = false;
        gwUtil_1.gwUtil.forEach(partialReloadDetails.ids, function (id) {
            if (id === "gw-body") {
                gwUtil_1.gwUtil.devlog("INFO: gw-body is targeted for replace; tab bar area may have changed.");
                found = true;
                return gwTypes_1.GW_BREAKER;
            }
            if (gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(gwUtil_1.gwUtil.getDomNode("#" + id), "gw-north-panel")) {
                found = true;
                return gwTypes_1.GW_BREAKER;
            }
            return;
        });
        return found;
    };
    GwResizer.prototype.check = function () {
        this.onResize();
    };
    GwResizer.prototype.addResizeCallback = function (callback) {
        this._resizeCallbacks.push(callback);
    };
    return GwResizer;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwResizer = GwResizer;
exports.gwResizer = new GwResizer();


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new Adder;
});

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Math.random();
});


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwJicHelper_1 = __webpack_require__(84);
var gwFocus_1 = __webpack_require__(8);
var gwDatePickerHelper_1 = __webpack_require__(41);
var gwUtil_1 = __webpack_require__(0);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwJic = /** @class */ (function (_super) {
    __extends(GwJic, _super);
    function GwJic() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.monthOptions = [];
        _this.eraRegex = /^([^\d\s]+)(.*)/;
        return _this;
    }
    GwJic.prototype.getSystemName = function () {
        return "gwJic";
    };
    // INIT
    GwJic.prototype.init = function (isFullPageReload) {
        gwJicHelper_1.gwJicHelper.mapEraDataFromServer(); //TODO: cooper, this is a bit heavy handed to build this on every call, but we do unexpected things when we change location or language, so safest for now.
    };
    GwJic.prototype.isJIC = function (inputEl) {
        return inputEl.hasAttribute("data-gw-jic");
    };
    // PUBLIC METHODS
    GwJic.prototype.onEraChange = function (el) {
        var eraYear = +gwJicHelper_1.gwJicHelper.getEraYearSelect(el).value;
        var maxYears = gwJicHelper_1.gwJicHelper.getTotalYearsForCurrentEraSelect(el);
        // Cap the shown years to the max allowable for the new era
        if (eraYear > maxYears) {
            gwJicHelper_1.gwJicHelper.setEraYearSelect(maxYears);
        }
        this.onEraYearChange(el);
    };
    GwJic.prototype.onEraYearChange = function (el) {
        var eraYearSelect = gwJicHelper_1.gwJicHelper.getEraYearSelect(el);
        if (!eraYearSelect) {
            return;
        }
        this.eraMonthOrYearChangedPossiblyRestrictDates();
        var eraYear = +gwJicHelper_1.gwJicHelper.getEraYearSelect(el).value;
        var gregYear = gwJicHelper_1.gwJicHelper.eraYearToGregYear(eraYear, true);
        var inst = gwJicHelper_1.gwJicHelper.getInst();
        inst.eraYear = eraYear;
        inst["selectedYear"] = gregYear;
        inst["drawYear"] = gregYear;
        gwDatePickerHelper_1.gwDatePickerHelper._adjustDate(inst);
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    /**
     * Returns the value with the era stripped out.
     * calls setEraValueFromPaste if a possible era is found
     * @param val
     * @param dateInput
     * @returns {*}
     */
    GwJic.prototype.possiblyHandleEraValue = function (val, dateInput) {
        if (!this.isJIC(dateInput) || !gwUtil_1.gwUtil.hasValue(val)) {
            return val;
        }
        var groups = this.eraRegex.exec(val.trim());
        if (groups && groups.length === 3) {
            gwJicHelper_1.gwJicHelper.setEraValueFromPaste(groups[1], dateInput);
            return groups[2].trim();
        }
        else {
            return val;
        }
    };
    GwJic.prototype.datePickerCalledShow = function (el) {
        var eraSelect = gwJicHelper_1.gwJicHelper.getEraInput(el);
        gwUtil_1.gwUtil.addClass(eraSelect, "gw-inDatePicker");
    };
    GwJic.prototype.datePickerCalledHide = function (el) {
        gwUtil_1.gwUtil.removeClass(gwJicHelper_1.gwJicHelper.getEraInput(el), "gw-inDatePicker");
    };
    GwJic.prototype.datePickerCalledUpdate = function (inst) {
        // build date from inst, covert it to
        var gregDate = new Date(inst.drawYear, inst.drawMonth, inst.selectedDay);
        gwJicHelper_1.gwJicHelper.gregYearToEraYear(gregDate, true);
    };
    GwJic.prototype.getDefaultDate = function () {
        //const gregYear = eraYearToGregYear(null);
        //return new Date(gregYear, getInst().drawMonth, 1);
        return new Date();
    };
    GwJic.prototype.datePickerCalledParseDate = function (eraYear) {
        if (!eraYear) {
            return 0;
        }
        gwJicHelper_1.gwJicHelper.setEraYearSelect(eraYear);
        return gwJicHelper_1.gwJicHelper.eraYearToGregYear(eraYear);
    };
    GwJic.prototype.datePickerCalledFormatDate = function (gregDateObj) {
        return gwJicHelper_1.gwJicHelper.gregYearToEraYear(gregDateObj, true);
    };
    GwJic.prototype.datePickerCalledSelectDate = function () {
        gwJicHelper_1.gwJicHelper.setEraInputValue(gwJicHelper_1.gwJicHelper.getEraSelectValue());
    };
    GwJic.prototype.getEraYearPickerHtml = function (eraYearStr) {
        var eraYear = parseInt(eraYearStr);
        var eraDetail = gwJicHelper_1.gwJicHelper.getEraDetailsForValueOrOrderOrThrow(gwJicHelper_1.gwJicHelper.getEraSelectValue());
        var eraYearSelectHtml = "<div class=\"gw-datePicker--eraYear\"><select id=\"gw-datePicker--eraYear--select\" data-gw-change=\"gwJic.onEraYearChange\" data-gw-always-change>";
        for (var i = eraDetail.total; i >= 1; i--) {
            eraYearSelectHtml += ("<option value=\"" + i + "\"");
            if (eraYear === i) {
                eraYearSelectHtml += " selected";
            }
            eraYearSelectHtml += (">" + i + gwJicHelper_1.gwJicHelper.eraYearLocalizedSuffix + "</option>");
        }
        return eraYearSelectHtml + "</select><div class='gw-icon'></div></div>";
    };
    GwJic.prototype.getEraPickerHtml = function () {
        var eraVal = gwJicHelper_1.gwJicHelper.getEraSelectValue();
        var currentOrder = gwJicHelper_1.gwJicHelper.getEraDetailsForValueOrOrderOrThrow(eraVal).order;
        var eraPickerHtml = "<div class='gw-datePicker--era'><select id=\"gw-datePicker--era--select\" data-gw-change=\"gwJic.onEraChange\" data-gw-always-change>";
        for (var i = gwJicHelper_1.gwJicHelper.highestEraOrder; i >= 1; i--) {
            var name_1 = gwJicHelper_1.gwJicHelper.eraOrderIndexToDetails[i].name;
            eraPickerHtml += ("<option data-gw-order=\"" + i + "\" value=\"" + name_1 + "\"");
            if (currentOrder === i) {
                eraPickerHtml += " selected";
            }
            eraPickerHtml += (">" + name_1 + "</option>");
        }
        return eraPickerHtml + "</select><div class='gw-icon'></div></div>";
    };
    GwJic.prototype.getMonthOptionNames = function () {
        if (this.monthOptions.length === 0) {
            this.monthOptions = [];
            for (var i = 1; i < 13; i++) {
                this.monthOptions.push("" + i + gwJicHelper_1.gwJicHelper.eraMonthLocalizedSuffix);
            }
        }
        return this.monthOptions;
    };
    GwJic.prototype.showDatePicker = function (el, args, e) {
        var dateWidget = document.getElementById(args.id);
        if (!dateWidget) {
            return;
        }
        var dateInput = dateWidget.querySelector(".gw-DateValueWidget--dateInput");
        if (!dateInput) {
            return;
        }
        gwFocus_1.gwFocus.forceFocus(dateInput);
    };
    GwJic.prototype.eraMonthOrYearChangedPossiblyRestrictDates = function () {
        var detail = gwJicHelper_1.gwJicHelper.getEraDetailsForValueOrOrder(gwJicHelper_1.gwJicHelper.getEraSelectValue());
        if (!detail) {
            return;
        }
        // No need to do anything, since the whole month will be valid
        if (detail.startDay === 1) {
            return;
        }
        var eraYearSelect = gwJicHelper_1.gwJicHelper.getEraYearSelect(null);
        if (!eraYearSelect) {
            return;
        }
        var eraYear = +eraYearSelect.value;
        if (!eraYear) {
            return;
        }
        var currMonth = +gwJicHelper_1.gwJicHelper.getMonthSelect(null).value;
        if (+eraYear === 1 && currMonth === detail.startMonth) {
            gwDatePickerHelper_1.gwDatePickerHelper.disableDaysBefore(detail.startDay);
        }
        else if (detail.order !== gwJicHelper_1.gwJicHelper.highestEraOrder && eraYear >= detail.total) {
            var nextEmperorDetail = gwJicHelper_1.gwJicHelper.getEraDetailsForValueOrOrderOrThrow(detail.order + 1);
            var finalMonth = nextEmperorDetail.startMonth;
            if (finalMonth === currMonth) {
                gwDatePickerHelper_1.gwDatePickerHelper.disableDaysAfter(nextEmperorDetail.startDay - 1);
            }
        }
    };
    return GwJic;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwJic = GwJic;
exports.gwJic = new GwJic();


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwLocale_1 = __webpack_require__(58);
var gwJic_1 = __webpack_require__(40);
var gwKeys_1 = __webpack_require__(23);
var gwInputs_1 = __webpack_require__(5);
var gwFocus_1 = __webpack_require__(8);
var gwDisplayKey_1 = __webpack_require__(16);
var GwInitializableSystem_1 = __webpack_require__(4);
var gwUtil_1 = __webpack_require__(0);
var GwDateInfo_1 = __webpack_require__(134);
var gwEvents_1 = __webpack_require__(3);
var GwDatePickerHelper = /** @class */ (function (_super) {
    __extends(GwDatePickerHelper, _super);
    function GwDatePickerHelper() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._mainDivClass = "gw-datePicker";
        _this._mainDivId = "gw-datePicker--div"; // The ID of the main datePicker division
        _this._unselectableClass = " gw-datePicker--unselectable"; // The name of the unselectable cell marker class
        _this._otherMonthDayClass = " gw-datePicker--other-month";
        _this._inputtedValueDayClass = " gw-datePicker--inputted-value-day"; // The name of the current day marker class
        _this._todayDayClass = " gw-datePicker--today-cell";
        _this._keyEventCurrentDayClass = " gw-datePicker--keyEventDay";
        _this._uuidAttr = "data-gw-datePicker--uuid"; // The attr name where the uuid for the input is stored
        _this.minRows = 6;
        _this._datePickerShowing = false;
        _this._keyEvent = false; // If the last event was a key event
        _this._datePickerDiv = null;
        _this._$datePickerDiv = null;
        _this._currInst = null;
        _this._lastInput = null;
        /**
         * The storage object for all datePicker code. Much of it depends on jquery being instantiated, so we initialize it
         * all inside of loadAllRequiredJCode, but we need access to the methods externally, primarily for events
         * and to show hide the calendar from the global events system.
         * @type {{}}
         */
        _this.dateInstMap = {}; // Holds one object, per uuid, for each input using the date picker
        _this._defaults = {
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            showMonthAfterYear: true,
            yearSuffix: "",
            defaultDate: null,
            // +/-number for offset from today, null for today
            changeMonth: true,
            changeYear: true,
            yearRange: "c-100:c+10",
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: true,
            selectOtherMonths: true,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "49",
            // > this are in the previous century,
            minDate: null,
            maxDate: null,
            numberOfMonths: 1,
            stepMonths: 1,
            stepBigMonths: 12,
            hidePickerOnSelect: true // Fire hidePicker if the user selects a new date
        };
        return _this;
    }
    GwDatePickerHelper.prototype.availableToGlobal = function () {
        return false;
    };
    GwDatePickerHelper.prototype.getSystemName = function () {
        return "gwDatePicker";
    };
    GwDatePickerHelper.prototype.init = function (isFullPageReload) {
        var _this = this;
        this._defaults.monthNamesShort = gwLocale_1.gwLocale.getShortMonths();
        this._defaults.dayNamesMin = gwLocale_1.gwLocale.getMinWeekdays();
        this._datePickerDiv = gwUtil_1.gwUtil.createDiv([this._mainDivClass, "gw-inDatePicker", "gw-hidden"], { id: this._mainDivId });
        this._$datePickerDiv = $(this._datePickerDiv);
        gwUtil_1.gwUtil.forEach(gwUtil_1.gwUtil.getDomNodes(".gw-DateValueWidget--dateInput"), function (el) {
            _this.setupDateInput(el);
        });
    };
    Object.defineProperty(GwDatePickerHelper.prototype, "datePickerDiv", {
        get: function () {
            if (this._datePickerDiv === null) {
                throw new Error("Missing date picker div");
            }
            return this._datePickerDiv;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GwDatePickerHelper.prototype, "$datePickerDiv", {
        get: function () {
            if (this._$datePickerDiv === null) {
                throw new Error("Missing date picker div");
            }
            return this._$datePickerDiv;
        },
        enumerable: true,
        configurable: true
    });
    GwDatePickerHelper.prototype.isDatePickerShowing = function () {
        return this._datePickerShowing;
    };
    GwDatePickerHelper.prototype.getCurrDateInfoOrThrow = function () {
        if (!this._currInst) {
            throw new Error("Found null current date info object");
        }
        return this._currInst;
    };
    GwDatePickerHelper.prototype.setupDateInput = function (inputEl) {
        if (inputEl.nodeName.toLowerCase() !== "input") {
            throw new Error("Trying to add date picker to non input");
        }
        var possibleExistingInst = this._getInst(inputEl);
        if (possibleExistingInst) {
            delete this.dateInstMap[possibleExistingInst.uuid];
        }
        var inst = this._newInst(inputEl);
        inputEl.setAttribute("data-gw-click", "gwDateValue.showDatePickerOnEvent");
        inputEl.setAttribute("data-gw-focus", "gwDateValue.showDatePickerOnEvent");
        this.dateInstMap[inst.uuid] = inst;
    };
    /* Create a new instance object. */
    GwDatePickerHelper.prototype._newInst = function (inputEl) {
        var info = new GwDateInfo_1.GwDateInfo(inputEl);
        inputEl.setAttribute(this._uuidAttr, info.uuid);
        return info;
    };
    GwDatePickerHelper.prototype._getInst = function (inputEl) {
        var attr = inputEl.getAttribute(this._uuidAttr);
        if (!attr) {
            return null;
        }
        var inst = this.dateInstMap[attr];
        return inst || null;
    };
    GwDatePickerHelper.prototype._setDateDatePicker = function (inputEl, dateObj) {
        var inst = this._getInst(inputEl);
        if (inst) {
            this._setDate(inst, dateObj);
            this._updateDatePicker(inst);
        }
    };
    GwDatePickerHelper.prototype._getDateDatePicker = function (inputEl, noDefault) {
        if (noDefault === void 0) { noDefault = false; }
        var inst = this._getInst(inputEl);
        if (inst) {
            this._setDateFromField(inst, noDefault);
        }
        return (inst ? this._getDate(inst) : null);
    };
    /* Handle keystrokes. */
    GwDatePickerHelper.prototype._doKeyDown = function (event) {
        var sel;
        var inst = this._getInst(event.target);
        if (!inst) {
            return;
        }
        var key = gwEvents_1.gwEvents.getKeyCode(event);
        if (key !== null && key !== undefined) {
            if (gwKeys_1.gwKeys.ignoredKeyCodes[key]) {
                return;
            }
        }
        var handled = true;
        var checkCtrlMetaAndHandled = function () {
            handled = event.ctrlKey || event.metaKey;
            return handled;
        };
        var checkAltAndHandled = function () {
            handled = event.altKey;
            return handled;
        };
        this._keyEvent = true;
        if (this._datePickerShowing) {
            switch (event.keyCode) {
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.TAB:
                    this._hideDatePicker();
                    handled = false;
                    break; // hide on tab out
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.ENTER:
                    if (checkCtrlMetaAndHandled()) {
                        sel = $(".gw-datePicker--keyEventDay", $(this.datePickerDiv))[0];
                        if (sel) {
                            this._selectDay(inst, +sel.getAttribute("data-month"), +sel.getAttribute("data-year"), +sel.getAttribute("data-day"));
                        }
                    }
                    break; //select current day on ctrl enter
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.END:
                    if (checkCtrlMetaAndHandled()) {
                        this._clearDate(inst);
                    }
                    break; // clear on ctrl or command +end
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.HOME:
                    if (checkCtrlMetaAndHandled()) {
                        this._gotoToday(inst);
                    }
                    break; // current on ctrl or command +home
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.LEFT:
                    // Move month left
                    if (checkAltAndHandled()) {
                        this._adjustDate(inst, -this._get("stepMonths"), "M");
                        // Move day left
                    }
                    else if (checkCtrlMetaAndHandled()) {
                        this._adjustDate(inst, (-1), "D");
                    }
                    break;
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.UP:
                    //Move year up
                    if (checkAltAndHandled()) {
                        this._adjustDate(inst, -this._get("stepBigMonths"), "M");
                        // Move day up
                    }
                    else if (checkCtrlMetaAndHandled()) {
                        this._adjustDate(inst, -7, "D");
                    }
                    break;
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.RIGHT:
                    // Move month up
                    if (checkAltAndHandled()) {
                        this._adjustDate(inst, +this._get("stepMonths"), "M");
                        // move day up
                    }
                    else if (checkCtrlMetaAndHandled()) {
                        this._adjustDate(inst, (+1), "D");
                    }
                    break;
                case gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.DOWN:
                    // Move year down
                    if (checkAltAndHandled()) {
                        this._adjustDate(inst, +this._get("stepBigMonths"), "M");
                        // Move day down
                    }
                    else if (checkCtrlMetaAndHandled()) {
                        this._adjustDate(inst, +7, "D");
                    }
                    break;
                default:
                    handled = false;
            }
        }
        else if (event.keyCode === gwKeys_1.gwKeys.shortcutKeyWordToKeyCodeMap.HOME && event.ctrlKey) {
            this._showDatePicker(event.target);
        }
        else {
            handled = false;
        }
        if (handled) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /* Synchronise manual entry and field/alternate field. */
    /**
     * TODO: cooper. I do not know what this method does, or rather, why it needs to do it.
     * Going to comment out and see if anything breaks
     */
    GwDatePickerHelper.prototype._doKeyUp = function (event) {
        return false; //TODO: undo when/if turning method back on
        //   let date;
        //   const inst = this._getInst(event.target as HTMLInputElement);
        //   if (!inst) {
        //     return false;
        //   }
        //
        //   const key = gwEvents.getKeyCode(event);
        //
        //   if (key !== null && key !== undefined) {
        //     if (gwKeys.ignoredKeyCodes[key]) {
        //       return false;
        //     }
        //   }
        //
        //   if (inst.$input.val() !== inst.lastVal) {
        //     try {
        //       date = this.parseDate(inst);
        //       if (date && this._setDateFromField(inst, undefined, date)) {
        //         this._updateDatePicker(inst);
        //       }
        //     } catch (err) {
        //       // No op
        //     }
        //   }
        //   return true;
    };
    /** Pop-up the date picker for a given input field.
     * @param  inputEl - the input field attached to the date picker or
     *                    event - if triggered by focus
     */
    GwDatePickerHelper.prototype._showDatePicker = function (inputEl) {
        var inst = this._getInst(inputEl);
        if (!inst) {
            return;
        }
        if (this._datePickerShowing && this._currInst === inst) {
            return;
        }
        this._lastInput = inputEl;
        this._currInst = inst;
        var valueWidget = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(inst.$input[0], "gw-ValueWidget");
        if (inst.isJIC) {
            gwJic_1.gwJic.datePickerCalledShow(inputEl);
        }
        gwUtil_1.gwUtil.addClass(inst.$input, "gw-inDatePicker");
        inst.$input.on("keydown", this._doKeyDown.bind(this)).on("keyup", this._doKeyUp.bind(this));
        gwUtil_1.gwUtil.addClass(inst.dateIconEl, "gw-inDatePicker");
        gwUtil_1.gwUtil.removeClass(this.$datePickerDiv, "gw-hidden");
        gwUtil_1.gwUtil.appendEl(inst.$inputParent[0], this.$datePickerDiv[0]);
        this._setDateFromField(inst);
        this._datePickerShowing = true;
        if (valueWidget) {
            valueWidget.setAttribute("data-gw-hideHelptext", "true");
        }
        this._updateDatePicker(inst);
        gwInputs_1.gwInputs.preventPickerBeingOffscreen(inst.$inputParent[0], inst.inputEl, this.$datePickerDiv[0]);
        inst.lastVal = null;
    };
    GwDatePickerHelper.prototype._putFocusBackOnInput = function (inst) {
        if (inst.$input && inst.$input.is(":visible") && !inst.$input.is(":disabled") && !inst.$input.is(":focus")) {
            gwFocus_1.gwFocus.forceFocus(inst.$input[0]);
        }
    };
    /* Generate the date picker content. */
    GwDatePickerHelper.prototype._updateDatePicker = function (inst) {
        if (!this._datePickerShowing) {
            return;
        }
        if (inst.isJIC) {
            gwJic_1.gwJic.datePickerCalledUpdate(inst);
        }
        var datePickerHtml = this._generateHTML(inst);
        this.$datePickerDiv.empty().append(datePickerHtml);
        if (inst.isJIC) {
            gwJic_1.gwJic.eraMonthOrYearChangedPossiblyRestrictDates();
        }
        this.$datePickerDiv.width("");
    };
    /* Hide the date picker from view.*/
    GwDatePickerHelper.prototype._hideDatePicker = function () {
        if (this._datePickerDiv === null) {
            return;
        }
        if (this._currInst && this._currInst.isJIC) {
            gwJic_1.gwJic.datePickerCalledHide(null);
        }
        gwUtil_1.gwUtil.addClass(this.$datePickerDiv, "gw-hidden");
        if (this._lastInput) {
            gwUtil_1.gwUtil.removeClass(this._lastInput, "gw-inDatePicker");
            $(this._lastInput).off("keydown").off("keyup");
        }
        if (this._currInst) {
            gwUtil_1.gwUtil.removeClass(this._currInst.dateIconEl, "gw-inDatePicker");
            var valueWidget = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(this._currInst.$input[0], "gw-ValueWidget");
            if (valueWidget) {
                valueWidget.removeAttribute("data-gw-hideHelptext");
            }
        }
        this._lastInput = null;
        this._datePickerShowing = false;
        this._currInst = null;
    };
    /* Adjust one of the date sub-fields. */
    GwDatePickerHelper.prototype._adjustDate = function (inst, offset, period) {
        if (offset === void 0) { offset = 0; }
        if (period === void 0) { period = ""; }
        this._adjustInstDate(inst, offset, period);
        this._updateDatePicker(inst);
    };
    /**
     * Show the month and year that currently contains today's date.
     * @param inst
     * @private
     */
    GwDatePickerHelper.prototype._gotoToday = function (inst) {
        var date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        this._adjustDate(inst);
    };
    GwDatePickerHelper.prototype._selectToday = function (inst) {
        var date = new Date();
        this._selectDay(inst, date.getMonth(), date.getFullYear(), date.getDate());
    };
    /**
     * Show the month and year of the date displayed in the input element
     * @param inst
     * @private
     */
    GwDatePickerHelper.prototype._gotoCurrent = function (inst) {
        if (!inst.currentDay) {
            return;
        }
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
        this._adjustDate(inst);
    };
    /* Action for selecting a new month/year. */
    GwDatePickerHelper.prototype._selectMonthYear = function (inst, select, period) {
        inst["selected" + (period === "M" ? "Month" : "Year")] =
            inst["draw" + (period === "M" ? "Month" : "Year")] =
                parseInt(select.options[select.selectedIndex].value, 10);
        this._adjustDate(inst);
    };
    /* Action for selecting a day. */
    GwDatePickerHelper.prototype._selectDay = function (inst, month, year, day) {
        if (!inst || !inst.$input || inst.$input.hasClass(this._unselectableClass)) {
            return;
        }
        inst.selectedDay = inst.currentDay = day;
        inst.selectedMonth = inst.currentMonth = month;
        inst.selectedYear = inst.currentYear = year;
        this._selectDate(inst, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
    };
    GwDatePickerHelper.prototype._clearDate = function (inst) {
        this._selectDate(inst, "");
    };
    /* Update the input field with the selected date. */
    GwDatePickerHelper.prototype._selectDate = function (inst, dateStr) {
        dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
        if (inst.$input) {
            inst.$input.val(dateStr);
            if (inst.isJIC) {
                gwJic_1.gwJic.datePickerCalledSelectDate();
            }
        }
        this._putFocusBackOnInput(inst);
        if (this._get("hidePickerOnSelect")) {
            this._hideDatePicker();
        }
        this.markDateValueInputModified(inst.inputEl, "datepicker");
    };
    /*
     * @param  date  Date - the date to customise
     * @return [boolean, string] - is this date selectable?, what is its CSS class?
     */
    GwDatePickerHelper.prototype.noWeekends = function (date) {
        var day = date.getDay();
        return [(day > 0 && day < 6), ""];
    };
    GwDatePickerHelper.prototype.getDateFormatFromInst = function (inst) {
        return inst.inputEl.getAttribute("data-gw-input-mask") || this._get("dateFormat");
    };
    /* Parse a string value into a date object.
     * See formatDate below for the possible formats.
     *
     * @param  format string - the expected format of the date
     * @param  value string - the date in the above format
     * @return  Date - the extracted date value or null if value is blank
     */
    GwDatePickerHelper.prototype.parseDate = function (inst, forcedValue) {
        var format = this.getDateFormatFromInst(inst).toUpperCase();
        var value = gwUtil_1.gwUtil.hasValue(forcedValue) ? forcedValue : (inst.$input ? inst.$input.val() : null);
        if (format == null || value == null) {
            throw new Error("Invalid arguments");
        }
        value = (typeof value === "object" ? value.toString() : value + "");
        if (value === "") {
            return new Date();
        }
        var day = parseInt(value.substr(format.indexOf("DD"), 2));
        var month = parseInt(value.substr(format.indexOf("MM"), 2));
        var yIndex = format.indexOf("YYYY");
        var yLength = 4;
        if (yIndex === -1) {
            yIndex = format.indexOf("YY");
            yLength = 2;
        }
        var year = parseInt(value.substr(yIndex, yLength));
        var eraYear = year;
        if (yLength === 2) {
            var fullYear = (new Date()).getFullYear();
            if (year > this._defaults.shortYearCutoff) {
                fullYear -= 100;
            }
            year = parseInt(("" + fullYear).substr(0, 2) + year);
        }
        if (inst.isJIC) {
            year = gwJic_1.gwJic.datePickerCalledParseDate(eraYear);
        }
        var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
            throw new Error("Invalid date"); // E.g. 31/02/00
        }
        return date;
    };
    /* Format a date object into a string value.
     * The format can be combinations of the following:
     * dd/DD - day of month (two digit)
     * mm/MM - month of year (two digit)
     * yy/YY  - year (two digit)
     * yyyy/YYYY - year (four digit)
     *
     * @param  format string - the desired format of the date
     * @param  date Date - the date value to format
     * @param  settings Object
     * @return  string - the date in the above format
     */
    GwDatePickerHelper.prototype.formatDate = function (inst, date) {
        if (!date) {
            return "";
        }
        var format = this.getDateFormatFromInst(inst);
        var iFormat = 0;
        var lookAhead = function (match) {
            var matches = format.indexOf(match) > -1;
            if (matches) {
                iFormat += match.length - 1;
            }
            return matches;
        };
        // Format a number, with leading zero if necessary
        var formatNumber = function (match, value, len) {
            var num = "" + value;
            if (lookAhead(match)) {
                while (num.length < len) {
                    num = "0" + num;
                }
            }
            return num;
        };
        var output = "";
        format = format.toUpperCase();
        if (date) {
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                switch (format.charAt(iFormat)) {
                    case "D":
                        output += formatNumber("DD", date.getDate(), 2);
                        break;
                    case "M":
                        output += formatNumber("MM", date.getMonth() + 1, 2);
                        break;
                    case "Y":
                        if (lookAhead("YYYY")) {
                            output += date.getFullYear();
                        }
                        else if (lookAhead("YY")) {
                            if (inst.isJIC) {
                                output += gwJic_1.gwJic.datePickerCalledFormatDate(date);
                            }
                            else {
                                output += ("" + date.getFullYear()).slice(-2);
                            }
                        }
                        break;
                    default:
                        output += format.charAt(iFormat);
                }
            }
        }
        return output;
    };
    /* Get a setting value, defaulting if necessary. */
    GwDatePickerHelper.prototype._get = function (name) {
        return this._defaults[name];
    };
    /** Parse existing date and initialise date picker.
     *  @return: boolean, true if the input value has changed and the datepicker needs updating
     */
    GwDatePickerHelper.prototype._setDateFromField = function (inst, noDefault, parsedDate) {
        if (this._datePickerShowing && inst.$input.val() === inst.lastVal) {
            return false;
        }
        var dates = inst.lastVal = inst.$input ? inst.$input.val() : null;
        var defaultDate = this._getDefaultDate(inst);
        var date = defaultDate;
        //TODO: I think here we could establish if we thought the date was invalid, and inform the user in some way
        try {
            date = parsedDate || this.parseDate(inst, dates);
            date = date || defaultDate;
        }
        catch (event) {
            dates = (noDefault ? "" : dates);
        }
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        inst.currentDay = (dates ? date.getDate() : 0);
        inst.currentMonth = (dates ? date.getMonth() : 0);
        inst.currentYear = (dates ? date.getFullYear() : 0);
        this._adjustInstDate(inst);
        return true;
    };
    /* Retrieve the default date shown on opening. */
    GwDatePickerHelper.prototype._getDefaultDate = function (inst) {
        if (inst.isJIC) {
            return gwJic_1.gwJic.getDefaultDate();
        }
        var defDate = this._determineDate(inst, this._get("defaultDate"), new Date());
        if (!defDate) {
            throw new Error("Unable to determine a default date.");
        }
        return this._restrictMinMax(inst, defDate);
    };
    /* A date may be specified as an exact value or a relative one. */
    GwDatePickerHelper.prototype._determineDate = function (inst, date, defaultDate) {
        var _this = this;
        var offsetNumeric = function (offset) {
            var dateInner = new Date();
            dateInner.setDate(dateInner.getDate() + offset);
            return dateInner;
        };
        var offsetString = function (offset) {
            try {
                return _this.parseDate(inst, offset);
            }
            catch (e) {
                // Ignore
            }
            var dateInner = (offset.toLowerCase().match(/^c/) ? _this._getDate(inst) : null) || new Date();
            var year = dateInner.getFullYear();
            var month = dateInner.getMonth();
            var day = dateInner.getDate();
            var pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
            var matches = pattern.exec(offset);
            while (matches) {
                switch (matches[2] || "d") {
                    case "d":
                    case "D":
                        day += parseInt(matches[1], 10);
                        break;
                    case "w":
                    case "W":
                        day += parseInt(matches[1], 10) * 7;
                        break;
                    case "m":
                    case "M":
                        month += parseInt(matches[1], 10);
                        day = Math.min(day, _this._getDaysInMonth(year, month));
                        break;
                    case "y":
                    case "Y":
                        year += parseInt(matches[1], 10);
                        day = Math.min(day, _this._getDaysInMonth(year, month));
                }
                matches = pattern.exec(offset);
            }
            return new Date(year, month, day);
        };
        var newDate = defaultDate;
        if (!date) {
            newDate = defaultDate;
        }
        else if (typeof date === "string") {
            if (date.length === 0) {
                newDate = defaultDate;
            }
            else {
                newDate = offsetString(date);
            }
        }
        else if (typeof date === "number") {
            if (isNaN(date)) {
                newDate = defaultDate;
            }
            else {
                newDate = offsetNumeric(date);
            }
        }
        else {
            newDate = new Date(date.getTime());
        }
        newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
        if (!newDate) {
            return null;
        }
        if (newDate) {
            newDate.setHours(0);
            newDate.setMinutes(0);
            newDate.setSeconds(0);
            newDate.setMilliseconds(0);
        }
        return this._daylightSavingAdjust(newDate);
    };
    /* Handle switch to/from daylight saving.
     * Hours may be non-zero on daylight saving cut-over:
     * > 12 when midnight changeover, but then cannot generate
     * midnight datetime, so jump to 1AM, otherwise reset.
     * @param  date  (Date) the date to check
     * @return  (Date) the corrected date
     */
    GwDatePickerHelper.prototype._daylightSavingAdjust = function (date) {
        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
        return date;
    };
    /* Set the date(s) directly. */
    GwDatePickerHelper.prototype._setDate = function (inst, date, noChange) {
        if (noChange === void 0) { noChange = false; }
        var clear = !date;
        var origMonth = inst.selectedMonth;
        var origYear = inst.selectedYear;
        var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
        inst.selectedDay = inst.currentDay = newDate.getDate();
        inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
        inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
        if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
            //NOTE: was using onchange notification here, leaving, in case one day we implement something similar
        }
        this._adjustInstDate(inst);
        if (inst.$input) {
            inst.$input.val(clear ? "" : this._formatDate(inst));
        }
    };
    /* Retrieve the date(s) directly. */
    GwDatePickerHelper.prototype._getDate = function (inst) {
        var startDate = (!inst.currentYear || (inst.$input && inst.$input.val() === "") ? null :
            this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
        return startDate;
    };
    GwDatePickerHelper.prototype.disableDaysAfter = function (lastValidDay) {
        lastValidDay = +lastValidDay;
        var inst = this._currInst;
        if (!inst) {
            return;
        }
        if (inst.selectedDay > lastValidDay) {
            this._adjustInstDate(inst, lastValidDay, "D");
        }
        inst.disableDaysAfter = lastValidDay;
        inst.disableTestFoundDate1 = 0;
    };
    GwDatePickerHelper.prototype.disableDaysBefore = function (firstValidDay) {
        firstValidDay = +firstValidDay;
        var inst = this._currInst;
        if (!inst) {
            return;
        }
        if (inst.selectedDay < firstValidDay) {
            this._adjustInstDate(inst, firstValidDay, "D");
        }
        inst.disableDaysBefore = firstValidDay;
        inst.disableTestFoundDate1 = 0;
    };
    GwDatePickerHelper.prototype.shouldDisableCalendarDate = function (num, inst) {
        num = +num;
        // If no days to disable, then exit.
        if (!inst.disableDaysBefore && !inst.disableDaysAfter) {
            inst.disableTestFoundDate1 = 0;
            return false;
        }
        if (num === 1) {
            inst.disableTestFoundDate1++;
        }
        if (inst.disableDaysBefore) {
            if (num < inst.disableDaysBefore && inst.disableTestFoundDate1 < 2) {
                return true;
            }
            // If we haven't found the first date yet, then these dates are in the previous month
            if (!inst.disableTestFoundDate1) {
                return true;
            }
        }
        else if (inst.disableDaysAfter) {
            if (inst.disableTestFoundDate1 && num > inst.disableDaysAfter) {
                return true;
            }
            // If we've seen the number 1 twice, then all these dates are in the next month
            if (inst.disableTestFoundDate1 === 2) {
                return true;
            }
        }
        return false;
    };
    GwDatePickerHelper.prototype.getCurrentButtonText = function () {
        return gwDisplayKey_1.gwDisplayKey.get("Web.Client.DatePicker.SelectedDay") || "";
    };
    GwDatePickerHelper.prototype.getTodayButtonText = function () {
        return gwDisplayKey_1.gwDisplayKey.get("Web.Client.DatePicker.Today") || "";
    };
    /* Generate the HTML for the current state of the date picker. */
    GwDatePickerHelper.prototype._generateHTML = function (inst) {
        var tempDate = new Date(), todayDay = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), currentDay = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay))), numMonths = this._getNumberOfMonths(inst), isMultiMonth = false, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max");
        var maxDraw, firstDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, calender, thead, day, daysInMonth, leadDays, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, disabled, drawMonth = inst.drawMonth, drawYear = inst.drawYear;
        if (drawMonth < 0) {
            drawMonth += 12;
            drawYear--;
        }
        if (maxDate) {
            maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
            maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
            while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                drawMonth--;
                if (drawMonth < 0) {
                    drawMonth = 11;
                    drawYear--;
                }
            }
        }
        inst.drawMonth = drawMonth;
        inst.drawYear = drawYear;
        var closeButton = "<div class='gw-datePicker--close' tabindex='0' data-gw-click='gwDatePicker.hide'><div class='gw-icon'></div></div>";
        var todayButton = "<div class='gw-datePicker--today' tabindex='0' data-gw-click='gwDatePicker.today'><div class='gw-icon'></div>" + this.getTodayButtonText() + "</div>";
        var currentButton = "<div class='gw-datePicker--inputted-value' tabindex='0' data-gw-click='gwDatePicker.current'><div class='gw-icon'></div>" + this.getCurrentButtonText() + "</div>";
        var infoButton = this.getInfoButtonHTML();
        var footer = "<div class='gw-datePicker--footer gw-inDatePicker'>" +
            (this._isInRange(inst, todayDay) ? todayButton : "") +
            (this._isInRange(inst, currentDay) ? currentButton : "") +
            infoButton +
            closeButton +
            "</div>";
        firstDay = parseInt(this._get("firstDay"), 10);
        firstDay = (isNaN(firstDay) ? 0 : firstDay);
        var dayNamesMin = this._get("dayNamesMin");
        var monthNamesShort = this._get("monthNamesShort");
        showOtherMonths = this._get("showOtherMonths");
        selectOtherMonths = this._get("selectOtherMonths");
        defaultDate = this._getDefaultDate(inst);
        html = "";
        for (row = 0; row < numMonths[0]; row++) {
            group = "";
            for (col = 0; col < numMonths[1]; col++) {
                selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                calender = "";
                if (isMultiMonth) {
                    calender += "<div class='gw-datePicker--group";
                    if (numMonths[1] > 1) {
                        switch (col) {
                            case 0:
                                calender += " gw-datePicker--group-first";
                                break;
                            case numMonths[1] - 1:
                                calender += " gw-datePicker--group-last";
                                break;
                            default:
                                calender += " gw-datePicker--group-middle";
                        }
                    }
                    calender += "'>";
                }
                calender += "<div class='gw-datePicker--header gw-inDatePicker'>" +
                    this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNamesShort) + // draw month headers
                    "</div><table class='gw-datePicker--calendar gw-inDatePicker'><thead>" +
                    "<tr>";
                thead = "";
                for (dow = 0; dow < 7; dow++) {
                    day = (dow + firstDay) % 7;
                    thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='gw-datePicker--week-end'" : "") + ">" +
                        "<div title='" + dayNamesMin[day] + "'>" + dayNamesMin[day] + "</div></th>";
                }
                calender += thead + "</tr></thead><tbody>";
                daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                    inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                }
                leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                numRows = Math.max(this.minRows, Math.ceil((leadDays + daysInMonth) / 7)); // calculate the number of rows to generate
                printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                for (dRow = 0; dRow < numRows; dRow++) {
                    calender += "<tr>";
                    tbody = "";
                    for (dow = 0; dow < 7; dow++) {
                        daySettings = [true, ""];
                        otherMonth = (printDate.getMonth() !== drawMonth);
                        unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                        disabled = this.shouldDisableCalendarDate(printDate.getDate(), inst) ? "gw-disabled-day" : "";
                        tbody += "<td tabindex='0' class='" + disabled +
                            ((dow + firstDay + 6) % 7 >= 5 ? " gw-datePicker--week-end" : "") + // highlight weekends
                            (otherMonth ? this._otherMonthDayClass : "") + // highlight days from other months
                            ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && this._keyEvent) || // user pressed key
                                (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ? this._keyEventCurrentDayClass : "") + // highlight selected day
                            (unselectable ? this._unselectableClass : "") + // highlight unselectable days
                            (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                (printDate.getTime() === currentDay.getTime() ? this._inputtedValueDayClass : "") + // highlight selected day
                                (printDate.getTime() === todayDay.getTime() ? this._todayDayClass : "")) + "'" + // highlight today (if different)
                            ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                            (unselectable ? "" : " data-gw-click='gwDatePicker.selectDay' data-day='" + printDate.getDate() + "' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                            (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                (unselectable ? "<div>" + printDate.getDate() + "</div>" : "<div class='gw-datePicker--day-label" +
                                    (printDate.getTime() === todayDay.getTime() ? this._todayDayClass : "") +
                                    (printDate.getTime() === currentDay.getTime() ? this._inputtedValueDayClass : "") + // highlight selected day
                                    (otherMonth ? this._otherMonthDayClass : "") + // distinguish dates from other months
                                    "'>" + printDate.getDate() + "<div class='gw-datePicker--day-icon'></div></div>")) + "</td>"; // display selectable date
                        printDate.setDate(printDate.getDate() + 1);
                        printDate = this._daylightSavingAdjust(printDate);
                    }
                    calender += tbody + "</tr>";
                }
                drawMonth++;
                if (drawMonth > 11) {
                    drawMonth = 0;
                    drawYear++;
                }
                calender += "</tbody></table>" + (isMultiMonth ? "</div>" + ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='gw-datePicker--row-break'></div>" : "") : "");
                group += calender;
            }
            html += group;
        }
        html += footer;
        this._keyEvent = false;
        inst.disableDaysBefore = null;
        inst.disableDaysAfter = null;
        return html;
    };
    /* Generate the month and year header. */
    GwDatePickerHelper.prototype._generateMonthYearHeader = function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNamesShort) {
        var inMinYear, inMaxYear, years, year, endYear, html = "", monthHtml = "";
        var changeMonth = this._get("changeMonth"), changeYear = this._get("changeYear"), showMonthAfterYear = this._get("showMonthAfterYear");
        if (inst.isJIC) {
            monthNamesShort = gwJic_1.gwJic.getMonthOptionNames();
            html += gwJic_1.gwJic.getEraPickerHtml();
            html += gwJic_1.gwJic.getEraYearPickerHtml("" + inst.eraYear);
        }
        var prevButton = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<div class='gw-datePicker--prev' tabindex='0' data-gw-click='gwDatePicker.prev'><div class='gw-icon'></div></div>" : "";
        var nextButton = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<div class='gw-datePicker--next' tabindex='0' data-gw-click='gwDatePicker.next'><div class='gw-icon'></div></div>" : "";
        inMinYear = (minDate && minDate.getFullYear() === drawYear);
        inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
        monthHtml += prevButton;
        monthHtml += "<div class='gw-datePicker--month'><select id='gw-datePicker--month--select' data-gw-change='gwDatePicker.selectMonth' data-gw-always-change>";
        for (var month = 0; month < 12; month++) {
            if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                monthHtml += "<option value='" + month + "'" +
                    (month === drawMonth ? " selected='selected'" : "") +
                    ">" + monthNamesShort[month] + "</option>";
            }
        }
        monthHtml += "</select><div class='gw-icon'></div></div>";
        monthHtml += nextButton;
        if (!showMonthAfterYear) {
            html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
        }
        var yearshtml = "";
        if (secondary || !changeYear) {
            html += "<div class='gw-datePicker--year'>" + drawYear + "</div>";
        }
        else {
            // determine range of years to display
            years = this._get("yearRange").split(":");
            var thisYear_1 = new Date().getFullYear();
            var determineYear = function (value) {
                var finalYear = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                    (value.match(/[+\-].*/) ? thisYear_1 + parseInt(value, 10) :
                        parseInt(value, 10)));
                return (isNaN(finalYear) ? thisYear_1 : finalYear);
            };
            year = determineYear(years[0]);
            endYear = Math.max(year, determineYear(years[1] || ""));
            year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
            endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
            yearshtml += "<div class='gw-datePicker--year'><select id='gw-datePicker--year--select' data-gw-change='gwDatePicker.selectYear' data-gw-always-change>";
            for (; year <= endYear; year++) {
                yearshtml += "<option value='" + year + "'" +
                    (year === drawYear ? " selected='selected'" : "") +
                    ">" + year + "</option>";
            }
            yearshtml += "</select><div class='gw-icon'></div></div>";
            html += yearshtml;
        }
        html += this._get("yearSuffix");
        if (showMonthAfterYear) {
            html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
        }
        return html;
    };
    GwDatePickerHelper.prototype.getInfoButtonHTML = function () {
        return ""; //TODO: pull out info button completely
    };
    /* Adjust one of the date sub-fields. */
    GwDatePickerHelper.prototype._adjustInstDate = function (inst, offset, period) {
        if (offset === void 0) { offset = 0; }
        if (period === void 0) { period = ""; }
        var year = inst.selectedYear + (period === "Y" ? offset : 0), month = inst.selectedMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        if (period === "M" || period === "Y") {
            // NOTE: was using change watching functionality here, leaving in case one day we want something similar
        }
    };
    /* Ensure a date is within any min/max bounds. */
    GwDatePickerHelper.prototype._restrictMinMax = function (inst, date) {
        if (date === null) {
            throw new Error("unable to find min max for a null date");
        }
        var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = (minDate && date < minDate ? minDate : date);
        return (maxDate && newDate > maxDate ? maxDate : newDate);
    };
    /* Determine the number of months to show. */
    GwDatePickerHelper.prototype._getNumberOfMonths = function (inst) {
        return [1, 1]; //TODO: remove option relating to this
    };
    /* Determine the current maximum date - ensure no time components are set. */
    GwDatePickerHelper.prototype._getMinMaxDate = function (inst, minMax) {
        return this._determineDate(inst, this._get(minMax + "Date"), null);
    };
    /* Find the number of days in a given month. */
    GwDatePickerHelper.prototype._getDaysInMonth = function (year, month) {
        return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    };
    /* Find the day of the week of the first of a month. */
    GwDatePickerHelper.prototype._getFirstDayOfMonth = function (year, month) {
        return new Date(year, month, 1).getDay();
    };
    /* Determines if we should allow a "next/prev" month display change. */
    GwDatePickerHelper.prototype._canAdjustMonth = function (inst, offset, curYear, curMonth) {
        var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
        if (offset < 0) {
            date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
        }
        return this._isInRange(inst, date);
    };
    /* Is the given date in the accepted range? */
    GwDatePickerHelper.prototype._isInRange = function (inst, date) {
        var yearSplit, currentYear, minYear = null, maxYear = null;
        var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), years = this._get("yearRange");
        if (years) {
            yearSplit = years.split(":");
            currentYear = new Date().getFullYear();
            minYear = parseInt(yearSplit[0], 10);
            maxYear = parseInt(yearSplit[1], 10);
            if (yearSplit[0].match(/[+\-].*/)) {
                minYear += currentYear;
            }
            if (yearSplit[1].match(/[+\-].*/)) {
                maxYear += currentYear;
            }
        }
        return ((!minDate || date.getTime() >= minDate.getTime()) &&
            (!maxDate || date.getTime() <= maxDate.getTime()) &&
            (!minYear || date.getFullYear() >= minYear) &&
            (!maxYear || date.getFullYear() <= maxYear));
    };
    /* Format the given date for display. */
    GwDatePickerHelper.prototype._formatDate = function (inst, day, month, year) {
        if (!day) {
            inst.currentDay = inst.selectedDay;
            inst.currentMonth = inst.selectedMonth;
            inst.currentYear = inst.selectedYear;
        }
        var date = (day ? (typeof day === "object" ? day :
            this._daylightSavingAdjust(new Date(year, month, day))) :
            this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
        return this.formatDate(inst, date);
    };
    GwDatePickerHelper.prototype.markDateValueInputModified = function (el, ignoresystem) {
        var forceChangeEvent = false;
        var changeParent = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(el, "data-gw-change");
        if (changeParent) {
            var changeAttrib = changeParent.getAttribute("data-gw-change");
            if (changeAttrib === "refresh") {
                forceChangeEvent = true;
            }
        }
        else {
            changeParent = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(el, "data-gw-reflection-trigger");
        }
        gwInputs_1.gwInputs.notifySystemsOfInputValueChange(el, ignoresystem);
        if (forceChangeEvent) {
            gwEvents_1.gwEvents.forceGlobalEvent(el, "change");
        }
        else if (changeParent) {
            changeParent.setAttribute("data-gw-pending-change", "gwDateValue");
        }
    };
    return GwDatePickerHelper;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwDatePickerHelper = GwDatePickerHelper;
exports.gwDatePickerHelper = new GwDatePickerHelper();


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x === null ? NaN : +x;
});


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = hue;
/* harmony export (immutable) */ __webpack_exports__["b"] = gamma;
/* harmony export (immutable) */ __webpack_exports__["a"] = nogamma;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(158);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(isNaN(a) ? b : a);
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_nest__ = __webpack_require__(352);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_nest__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_set__ = __webpack_require__(353);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__src_set__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_map__ = __webpack_require__(101);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__src_map__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_keys__ = __webpack_require__(354);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__src_keys__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_values__ = __webpack_require__(355);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_4__src_values__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_entries__ = __webpack_require__(356);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_5__src_entries__["a"]; });








/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["g"] = spherical;
/* harmony export (immutable) */ __webpack_exports__["a"] = cartesian;
/* harmony export (immutable) */ __webpack_exports__["d"] = cartesianDot;
/* harmony export (immutable) */ __webpack_exports__["c"] = cartesianCross;
/* harmony export (immutable) */ __webpack_exports__["b"] = cartesianAddInPlace;
/* harmony export (immutable) */ __webpack_exports__["f"] = cartesianScale;
/* harmony export (immutable) */ __webpack_exports__["e"] = cartesianNormalizeInPlace;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


function spherical(cartesian) {
  return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(cartesian[1], cartesian[0]), Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi);
  return [cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda), cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda), Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = azimuthalRaw;
/* harmony export (immutable) */ __webpack_exports__["a"] = azimuthalInvert;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x),
        cy = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y),
        k = scale(cx * cy);
    return [
      k * cy * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x),
      k * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(x * x + y * y),
        c = angle(z),
        sc = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(c),
        cc = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(c);
    return [
      Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(x * sc, z * cc),
      Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(z && y * sc / z)
    ];
  }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
});


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = linearish;
/* harmony export (immutable) */ __webpack_exports__["a"] = linear;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__continuous__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tickFormat__ = __webpack_require__(464);





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["B" /* ticks */])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__tickFormat__["a" /* default */])(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["z" /* tickIncrement */])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["z" /* tickIncrement */])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["z" /* tickIncrement */])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["b" /* default */])(__WEBPACK_IMPORTED_MODULE_2__continuous__["c" /* deinterpolateLinear */], __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["m" /* interpolateNumber */]);

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["a" /* copy */])(scale, linear());
  };

  return linearish(scale);
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
});


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return tau; });
/* harmony export (immutable) */ __webpack_exports__["b"] = acos;
/* harmony export (immutable) */ __webpack_exports__["c"] = asin;
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return beaches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cells; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return circles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return edges; });
/* harmony export (immutable) */ __webpack_exports__["d"] = Diagram;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Beach__ = __webpack_require__(523);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cell__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Circle__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Edge__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RedBlackTree__ = __webpack_require__(125);






var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new __WEBPACK_IMPORTED_MODULE_4__RedBlackTree__["b" /* default */];
  circles = new __WEBPACK_IMPORTED_MODULE_4__RedBlackTree__["b" /* default */];

  while (true) {
    circle = __WEBPACK_IMPORTED_MODULE_2__Circle__["c" /* firstCircle */];
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        Object(__WEBPACK_IMPORTED_MODULE_0__Beach__["a" /* addBeach */])(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      Object(__WEBPACK_IMPORTED_MODULE_0__Beach__["b" /* removeBeach */])(circle.arc);
    } else {
      break;
    }
  }

  Object(__WEBPACK_IMPORTED_MODULE_1__Cell__["d" /* sortCellHalfedges */])();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["a" /* clipEdges */])(x0, y0, x1, y1);
    Object(__WEBPACK_IMPORTED_MODULE_1__Cell__["b" /* clipCells */])(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return Object(__WEBPACK_IMPORTED_MODULE_1__Cell__["a" /* cellHalfedgeStart */])(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwEvents_1 = __webpack_require__(3);
var GwReflectionTrigger_1 = __webpack_require__(220);
var gwCheckboxGroup_1 = __webpack_require__(129);
var gwDateValue_1 = __webpack_require__(55);
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwRangeValue_1 = __webpack_require__(221);
var gwRangeRadio_1 = __webpack_require__(130);
var gwInputs_1 = __webpack_require__(5);
var gwAjax_1 = __webpack_require__(15);
/**
 * Utility responsible for reflection functionality of the application.
 * See <Reflect> and <ReflectCondition> pcf elements
 *
 * There are two notions which are used in this class: trigger and reflector.
 * Both are wrappers around html elements with additional functionality.
 * A trigger provides functions to listen to change html native events and then dispatch events further to reflectors
 * A reflector provides a functionality to reflect values received from triggers to their internal HTML elements.
 */
var GwReflection = /** @class */ (function (_super) {
    __extends(GwReflection, _super);
    function GwReflection() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.TRIGGER_IDS_PROP = "triggerIds";
        _this.REFLECTOR_ID_PROP = "reflectorId";
        _this.DIRECT_CHANGES_ONLY_PROP = "directChangesOnly";
        /**
         * Cache of trigger wrappers
         */
        _this.triggerCache = {};
        /**
         * This helps prevents cyclic loops of triggers. It can happen when a reflector and a trigger listen to each other.
         */
        _this.cycleEventsCache = [];
        _this.changeListeners = {};
        return _this;
    }
    GwReflection.prototype.getSystemName = function () {
        return "gwReflection";
    };
    GwReflection.prototype.clearCache = function () {
        this.triggerCache = {};
        this.changeListeners = {};
    };
    GwReflection.prototype.notifyTriggerChange = function (id) {
        if (this.changeListeners.hasOwnProperty(id)) {
            this.changeListeners[id]();
        }
    };
    GwReflection.prototype.isReflectionTrigger = function (node) {
        return node.hasAttribute("data-gw-reflection-trigger");
    };
    /**
     * For each reflector node, wrap it into a reflector class, find all of its trigger, wrap them into trigger classes,
     * cache them, then add change listeners to those triggers
     */
    GwReflection.prototype.initForNode = function (node) {
        var _this = this;
        if (node.hasAttribute("data-gw-reflection")) {
            var reflectionInfo = this.parseReflectionInfo(node.getAttribute("data-gw-reflection"));
            var reflector_1 = this.reflectorify(node, reflectionInfo);
            var triggerIds = this.extractTriggerIds(reflectionInfo);
            var triggers_1 = [];
            triggerIds.split(",").forEach(function (triggerId) {
                var triggerNode = gwUtil_1.gwUtil.getDomNode("#" + triggerId);
                if (triggerNode) {
                    var trigger_1 = _this.triggerify(triggerNode);
                    triggers_1.push(trigger_1);
                    trigger_1.addChangeListener(function (isDirectChange) {
                        if (reflector_1.shouldReflect(isDirectChange)) {
                            _this.triggerChangeListener(trigger_1, triggers_1, reflector_1);
                        }
                    });
                }
                else {
                    gwUtil_1.gwUtil.devlog("No node found for trigger id: " + triggerId, node);
                }
            });
        }
    };
    GwReflection.prototype.parseReflectionInfo = function (stringValue) {
        var values = stringValue.split(";");
        if (values.length !== 3) {
            throw new Error("unable to extract reflection information from the string: " + stringValue);
        }
        var reflectionInfo = {};
        values.forEach(function (val) {
            var info = val.split(":");
            if (info.length !== 2) {
                throw new Error("unable to extract reflection information property from the string: " + val);
            }
            reflectionInfo[info[0]] = info[1];
        });
        return this.validateInfo(reflectionInfo);
    };
    GwReflection.prototype.validateInfo = function (reflectionInfo) {
        if (!reflectionInfo.hasOwnProperty(this.TRIGGER_IDS_PROP)) {
            throw new Error("triggerIds property is missing in " + reflectionInfo);
        }
        if (!reflectionInfo.hasOwnProperty(this.REFLECTOR_ID_PROP)) {
            throw new Error("reflectorId property is missing in " + reflectionInfo);
        }
        if (!reflectionInfo.hasOwnProperty(this.DIRECT_CHANGES_ONLY_PROP)) {
            throw new Error("directChangesOnly property is missing in " + reflectionInfo);
        }
        return reflectionInfo;
    };
    GwReflection.prototype.extractTriggerIds = function (reflectionInfo) {
        return reflectionInfo[this.TRIGGER_IDS_PROP];
    };
    GwReflection.prototype.extractReflectorId = function (reflectionInfo) {
        return reflectionInfo[this.REFLECTOR_ID_PROP];
    };
    GwReflection.prototype.extractDirectReflectOnly = function (reflectionInfo) {
        return reflectionInfo[this.DIRECT_CHANGES_ONLY_PROP] === "true";
    };
    /**
     * Handles a trigger change. Sends a request to the server to get the reflected value , based on the trigger value.
     */
    GwReflection.prototype.triggerChangeListener = function (trigger, allTriggers, reflector) {
        var requestObject = {
            activeTriggerId: trigger.id,
            allTriggerValues: allTriggers
                .reduce(function (map, itrTrigger) {
                map[itrTrigger.id] = itrTrigger.getValue();
                return map;
            }, {}),
            reflectorId: reflector.id
        };
        var requestParams = {};
        requestParams["__reflect"] = JSON.stringify(requestObject);
        gwAjax_1.gwAjax.ajaxRequest(requestParams, this.handleReflectionResponse.bind(this, trigger, allTriggers, reflector), this.handleReflectionError.bind(this, trigger, allTriggers, reflector));
    };
    /**
     * Handles a response from the server with the reflected value.
     */
    GwReflection.prototype.handleReflectionResponse = function (trigger, allTriggers, reflector, response) {
        var _this = this;
        var mapExpression = function (reflectionValue) {
            if (reflectionValue.isJavascript) {
                return _this.evalExpression(trigger, allTriggers, reflector, reflectionValue.value);
            }
            else {
                return reflectionValue.value;
            }
        };
        if (response.hasOwnProperty("reflectorValues")) {
            if (response.reflectorValues.hasOwnProperty("OPTIONS")) {
                reflector.reflectOptions(mapExpression(response.reflectorValues["OPTIONS"]));
            }
            if (response.reflectorValues.hasOwnProperty("MASK")) {
                reflector.reflectMask(mapExpression(response.reflectorValues["MASK"]));
            }
            if (response.reflectorValues.hasOwnProperty("VALUE")) {
                reflector.reflectValue(mapExpression(response.reflectorValues["VALUE"]));
            }
            if (response.reflectorValues.hasOwnProperty("AVAILABLE")) {
                reflector.reflectAvailable(mapExpression(response.reflectorValues["AVAILABLE"]));
            }
            if (response.reflectorValues.hasOwnProperty("CUSTOM")) {
                this.evalExpression(trigger, allTriggers, reflector, response.reflectorValues["CUSTOM"].value);
            }
        }
        else {
            console.error("unable to parse reflection response");
        }
    };
    /**
     * Reflection expressions which start with "javascript:" need to be executed on the client side, the server returns
     * such expression unchanged as a javascript code. These expression may include following symbols: TRIGGER_INDEX,
     * REFLECTOR, VALUE, VALUE1, .... , VALUEn (n - number of triggers). All these symbols need to be initialized in a
     * local context.
     *
     * All of that is done in this function.
     */
    GwReflection.prototype.evalExpression = function (trigger, allTriggers, reflector, expression) {
        //TODO: TS worried about how all this is going to handles with closures after TS compile
        // tslint:disable-next-line: no-unused-variable
        var VALUE = trigger.getValue();
        // tslint:disable-next-line: no-unused-variable
        var TRIGGER_INDEX = -1;
        // tslint:disable-next-line: no-unused-variable
        var REFLECTOR = reflector.widget;
        if (allTriggers) {
            for (var index = 0; index < allTriggers.length; index++) {
                // tslint:disable-next-line: no-eval
                eval("var VALUE" + (index + 1) + " = allTriggers[index].getValue();"); //
            }
            // tslint:disable-next-line: no-unused-variable
            TRIGGER_INDEX = allTriggers.indexOf(trigger);
        }
        // tslint:disable-next-line: no-eval
        return eval(expression);
    };
    GwReflection.prototype.handleReflectionError = function (trigger, allTriggers, reflector, reason, response) {
        // Do nothing to the reflection error message until we figure out where to display this message.
        // Possible exception could happen during reflection is validation errors.
        if (reason === 4 /* FATAL_ERROR */) {
            gwUtil_1.gwUtil.devlog(response.exceptionText);
            return 0 /* DONE */;
        }
        return 1 /* UNABLE_TO_PROCESS */;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////// REFLECTOR STUFF ///////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Wrap reflector node into a Reflector class
     */
    GwReflection.prototype.reflectorify = function (node, reflectionInfo) {
        var _this = this;
        var reflectorId = this.extractReflectorId(reflectionInfo);
        var reflectorWidget = gwUtil_1.gwUtil.getDomNode("#" + reflectorId);
        if (!reflectorWidget) {
            throw new Error("Unable to locate reflector widget. " + reflectorId);
        }
        var reflectDirectChangesOnly = this.extractDirectReflectOnly(reflectionInfo);
        return {
            id: reflectorId,
            widget: reflectorWidget,
            reflectDirectChangesOnly: reflectDirectChangesOnly,
            /**
             * Returns true, if this reflector is allowed to reflect values. May return false, in case if it is a trigger
             * itself and already has been changed by a user (cycle loops) or if in the configuration, this reflector is marked
             * as a reflector which reflects only direct changes, and this change is not direct
             */
            shouldReflect: function (isDirectChange) {
                if (isDirectChange === void 0) { isDirectChange = false; }
                if (reflectDirectChangesOnly && !isDirectChange) {
                    return;
                }
                var trigger = _this.getTriggerById(reflectorId);
                if (trigger) {
                    // don't reflect if is a trigger and already triggered.
                    return !trigger.hasTriggered();
                }
                return true;
            },
            reflectValue: function (value) {
                if (gwUtil_1.gwUtil.hasClass(node, "gw-value-reflector")) {
                    _this.reflectValueToReadOnlyElement(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-value-input-reflector")) {
                    _this.reflectValueToInputElement(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-value-select-reflector")) {
                    _this.reflectValueToSelectElement(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-value-checkboxGroup-reflector")) {
                    _this.reflectValueToCheckboxRange(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-range-readonly-reflector")) {
                    _this.reflectValueToReadOnlyRangeElement(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-range-radio-reflector")) {
                    _this.reflectValueToRangeRadioElement(node, reflectorId, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-checkbox-reflector")) {
                    _this.reflectValueToCheckboxElement(node, value);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-date-reflector")) {
                    _this.reflectValueToDateElement(node, value);
                }
                var trigger = _this.getTriggerById(reflectorId);
                // reflect further
                if (trigger) {
                    trigger.dispatchChangeEvent();
                }
            },
            reflectOptions: function (options) {
                if (gwUtil_1.gwUtil.hasClass(node, "gw-value-select-reflector")) {
                    gwRangeValue_1.gwRangeValue.setOptions(node, options);
                }
                else if (gwUtil_1.gwUtil.hasClass(node, "gw-value-checkboxGroup-reflector")) {
                    //TODO: enable later. Right now does not work - new checkbox group has to be triggerified again
                    //gw.CheckboxGroup.setOptions(node, options);
                }
            },
            reflectMask: function (mask) {
                if (gwUtil_1.gwUtil.hasClass(node, "gw-value-input-reflector")) {
                    // Reflected masks always use the default placeholder character, don't have to worry about custom ones
                    if (gwInputs_1.gwInputs.isActiveInputMask(mask)) {
                        node.setAttribute("data-gw-input-mask", mask);
                    }
                    else {
                        node.setAttribute("data-gw-input-mask", "");
                    }
                    node.setAttribute("placeholder", mask);
                    gwEvents_1.gwEvents.addAdditionalAttributes(node);
                }
            },
            reflectAvailable: function (available) {
                var childrenNode = gwUtil_1.gwUtil.getDomNode(".gw-vw--children", reflectorWidget);
                if (available) {
                    gwUtil_1.gwUtil.removeClass(reflectorWidget, "gw-disabled");
                    if (childrenNode) {
                        gwUtil_1.gwUtil.removeClass(childrenNode, "gw-hidden");
                    }
                    _this.enableNode(node, true);
                }
                else {
                    gwUtil_1.gwUtil.addClass(reflectorWidget, "gw-disabled");
                    if (childrenNode) {
                        gwUtil_1.gwUtil.addClass(childrenNode, "gw-hidden");
                    }
                    _this.enableNode(node, false);
                }
            }
        };
    };
    /**
     * Set innerText on node to value, but additionally, conditionally set the gw-negative class if the value
     * could possibly be a negative currency. css will then style it  if the value widget is also a currency widget
     * @param {GwDomNode} node
     * @param {string} value
     */
    GwReflection.prototype.reflectValueToReadOnlyElement = function (node, value) {
        node.innerText = value;
        gwUtil_1.gwUtil.conditionalAddRemoveClass(value && (value[0] === "-" || value[0] === "("), node, "gw-negative");
    };
    GwReflection.prototype.reflectValueToInputElement = function (node, value) {
        node.value = value;
    };
    GwReflection.prototype.reflectValueToSelectElement = function (node, value) {
        if (gwRangeValue_1.gwRangeValue.isMultiple(node)) {
            gwRangeValue_1.gwRangeValue.setValues(node, value);
        }
        else {
            gwRangeValue_1.gwRangeValue.setValue(node, value);
        }
    };
    GwReflection.prototype.reflectValueToCheckboxRange = function (node, value) {
        gwCheckboxGroup_1.gwCheckboxGroup.setValues(node, value);
    };
    GwReflection.prototype.reflectValueToReadOnlyRangeElement = function (node, value) {
        //TODO: implement
    };
    GwReflection.prototype.reflectValueToRangeRadioElement = function (node, reflectorId, value) {
        gwRangeRadio_1.gwRangeRadio.setValue(node, reflectorId, value);
    };
    GwReflection.prototype.reflectValueToCheckboxElement = function (node, value) {
        node.checked = (value === "true");
    };
    GwReflection.prototype.reflectValueToDateElement = function (node, value) {
        gwDateValue_1.gwDateValue.setValue(node, value);
    };
    GwReflection.prototype.enableNode = function (node, enabled) {
        if (enabled === void 0) { enabled = false; }
        if (gwUtil_1.gwUtil.hasClass(node, "gw-value-checkboxGroup-reflector")) {
            gwCheckboxGroup_1.gwCheckboxGroup.enable(node, enabled);
        }
        else if (gwUtil_1.gwUtil.hasClass(node, "gw-range-radio-reflector")) {
            gwRangeRadio_1.gwRangeRadio.enable(node, enabled);
        }
        else if (gwUtil_1.gwUtil.hasClass(node, "gw-date-reflector")) {
            gwDateValue_1.gwDateValue.enable(node, enabled);
        }
        else {
            node.disabled = !enabled;
        }
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////// TRIGGER STUFF /////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Returns trigger from the cache
     */
    GwReflection.prototype.getTriggerById = function (id) {
        return this.triggerCache[id];
    };
    GwReflection.prototype.cacheTriger = function (trigger) {
        this.triggerCache[trigger.id] = trigger;
    };
    /**
     * Wrap trigger node into a trigger wrapper class.
     */
    GwReflection.prototype.triggerify = function (triggerNode) {
        var triggerId = triggerNode.id;
        // check the cache first
        var trigger = this.getTriggerById(triggerId);
        if (trigger) {
            return trigger;
        }
        trigger = this.wrapWithFunctions(new GwReflectionTrigger_1.GwReflectionTrigger(triggerNode));
        this.cacheTriger(trigger);
        this.markAsTrigger(triggerNode);
        return trigger;
    };
    GwReflection.prototype.markAsTrigger = function (triggerNode) {
        triggerNode.setAttribute("data-gw-reflection-trigger", "data-gw-reflection-trigger");
    };
    GwReflection.prototype.wrapWithFunctions = function (trigger) {
        var triggerNode = trigger.widget;
        if (gwUtil_1.gwUtil.hasClass(triggerNode, "gw-readonly") || gwUtil_1.gwUtil.hasClass(triggerNode, "gw-actionValue")) {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.readonly);
            return trigger;
        }
        this.wrapWithEventListener(trigger);
        if (gwUtil_1.gwUtil.hasClass(triggerNode, "gw-CheckboxGroupRangeValueWidget") || gwUtil_1.gwUtil.hasClass(triggerNode, "gw-CheckboxGroupTypeKeyValueWidget")) {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.checkboxGroup);
        }
        else if (gwUtil_1.gwUtil.hasClass(triggerNode, "gw-RangeRadioValueWidget") || gwUtil_1.gwUtil.hasClass(triggerNode, "gw-BooleanRadioValueWidget") || gwUtil_1.gwUtil.hasClass(triggerNode, "gw-TypeKeyRadioValueWidget")) {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.radioRange);
        }
        else if (gwUtil_1.gwUtil.hasClass(triggerNode, "gw-DateValueWidget")) {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.dateInput);
        }
        else if (gwUtil_1.gwUtil.hasClass(triggerNode, "gw-BooleanCheckboxValueWidget")) {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.checkbox);
        }
        else {
            trigger.setReflectionType(GwReflectionTrigger_1.GwReflectionType.input);
        }
        return trigger;
    };
    GwReflection.prototype.wrapWithEventListener = function (trigger) {
        this.changeListeners[trigger.id] = trigger.internalDispatchChangeEvent.bind(trigger);
        return trigger;
    };
    return GwReflection;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwReflection = GwReflection;
exports.gwReflection = new GwReflection();


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwPrefPanel_1 = __webpack_require__(28);
var gwFocus_1 = __webpack_require__(8);
var gwInputs_1 = __webpack_require__(5);
var gwDatePickerHelper_1 = __webpack_require__(41);
var GwInitializableSystem_1 = __webpack_require__(4);
var gwUtil_1 = __webpack_require__(0);
var gwLocale_1 = __webpack_require__(58);
var gwHelpText_1 = __webpack_require__(81);
/**
 * DatePicker (DateValue)
 *
 * # OVERVIEW #
 * The DatePicker a client only widget, (the server knows nothing about it, and it knows nothing of the server), largely cribbed from the jQuery.datePicker.widget
 * We've cleaned out all unneeded code, added some features, and put in custom styling and layout. There is a lot of code
 * in this widget that doesn't conform to how we (gw) have been standardizing our js, but I've left it as a cleanup task.
 *
 *
 * # ENTRY POINT #
 * The entry point, currently, for the datePicker functionality finds any inputs marked with gw-DateValueWidget--input
 * and attaches listeners to those inputs, and any default properties. On focus, the datePicker becomes a child of the input's parent, and positions
 * itself absolutely below the input.
 *
 * The date picker then takes over various key events fired on the input, and manipulates its own UI accordingly.
 *
 *
 * # DEFAULTS & OVERRIDING PER INSTANCE #
 * It has dozens of defaults listed in gwDate._defaults. THESE ARE NEW AND OLD AND CHANGED from jquery, do NOT rely on their
 * documentation. Any input can override any of these defaults by passing an object to the .datePicker init method.
 * ie: $(".myInput").datePicker({hidePickerOnSelect: false});
 *
 * Every input has a property instance (referred to as inst in code), that holds that input's information, and custom properties.
 * Therefore, anywhere the code needs to get a property, it needs to use gwDate._get(inst, "property name") to be able to use the default
 * values if the property is not defined on the input itself.
 *
 *
 * # CLICK & KEY EVENTS #
 * Click-events are now handled by gw global events, and constantly punt focus back to the input element. See  _keyDown method.
 */
var GwDateValue = /** @class */ (function (_super) {
    __extends(GwDateValue, _super);
    function GwDateValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.twoDigitYearInfo = {};
        // private dateShortcuts: GwMap = {};
        _this._amPmStringCache = null;
        return _this;
    }
    GwDateValue.prototype.getSystemName = function () {
        return "gwDateValue";
    };
    /**
     * Needs to be fired on page loads.
     * @param isFullPageReload
     */
    GwDateValue.prototype.init = function (isFullPageReload) {
        this._amPmStringCache = null;
        // this.dateShortcuts = {
        //     "Ctrl/Cmd + →": gwDisplayKey.get("Web.Client.DatePicker.DayPlus"),
        //     "Ctrl/Cmd + ←": gwDisplayKey.get("Web.Client.DatePicker.DayMinus"),
        //     "Ctrl/Cmd + ↓": gwDisplayKey.get("Web.Client.DatePicker.WeekPlus"),
        //     "Ctrl/Cmd + ↑": gwDisplayKey.get("Web.Client.DatePicker.WeekMinus"),
        //     "Ctrl/Cmd + ENTER": gwDisplayKey.get("Web.Client.DatePicker.SelectDay"),
        //     "Alt + →": gwDisplayKey.get("Web.Client.DatePicker.MonthPlus"),
        //     "Alt + ←": gwDisplayKey.get("Web.Client.DatePicker.MonthMinus"),
        //     "Alt + ↓": gwDisplayKey.get("Web.Client.DatePicker.YearPlus"),
        //     "Alt + ↑": gwDisplayKey.get("Web.Client.DatePicker.YearMinus"),
        //     "Ctrl/Cmd + END": gwDisplayKey.get("Web.Client.DatePicker.Close"),
        //     "Ctrl/Cmd + HOME": gwDisplayKey.get("Web.Client.DatePicker.GoToToday")
        // };
        if (isFullPageReload) {
            this.twoDigitYearInfo = {
                threshold: parseInt(gwUtil_1.gwUtil.getUtilityInfo("gw-twoDigitYearThreshold")),
                late: parseInt(gwUtil_1.gwUtil.getUtilityInfo("gw-twoDigitYearLate")),
                early: parseInt(gwUtil_1.gwUtil.getUtilityInfo("gw-twoDigitYearEarly"))
            };
        }
    };
    GwDateValue.prototype.getTwoDigitYearThreshold = function () {
        return this.twoDigitYearInfo.threshold;
    };
    GwDateValue.prototype.getTwoDigitYearLate = function () {
        return this.twoDigitYearInfo.late;
    };
    GwDateValue.prototype.getTwoDigitYearEarly = function () {
        return this.twoDigitYearInfo.early;
    };
    GwDateValue.prototype.shouldCapDateTimeUserInput = function () {
        return gwPrefPanel_1.gwPrefPanel.getPrefValueById("capDateTimeUserInput");
    };
    GwDateValue.prototype.getAmString = function () {
        var amPmStrings = this.getAmPmStrings();
        if (!amPmStrings) {
            return "";
        }
        return amPmStrings[0];
    };
    GwDateValue.prototype.getPmString = function () {
        var amPmStrings = this.getAmPmStrings();
        if (!amPmStrings) {
            return "";
        }
        return amPmStrings[1];
    };
    GwDateValue.prototype.getAmPmStrings = function () {
        if (!this._amPmStringCache) {
            this._amPmStringCache = gwLocale_1.gwLocale.getPeriods();
        }
        return this._amPmStringCache;
    };
    // =============== PUBLIC METHODS FOR EVENTS ==================
    /**
     * @public
     */
    GwDateValue.prototype.hideDatePicker = function () {
        gwDatePickerHelper_1.gwDatePickerHelper._hideDatePicker();
    };
    /**
     * @public
     * @param el
     * @param args
     * @param event
     */
    GwDateValue.prototype.showDatePickerOnEvent = function (el) {
        if (!gwPrefPanel_1.gwPrefPanel.getPrefValueById("focusOpenDatePicker")) {
            return;
        }
        gwDatePickerHelper_1.gwDatePickerHelper._showDatePicker(el);
    };
    /**
     * Clicking the icon will punt focus into the date input.
     * It will also act as a toggle for the date picker showing.
     * @param el
     * @param args
     * @param event
     */
    GwDateValue.prototype.dateIconClicked = function (el, args, event) {
        var dateWidget = document.getElementById(args.id);
        if (!dateWidget) {
            return;
        }
        var inCurrentDatePicker = gwUtil_1.gwUtil.hasClass(el, "gw-inDatePicker");
        if (gwDatePickerHelper_1.gwDatePickerHelper.isDatePickerShowing()) {
            this.hideDatePicker();
        }
        if (!inCurrentDatePicker) {
            var dateInput = dateWidget.querySelector(".gw-DateValueWidget--dateInput");
            gwFocus_1.gwFocus.forceFocus(dateInput);
            if (!gwPrefPanel_1.gwPrefPanel.getPrefValueById("focusOpenDatePicker")) {
                gwDatePickerHelper_1.gwDatePickerHelper._showDatePicker(dateInput);
                // Make sure HelpText is closed when DatePicker is opened so they don't overlap
                gwHelpText_1.gwHelpText.closeHelpText();
            }
        }
    };
    GwDateValue.prototype.clickedOnAmPmInput = function (el, args) {
        var timeInputEl = document.getElementById(args.id);
        if (!timeInputEl) {
            return;
        }
        var currVal = el.value;
        var am = this.getAmString();
        var pm = this.getPmString();
        var finalVal = (currVal === am) ? pm : am;
        el.value = finalVal;
        gwDatePickerHelper_1.gwDatePickerHelper.markDateValueInputModified(el);
    };
    /**
     * @public
     * @param el
     * @param args
     * @param event
     */
    GwDateValue.prototype.notifyPickerOfInputChange = function (el) {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper._getInst(el);
        if (inst) {
            gwDatePickerHelper_1.gwDatePickerHelper._setDateFromField(inst);
            gwDatePickerHelper_1.gwDatePickerHelper._updateDatePicker(inst);
        }
    };
    GwDateValue.prototype.getValue = function (dateWidgetNode) {
        var widget = gwUtil_1.gwUtil.getDomNodeOrThrow(dateWidgetNode);
        var values = [];
        var eraSelect = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--era", widget);
        if (eraSelect) {
            values.push(eraSelect.value);
        }
        var dateInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--dateInput", widget);
        if (dateInput) {
            values.push(dateInput.value);
        }
        var timeInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--timeInput", widget);
        if (timeInput) {
            values.push(timeInput.value);
        }
        var ampmInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--ampm", widget);
        if (ampmInput) {
            values.push(ampmInput.value);
        }
        return values.join(" ");
    };
    GwDateValue.prototype.setValue = function (dateWidgetNode, dateValue) {
        var widget = gwUtil_1.gwUtil.getDomNodeOrThrow(dateWidgetNode);
        var dateInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--dateInput", widget);
        if (dateInput) {
            dateInput.value = dateValue;
            gwInputs_1.gwInputs.valueChangedSoProcessInputMask(dateInput);
        }
        else {
            //maybe timeInput
            var timeInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--timeInput", widget);
            if (timeInput) {
                timeInput.value = dateValue;
                gwInputs_1.gwInputs.valueChangedSoProcessInputMask(timeInput);
            }
        }
    };
    GwDateValue.prototype.isDateValueWidget = function (el) {
        if (!el) {
            return false;
        }
        return gwUtil_1.gwUtil.hasClass(el, "gw-DateValueWidget");
    };
    GwDateValue.prototype.getConfirmTargets = function (dateValueNode) {
        return $(dateValueNode).find("input.gw-DateValueWidget--dateInput," +
            "input.gw-DateValueWidget--timeInput," +
            "select.gw-DateValueWidget--ampm");
    };
    GwDateValue.prototype.deferredChangeOnFocusInMethod = function () {
        // In case the date or time picker is open and we move away,
        // make sure date and time pickers are closed.
        this.hideDatePicker();
    };
    GwDateValue.prototype.enable = function (dateWidgetNode, enabled) {
        if (enabled === void 0) { enabled = false; }
        var widget = gwUtil_1.gwUtil.getDomNodeOrThrow(dateWidgetNode);
        var eraInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--era", widget);
        if (eraInput) {
            eraInput.disabled = !enabled;
        }
        var dateInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--dateInput", widget);
        if (dateInput) {
            dateInput.disabled = !enabled;
        }
        var timeInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--timeInput", widget);
        if (timeInput) {
            timeInput.disabled = !enabled;
        }
        var ampmInput = gwUtil_1.gwUtil.getInputElement(".gw-DateValueWidget--ampm", widget);
        if (ampmInput) {
            ampmInput.disabled = !enabled;
        }
    };
    return GwDateValue;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwDateValue = GwDateValue;
exports.gwDateValue = new GwDateValue();


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var gwDraggable_1 = __webpack_require__(82);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwTooltips = /** @class */ (function (_super) {
    __extends(GwTooltips, _super);
    function GwTooltips() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.xOffset = 3; // Offset of right end of tooltip from mouse position
        _this.yOffsetUp = 3; // Offset of bottom of tooltip from mouse position
        _this.yOffsetDown = 8; // Offset of top of tooltip from mouse position, if there's no room above the mouse
        _this.tooltipDiv = null;
        _this.DATA_TOOLTIP = "data-gw-tooltip";
        return _this;
    }
    GwTooltips.prototype.getSystemName = function () {
        return "gwTooltips";
    };
    GwTooltips.prototype.init = function (isFullPageReload, partialReloadDetails) {
        if (isFullPageReload && this.tooltipDiv === null) {
            this.tooltipDiv = document.createElement("div");
            this.tooltipDiv.classList.add("gw-tooltip");
            document.body.appendChild(this.tooltipDiv);
        }
    };
    /**
     * Used to add a tooltip, and all the required attributes, to a client generated element, generated after the page walk is complete
     * @param el
     * @param tooltip
     */
    GwTooltips.prototype.addTooltip = function (el, tooltip) {
        el.setAttribute(this.DATA_TOOLTIP, tooltip);
        gwEvents_1.gwEvents.addInlineEventListenersToThisSpecificNode(el);
    };
    GwTooltips.prototype.getTooltipDiv = function () {
        if (this.tooltipDiv === null) {
            throw new Error("Missing tooltip div");
        }
        return this.tooltipDiv;
    };
    GwTooltips.prototype.positionTooltip = function (e) {
        var tooltipRect = this.getTooltipDiv().getBoundingClientRect();
        var left = Math.max(e.clientX - (tooltipRect.width + this.xOffset), 0);
        var top = e.clientY - (tooltipRect.height + this.yOffsetUp);
        if (top < 0) {
            top = e.clientY + this.yOffsetDown;
        }
        this.getTooltipDiv().style.left = left + "px";
        this.getTooltipDiv().style.top = top + "px";
    };
    GwTooltips.prototype.show = function (el, args, e) {
        if (gwDraggable_1.gwDraggable.isDragging() ||
            !el.hasAttribute(this.DATA_TOOLTIP) ||
            el.hasAttribute("data-gw-hideHelptext")) {
            this.hide();
            return;
        }
        gwUtil_1.gwUtil.addClass(this.getTooltipDiv(), "gw-show");
        this.getTooltipDiv().innerHTML = el.getAttribute(this.DATA_TOOLTIP) || "";
        //position anyway, so that it is in the right place when it appears
        this.positionTooltip(e);
    };
    GwTooltips.prototype.move = function (el, args, e) {
        this.positionTooltip(e);
    };
    GwTooltips.prototype.hide = function () {
        if (this.tooltipDiv === null) {
            return;
        }
        gwUtil_1.gwUtil.removeClass(this.getTooltipDiv(), "gw-show");
        this.getTooltipDiv().style.removeProperty("left");
        this.getTooltipDiv().style.removeProperty("top");
        this.getTooltipDiv().innerHTML = "";
    };
    return GwTooltips;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwTooltips = GwTooltips;
exports.gwTooltips = new GwTooltips();


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwAnimation = /** @class */ (function (_super) {
    __extends(GwAnimation, _super);
    function GwAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Stores the event handler functions for animationend by animation name.
         * We do this so that we don't have to worry about adding and removing event listeners per element,
         * but we also add the listeners dynamically so that creating new animations don't require updating
         * a fixed list of names here.
         * @type {{}}
         */
        _this.animationEndEventListeners = {};
        return _this;
    }
    GwAnimation.prototype.getSystemName = function () {
        return "gwAnimation";
    };
    GwAnimation.prototype.getAnimClass = function (name) {
        if (name.indexOf(".gw-animation--") >= 0) {
            return name;
        }
        return "gw-animation--" + name;
    };
    /**
     * Adds the classname for the animation to the element.
     * If we haven't already registered a global listener for the animation name, then it builds the method
     * and adds an event listener to document.body
     * @param el
     * @param className
     * @param animName
     */
    GwAnimation.prototype.processElForAnimation = function (el, className, animName) {
        var _this = this;
        gwUtil_1.gwUtil.addClass(el, className);
        // We've already added an event listener for this animation name to the window, so no reason to do anything else
        if (this.animationEndEventListeners[animName]) {
            return;
        }
        this.animationEndEventListeners[animName] = function (event) {
            _this.killAnimation(animName, event.target);
        };
        document.body.addEventListener("animationend", this.animationEndEventListeners[animName]);
    };
    /**
     * Adds the animation class for a a css keyframed animation, and sets up an event listener, if not already setup,
     * to fire killAnimation on the element when the animation completes.
     *
     * This allows a given element to have n number of unique animations loaded on it, but obviously only one
     * of a given animation. Meaning, adding the same animation twice does not stack them. Instead, it will kill
     * the current animation, then fire a settimeout to queue the animation again from the start.
     */
    GwAnimation.prototype.addAnimation = function (classIdTagOrNode, animName) {
        var _this = this;
        var els = gwUtil_1.gwUtil.getDomNodes(classIdTagOrNode);
        var className = this.getAnimClass(animName);
        gwUtil_1.gwUtil.forEach(els, function (el) {
            // Special Exception for inner actions, as it looks odd to animate over the drop down arrow
            if (gwUtil_1.gwUtil.hasClass(el, "gw-action--inner") || gwUtil_1.gwUtil.hasClass(el, "gw-action--expand-button")) {
                el = $(el).parents(".gw-action--outer")[0];
            }
            if (gwUtil_1.gwUtil.hasClass(el, className)) {
                _this.killAnimation(animName, el);
                setTimeout(_this.addAnimation.bind(_this, el, animName), 0);
                return;
            }
            _this.processElForAnimation(el, className, animName);
        });
    };
    /**
     * Called automatically by the animationend listener created via animation.addAnimation, but can be manually called in the event
     * of an animation being infinite.
     * @param animName
     * @param el
     */
    GwAnimation.prototype.killAnimation = function (animName, el) {
        if (!el) {
            return;
        }
        gwUtil_1.gwUtil.removeClass(el, this.getAnimClass(animName));
    };
    return GwAnimation;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwAnimation = GwAnimation;
exports.gwAnimation = new GwAnimation();


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwLocale = /** @class */ (function (_super) {
    __extends(GwLocale, _super);
    function GwLocale() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.localeCode = null;
        return _this;
    }
    GwLocale.prototype.getSystemName = function () {
        return "gwLocale";
    };
    GwLocale.prototype.orderSpecificInit = function () {
        var previous = this.localeCode;
        var next = gwUtil_1.gwUtil.getUtilityInfo("gw-locale");
        if (!next) {
            return;
        }
        this.localeCode = next;
        if (previous && previous !== this.localeCode) {
            gwUtil_1.gwUtil.fireCustomEvent("localeChanged", { locale: this.localeCode });
        }
    };
    GwLocale.prototype.getDecimalSymbol = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-decimal-symbol") || ".";
    };
    GwLocale.prototype.getThousandsSymbol = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-thousands-symbol") || ",";
    };
    GwLocale.prototype.getMinWeekdays = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-minDays").split("++") || ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    };
    GwLocale.prototype.getShortWeekdays = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-shortDays").split("++") || ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    };
    GwLocale.prototype.getWeekdays = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-days").split("++") || ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    };
    GwLocale.prototype.getShortMonths = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-shortMonths").split("++") || ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    };
    GwLocale.prototype.getMonths = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-months").split("++") || ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    };
    GwLocale.prototype.getPeriods = function () {
        return gwUtil_1.gwUtil.getUtilityInfo("gw-amPmInfo").split("++") || ["AM", "PM"];
    };
    return GwLocale;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwLocale = GwLocale;
exports.gwLocale = new GwLocale();


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Simple class representing a coordinate pair. Has getters for x,y and w,h.
 * Has simple math methods for operating on multiple Vectors.
 * Has dot accessors for get, and none for set. As it's dangerous to send mutable objects around
 * that may be held as references.
 */
var GwPoint = /** @class */ (function () {
    function GwPoint(x, y) {
        this._x = x;
        this._y = y;
        this._length = Math.sqrt(this._x * this._x + this._y * this._y);
    }
    Object.defineProperty(GwPoint.prototype, "x", {
        get: function () {
            return this._x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GwPoint.prototype, "y", {
        get: function () {
            return this._y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GwPoint.prototype, "length", {
        get: function () {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    GwPoint.prototype.minus = function (point) {
        return new GwPoint(this.x - point.x, this.y - point.y);
    };
    GwPoint.getElTopLeftVector = function (el) {
        var bounds = el.getBoundingClientRect();
        return new GwPoint(bounds.left, bounds.top);
    };
    GwPoint.ZERO = new GwPoint(0, 0);
    return GwPoint;
}());
exports.GwPoint = GwPoint;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Collects information for the server side PerfAnalyzer, which tracks total request/response time across both
 * server and client. Communication is via the "reqMon" input. The value of the input is a JSON array containing
 * details of a request/response timing. Each request also has a unique id which the server stores in a data
 * attribute on the "reqMon" input so the client can store it in the JSON array returned to the server.
 */
var gwUtil_1 = __webpack_require__(0);
var GwPerfAnalyzer = /** @class */ (function () {
    function GwPerfAnalyzer() {
        this.enabled = false;
        this.eventId = "-1";
        // Time stamps are elapsed time since page was loaded, not UTC
        this.requestStartTimeStamp = -1;
        this.requestSentTimeStamp = -1;
        this.responseReceivedTimeStamp = -1;
        /**
         * Array of information sent back to the server, contains:
         * [eventId, requestPrepElapsed, serverRequestElapsed, responseProcessElapsed, responseDoneTime, requestId, agent]
         */
        this.infoArray = null;
    }
    GwPerfAnalyzer.prototype.getPerfInput = function () {
        return gwUtil_1.gwUtil.getDomNodeByName("reqMon");
    };
    GwPerfAnalyzer.prototype.getPerfInputOrThrow = function () {
        var node = this.getPerfInput();
        if (!node) {
            throw new Error("Found null perf input element");
        }
        return node;
    };
    GwPerfAnalyzer.prototype.elapsed = function (earlier, later) {
        return earlier && later ? Math.round(later - earlier) : 0;
    };
    GwPerfAnalyzer.prototype.startRequest = function (requestEventId) {
        this.enabled = !!this.getPerfInput();
        if (!this.enabled) {
            return;
        }
        if (this.infoArray) {
            var node = this.getPerfInput();
            if (!node) {
                return;
            }
            // Send results from previous request along with this request
            node.setAttribute("value", JSON.stringify(this.infoArray));
            this.infoArray = null;
        }
        this.eventId = requestEventId;
        this.requestStartTimeStamp = performance.now();
    };
    GwPerfAnalyzer.prototype.requestSent = function () {
        if (!this.enabled) {
            return;
        }
        this.requestSentTimeStamp = performance.now();
    };
    GwPerfAnalyzer.prototype.responseReceived = function () {
        if (!this.enabled) {
            return;
        }
        this.responseReceivedTimeStamp = performance.now();
    };
    GwPerfAnalyzer.prototype.responseProcessed = function () {
        if (!this.enabled) {
            return;
        }
        var responseProcessedTimeStamp = performance.now();
        var requestPrepElapsed = this.elapsed(this.requestStartTimeStamp, this.requestSentTimeStamp);
        var serverRequestElapsed = this.elapsed(this.requestSentTimeStamp, this.responseReceivedTimeStamp);
        var responseProcessElapsed = this.elapsed(this.responseReceivedTimeStamp, responseProcessedTimeStamp);
        var responseProcessedTimeUTC = Math.round(performance.timing.navigationStart + responseProcessedTimeStamp);
        var perfInputRequestId = this.getPerfInputOrThrow().dataset.gwRequestId;
        this.infoArray = [
            this.eventId,
            requestPrepElapsed,
            serverRequestElapsed,
            responseProcessElapsed,
            responseProcessedTimeUTC,
            perfInputRequestId,
            window.navigator.userAgent
        ];
    };
    return GwPerfAnalyzer;
}());
exports.GwPerfAnalyzer = GwPerfAnalyzer;
exports.gwPerfAnalyzer = new GwPerfAnalyzer();


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwEvents_1 = __webpack_require__(3);
var gwKeys_1 = __webpack_require__(23);
var gwUtil_1 = __webpack_require__(0);
var GwKeyListener_1 = __webpack_require__(85);
var GwEventDescription = /** @class */ (function (_super) {
    __extends(GwEventDescription, _super);
    function GwEventDescription(node) {
        var _this = _super.call(this, "") || this;
        _this.eventType = "";
        _this.unnamedArgs = "";
        _this.replacesClick = false;
        _this.id = "";
        _this.suffix = "";
        _this.key = "";
        _this.metaKey = false;
        _this.ctrlKey = false;
        _this.shiftKey = false;
        _this.altKey = false;
        _this.eventTargetNode = node;
        _this.id = node.getAttribute("id") || "";
        return _this;
    }
    /**
     * @private
     * Takes the node and the event, and returns an event description object in the form of:
     * {eventTargetNode: node, methodName: Function, arg1: String, unnamedArgs: String etc }
     *
     * First looks on the node for matching gw-data-eventType attribute to parse. If we're not dealing
     * with a key event then that's it - if we found a matching attribute we're good otherwise we return
     * null.
     *
     * If the event is a key event then even if we have a matching attribute we have to check that it
     * applies to the particular key code in the event. And if the attribute doesn't match (or if we didn't
     * even find an attribute) we still have to check for special "reactor" key events plus server and
     * global keyboard shortcuts.
     *
     * @param node
     * @param e
     * @returns {Object}
     */
    GwEventDescription.getEventDescription = function (node, e) {
        // We remap some event names here to match up with more generic terms the server uses, like key instead of keyup.
        var eventType = gwEvents_1.gwEvents.eventsMap[e.type] || e.type;
        //find if the node has an event attribute matching the triggered event
        var description = this.parseEventDescription(node, node.getAttribute(gwEvents_1.gwEvents.dataPrefix + eventType)) || this.createBasicEventDescription(node);
        //Persist the mapped eventType onto the description
        description.eventType = eventType;
        // If it's a key, then we are gonna check a bunch of stuff before we decide if there's a method or not
        if (description.eventType === "key") {
            var keyboardEvent = e;
            // If we received a key event, then either the node is focusable, or it is document.body. If it's
            // focusable then we've parsed its gw-data-key attribute (if any) into description, so first check
            // if the key specified in the description matches the event. If that fails then try, in sequence:
            // 1) The reactors list, which converts special keys (return/space) into actions on the target node
            // 2) The list of server keyboard shortcuts
            // 3) This list of global, hardcoded, shortcut
            var tempKeyCode = gwEvents_1.gwEvents.getKeyCode(keyboardEvent);
            var keyCode = "";
            if (tempKeyCode !== null) {
                keyCode = "" + tempKeyCode;
            }
            // We do this check here, even though we shouldnt have to, because chrome is not returning a key code on the login page,
            // for some reason we don't understand, so harden against it, since it's benign.
            if (gwUtil_1.gwUtil.hasValue(keyCode)) {
                keyCode = keyCode.toString();
            }
            return this.descriptionFromKeyListener(gwKeys_1.gwKeys.findMatchingKeyListener(keyboardEvent, [description], keyCode), description)
                || this.descriptionFromKeyListener(gwKeys_1.gwKeys.findMatchingKeyListener(keyboardEvent, gwKeys_1.gwKeys.genericKeyReactors, keyCode), description)
                || this.descriptionFromKeyListener(gwKeys_1.gwKeys.findMatchingContextualKeyListener(keyboardEvent, node, keyCode), description)
                || this.descriptionFromKeyListener(gwKeys_1.gwKeys.findMatchingServerShortcutKeyListener(keyboardEvent, keyCode), description)
                || this.descriptionFromKeyListener(gwKeys_1.gwKeys.findMatchingKeyListener(keyboardEvent, gwKeys_1.gwKeys.globalShortcutKeyListeners, keyCode), description);
        }
        else {
            return description.methodName ? description : null;
        }
    };
    /**
     * @private
     * Creates an initial event description containing the eventTargetNode, id and suffix fields.
     * @param node target of the event
     * @returns {{eventTargetNode: node, id: string, suffix: string}}
     */
    GwEventDescription.createBasicEventDescription = function (node) {
        var evtDescription = new GwEventDescription(node);
        evtDescription.suffix = gwEvents_1.gwEvents.actionSuffix;
        return evtDescription;
    };
    /**
     * @private
     * Takes the node and a string describing an event and returns an event description object containing
     * the target node, the name of the method to be executed plus arguments to the method. Defines the
     * methodName as the first whole word it finds and then parses the remaining string. For example:
     * "fireEvent arg1:foo arg2:bar" would become {methodName: "fireEvent", arg1: "foo", arg2: "bar"}
     * where the colon is used to as the delimiter to determine key and value.
     *
     * If the string following the method name has no colon, then the entire string is returned as a
     * single unnamed argument, for example {unnamedArgs: wholeString}.
     *
     * By default sets the field "suffix" to the global action suffix and the field "id" to be the id of the
     * target node. These can be overridden by explicit arguments in the event string
     *
     * Returns null if the event string is null, undefined or empty
     *
     * @param node the target node of the event
     * @param eventString description of the event
     *
     * @returns {{eventTargetNode: node, id: string, suffix: string, methodName: string}}
     */
    GwEventDescription.parseEventDescription = function (node, eventString) {
        if (!eventString || eventString === "") {
            return null;
        }
        var description = this.createBasicEventDescription(node);
        var firstSpaceIndex = eventString.indexOf(" ");
        if (firstSpaceIndex === -1) {
            description.methodName = eventString;
            return description;
        }
        description.methodName = eventString.substring(0, firstSpaceIndex);
        var totalStr = eventString.substring(firstSpaceIndex + 1);
        if (totalStr.indexOf(":") === -1) {
            // There is no colon in this arg string, so we assume it's a custom string for the method
            description.unnamedArgs = totalStr;
            return description;
        }
        var c, keyEnd, keyStart, i, valueStart, value, key;
        var valueEnd = totalStr.length;
        var lookingForKey = false;
        // This clumsy looking algorithm is just going to walk the string backwards pairing up argName: with trailing space separated args.
        // It's actually better time and memory than less clumsy looking ones, since javascript doesn't have incremental repeated regex capture groups.
        // So "toggle: class1 class2 class3 target: class4" becomes: map = {toggle: "class1 class2 class3", target: "class4"};
        for (i = totalStr.length - 1; i >= 0; i--) {
            c = totalStr[i];
            if (c === ":") {
                lookingForKey = true;
                valueStart = i + 1;
                keyEnd = i;
                continue;
            }
            if (i === 0 || (lookingForKey && c === " ")) {
                keyStart = i ? i + 1 : i;
                value = totalStr.substring(valueStart || 0, valueEnd);
                // We specifically look for the string 'null' to allow the server to prevent default client settings like action suffix
                value = value === "null" ? "" : value;
                key = totalStr.substring(keyStart, keyEnd);
                if (key === "id" && value === "^") {
                    value = $(node).parents("[id]")[0].id;
                }
                description[key] = value; //TODO: figure out how to handle this more cleanly than defining an any type sig on eventDescription
                valueEnd = i;
                lookingForKey = false;
            }
        }
        // Just some silliness to allow for key related arguments to be specified in multiple forms, for
        // example either key:x or keyCode:x will result in keyCode:x in the parsed description
        description.keyCode = description.keyCode || description.key;
        description.shift = description.shift || description.shiftKey;
        description.alt = description.alt || description.altKey;
        description.ctrl = description.ctrl || description.ctrlKey;
        description.meta = description.meta || description.metaKey;
        return description;
    };
    /**
     * Given a key listener (or null) plus an initial event description return a completed event description
     * based on the key listener. Returns null if the key listener is null or if the listener cannot create
     * an event description.
     *
     * If the key listener just contains a method name, then the returned description will be the initial
     * description plus the method name and, possibly, enableDefault. If the key listener knows how to create
     * its own event description then that new description is returned.
     *
     * @param keyListener possibly null key listener
     * @param initialEventDescription event description containing at least target node and basic fields
     * @returns {*}
     */
    GwEventDescription.descriptionFromKeyListener = function (keyListener, initialEventDescription) {
        var description = initialEventDescription;
        if (!keyListener) {
            return null;
        }
        if (keyListener.createEventDescription === "reactors") {
            description = keyListener.applyReactorsForKeyEvent(initialEventDescription.eventTargetNode);
            if (!description) {
                return null;
            }
        }
        else if (keyListener.createEventDescription === "server") {
            description = keyListener.serverShortcut();
            if (!description) {
                return null;
            }
        }
        else {
            description.methodName = keyListener.methodName;
        }
        description.enableDefault = keyListener.enableDefault;
        return description;
    };
    return GwEventDescription;
}(GwKeyListener_1.GwKeyListener));
exports.GwEventDescription = GwEventDescription;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwPreferences = /** @class */ (function (_super) {
    __extends(GwPreferences, _super);
    function GwPreferences() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.serverPrefs = {};
        _this.alteredPrefs = {};
        _this.PREF_STATE_DIV_ID = "gw-preferenceState";
        _this.PREF_INPUT_ID_SELECTOR = "#gw-util--preferences";
        _this.PREF_DIV_ID = "gw-preferences";
        return _this;
    }
    GwPreferences.prototype.getSystemName = function () {
        return "gwPreferences";
    };
    // private applyPreferenceFunctions: GwMap = {};
    // /**
    //  * @public
    //  * Allows widget types to be registered against a function used to apply preferences for that widget
    //  */
    // registerApplyPreferenceFunction (widgetType: string, applyPreferenceFunc: string): void {
    //     this.applyPreferenceFunctions[widgetType] = applyPreferenceFunc;
    // }
    /**
     * Stores the given key/value preference under the supplied renderId.
     * These settings are not sent to the server until the next full request.
     */
    GwPreferences.prototype.storePreference = function (renderId, key, value, preferenceType) {
        if (!this.alteredPrefs.hasOwnProperty(renderId)) {
            this.alteredPrefs[renderId] = {};
        }
        this.alteredPrefs[renderId].prefType = preferenceType;
        this.alteredPrefs[renderId][key] = value;
    };
    GwPreferences.prototype.getPreference = function (renderId, key) {
        if (this.alteredPrefs.hasOwnProperty(renderId) && this.alteredPrefs[renderId].hasOwnProperty(key)) {
            return gwUtil_1.gwUtil.convertIfString(this.alteredPrefs[renderId][key]);
        }
        if (this.serverPrefs.hasOwnProperty(renderId) && this.serverPrefs[renderId].hasOwnProperty(key)) {
            return gwUtil_1.gwUtil.convertIfString(this.serverPrefs[renderId][key]);
        }
        return null;
    };
    GwPreferences.prototype.getPreferences = function (renderId) {
        var prefs = {};
        if (this.serverPrefs.hasOwnProperty(renderId)) {
            gwUtil_1.gwUtil.forEach(this.serverPrefs[renderId], function (val, key) {
                prefs[renderId][key] = val;
            });
        }
        if (this.alteredPrefs.hasOwnProperty(renderId)) {
            gwUtil_1.gwUtil.forEach(this.alteredPrefs[renderId], function (val, key) {
                prefs[renderId][key] = val;
            });
        }
        return prefs;
    };
    GwPreferences.prototype.forcePersistPreferencesToServer = function () {
        gwUtil_1.gwUtil.refresh();
    };
    GwPreferences.prototype.hasPreferencesOfType = function (prefTypeKey) {
        for (var renderId in this.alteredPrefs) {
            if (this.alteredPrefs[renderId].prefType === prefTypeKey) {
                return true;
            }
        }
        for (var renderId in this.serverPrefs) {
            if (this.serverPrefs[renderId].prefType === prefTypeKey) {
                return true;
            }
        }
        return false;
    };
    /**
     * Called before a request is sent to the server, adding a hidden input
     * to send the changed preferences to the server, if necessary.
     */
    GwPreferences.prototype.beforeServerRequest = function () {
        if (Object.keys(this.alteredPrefs).length > 0) {
            gwUtil_1.gwUtil.getInputElement(this.PREF_INPUT_ID_SELECTOR).value = JSON.stringify(this.alteredPrefs);
        }
    };
    /**
     * Called after a request to the server is complete, flushing the preferences if necessary.
     */
    GwPreferences.prototype.orderSpecificInit = function () {
        gwUtil_1.gwUtil.getInputElement(this.PREF_INPUT_ID_SELECTOR).value = "";
        if (gwUtil_1.gwUtil.getUtilityFlag(this.PREF_STATE_DIV_ID)) {
            //Only clear the preferences if the dom node is there and its value is true
            this.clearPrefs();
        }
        //refresh the server preferences
        var preferences = gwUtil_1.gwUtil.getUtilityJson(this.PREF_DIV_ID);
        if (preferences) {
            this.serverPrefs = preferences;
        }
        else {
            this.serverPrefs = {};
        }
    };
    // applyPreferences (): void {
    //      gwUtil.forEach(Object.keys(this.applyPreferenceFunctions), (prefKeyType) => {
    //         if (this.hasPreferencesOfType(prefKeyType)) {
    //             this.applyPreferenceFunctions[prefKeyType]();
    //         }
    //     });
    // }
    /**
     * Clears the altered preferences object
     */
    GwPreferences.prototype.clearPrefs = function () {
        this.alteredPrefs = {};
    };
    GwPreferences.prototype.resetPreferencesForId = function (id) {
        this.clearPrefs();
        gwUtil_1.gwUtil.setEventParam("resetPreferences", id);
        gwUtil_1.gwUtil.fireEvent("_refresh_");
    };
    return GwPreferences;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwPreferences = GwPreferences;
exports.gwPreferences = new GwPreferences();


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__namespaces__ = __webpack_require__(90);



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */] && document.documentElement.namespaceURI === __WEBPACK_IMPORTED_MODULE_1__namespaces__["b" /* xhtml */]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
});


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_timer__ = __webpack_require__(100);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_timeout__ = __webpack_require__(313);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_timeout__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_interval__ = __webpack_require__(314);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__src_interval__["a"]; });







/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tweenValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(14);


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(node, id).value[name];
  };
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(108);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = rotateRadians;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compose__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);



function rotationIdentity(lambda, phi) {
  return [lambda > __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] ? lambda - __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */] : lambda < -__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] ? lambda + __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */] : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */]) ? (deltaPhi || deltaGamma ? Object(__WEBPACK_IMPORTED_MODULE_0__compose__["a" /* default */])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] ? lambda - __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */] : lambda < -__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] ? lambda + __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */] : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(deltaPhi),
      sinDeltaPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(deltaPhi),
      cosDeltaGamma = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(deltaGamma),
      sinDeltaGamma = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi),
        x = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(lambda) * cosPhi,
        y = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(lambda) * cosPhi,
        z = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      Object(__WEBPACK_IMPORTED_MODULE_1__math__["e" /* atan2 */])(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      Object(__WEBPACK_IMPORTED_MODULE_1__math__["c" /* asin */])(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi),
        x = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(lambda) * cosPhi,
        y = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(lambda) * cosPhi,
        z = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      Object(__WEBPACK_IMPORTED_MODULE_1__math__["e" /* atan2 */])(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      Object(__WEBPACK_IMPORTED_MODULE_1__math__["c" /* asin */])(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ __webpack_exports__["a"] = (function(rotate) {
  rotate = rotateRadians(rotate[0] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], rotate[1] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], rotate.length > 2 ? rotate[2] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */] : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], coordinates[1] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */]);
    return coordinates[0] *= __WEBPACK_IMPORTED_MODULE_1__math__["h" /* degrees */], coordinates[1] *= __WEBPACK_IMPORTED_MODULE_1__math__["h" /* degrees */], coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], coordinates[1] * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */]);
    return coordinates[0] *= __WEBPACK_IMPORTED_MODULE_1__math__["h" /* degrees */], coordinates[1] *= __WEBPACK_IMPORTED_MODULE_1__math__["h" /* degrees */], coordinates;
  };

  return forward;
});


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clipRectangle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__buffer__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__line__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rejoin__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_array__ = __webpack_require__(9);






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(p[0] - x0) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */] ? direction > 0 ? 0 : 3
        : Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(p[0] - x1) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */] ? direction > 0 ? 2 : 1
        : Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(p[1] - y0) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */] ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = Object(__WEBPACK_IMPORTED_MODULE_1__buffer__["a" /* default */])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = Object(__WEBPACK_IMPORTED_MODULE_4_d3_array__["n" /* merge */])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          Object(__WEBPACK_IMPORTED_MODULE_3__rejoin__["a" /* default */])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (Object(__WEBPACK_IMPORTED_MODULE_2__line__["a" /* default */])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = transformer;
/* harmony default export */ __webpack_exports__["a"] = (function(methods) {
  return {
    stream: transformer(methods)
  };
});

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
});


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__request__ = __webpack_require__(117);


/* harmony default export */ __webpack_exports__["a"] = (function(defaultMimeType, response) {
  return function(url, callback) {
    var r = Object(__WEBPACK_IMPORTED_MODULE_0__request__["a" /* default */])(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
});


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = deinterpolateLinear;
/* harmony export (immutable) */ __webpack_exports__["a"] = copy;
/* harmony export (immutable) */ __webpack_exports__["b"] = continuous;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constant__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(195);






var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["a" /* default */])(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["b" /* bisect */])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["a" /* interpolate */],
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_2__array__["a" /* map */].call(_, __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_2__array__["b" /* slice */].call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = __WEBPACK_IMPORTED_MODULE_2__array__["b" /* slice */].call(_), interpolate = __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["r" /* interpolateRound */], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_interval__ = __webpack_require__(7);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_0__src_interval__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_millisecond__ = __webpack_require__(470);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_second__ = __webpack_require__(471);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_minute__ = __webpack_require__(472);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_3__src_minute__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_3__src_minute__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_hour__ = __webpack_require__(473);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_4__src_hour__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_4__src_hour__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_day__ = __webpack_require__(474);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_5__src_day__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_5__src_day__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_week__ = __webpack_require__(475);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["m"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["n"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_month__ = __webpack_require__(476);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_7__src_month__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_7__src_month__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_year__ = __webpack_require__(477);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_8__src_year__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_8__src_year__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__ = __webpack_require__(478);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_utcHour__ = __webpack_require__(479);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcHour__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcHour__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_utcDay__ = __webpack_require__(480);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_11__src_utcDay__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_11__src_utcDay__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__ = __webpack_require__(481);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_5", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_6", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_1", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_2", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_3", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["m"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_4", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["n"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_0", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__ = __webpack_require__(482);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_utcYear__ = __webpack_require__(483);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_7", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utcYear__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_8", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utcYear__["b"]; });































/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new Linear(context);
});


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {});


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = point;
/* harmony export (immutable) */ __webpack_exports__["a"] = Basis;
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["b"] = (function(context) {
  return new Basis(context);
});


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = point;
/* harmony export (immutable) */ __webpack_exports__["a"] = Cardinal;
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["b"] = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwConfig = /** @class */ (function (_super) {
    __extends(GwConfig, _super);
    function GwConfig() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.values = {};
        return _this;
    }
    GwConfig.prototype.getSystemName = function () {
        return "gwConfig";
    };
    GwConfig.prototype.orderSpecificInit = function (isFullPageReload) {
        if (isFullPageReload) {
            this.values = $("body").data("gw-config");
        }
    };
    GwConfig.prototype.serverTimeoutMillis = function () {
        return this.values.timeout * 1000;
    };
    GwConfig.prototype.prefPanelDefaults = function () {
        return this.values.prefPanelDefaults;
    };
    /** Only used for testing */
    GwConfig.prototype._setServerTimeoutSeconds = function (seconds) {
        this.values.timeout = seconds;
    };
    return GwConfig;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwConfig = GwConfig;
exports.gwConfig = new GwConfig();


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwInputs_1 = __webpack_require__(5);
var gwTooltips_1 = __webpack_require__(56);
/**
 * - Helptext can only appear on an input widget in edit mode.
 * - Helptext always appears when focusing on the input.
 * - But there is a global config option on the server that allows it to also appear as a tooltip on mouseover.
 * If this is enabled, then the helptext appears as the data-gw-tooltip attribute,
 * but the tooltip is removed temporarily when the element is focused, so that you don't have the text up in 2 places.
 */
var GwHelpText = /** @class */ (function () {
    function GwHelpText() {
        this.HELP_TEXT_EL_ID = "gw-helptext";
        this.HELP_TEXT_OPEN = "gw-helptextOpen";
        this.DATA_HELPTEXT = "data-gw-helptext";
        this.DATA_HIDDEN_TOOLTIP = "data-gw-hidden-tooltip";
    }
    GwHelpText.prototype.focusIn = function (input) {
        if (gwInputs_1.gwInputs.inputType(input)) {
            this.enableHelptextOnInputIfAvailable(input);
        }
    };
    GwHelpText.prototype.focusOut = function () {
        this.disableHelpText();
    };
    GwHelpText.prototype.closeHelpText = function () {
        this.disableHelpText();
    };
    GwHelpText.prototype.enableHelptextOnInputIfAvailable = function (input) {
        this.disableHelpText();
        //Go up until we find a value widget, or bail
        var valueWidget = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(input, "gw-ValueWidget");
        if (!valueWidget ||
            valueWidget.hasAttribute("data-gw-no-helptext-drop") ||
            valueWidget.hasAttribute("data-gw-hideHelptext")) {
            return;
        }
        var helptext = valueWidget.getAttribute(this.DATA_HELPTEXT);
        var tooltext = valueWidget.getAttribute(gwTooltips_1.gwTooltips.DATA_TOOLTIP);
        if (helptext || tooltext) {
            // If it has a helptext as tooltip, remove it temporarily while help text is being displayed.
            if (tooltext) {
                valueWidget.setAttribute(this.DATA_HIDDEN_TOOLTIP, tooltext);
                valueWidget.removeAttribute(gwTooltips_1.gwTooltips.DATA_TOOLTIP);
                gwTooltips_1.gwTooltips.hide();
            }
            this.addHelptextElToNode(valueWidget, input, helptext || tooltext || "");
        }
    };
    GwHelpText.prototype.addHelptextElToNode = function (valueWidget, input, text) {
        var helptextEl = gwUtil_1.gwUtil.createDiv(null, { id: this.HELP_TEXT_EL_ID }, { maxWidth: valueWidget.offsetWidth + "px" });
        helptextEl.innerHTML = text;
        gwUtil_1.gwUtil.addClass(valueWidget, this.HELP_TEXT_OPEN);
        valueWidget.appendChild(helptextEl);
        gwInputs_1.gwInputs.preventPickerBeingOffscreen(valueWidget, input, helptextEl);
    };
    GwHelpText.prototype.disableHelpText = function () {
        var helptextEl = document.getElementById(this.HELP_TEXT_EL_ID);
        if (helptextEl) {
            var owner = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(helptextEl, this.HELP_TEXT_OPEN);
            if (owner) {
                if (owner.hasAttribute(this.DATA_HIDDEN_TOOLTIP)) {
                    owner.setAttribute(gwTooltips_1.gwTooltips.DATA_TOOLTIP, owner.getAttribute(this.DATA_HIDDEN_TOOLTIP) || "");
                    owner.removeAttribute(this.DATA_HIDDEN_TOOLTIP);
                }
                gwUtil_1.gwUtil.removeClass(owner, this.HELP_TEXT_OPEN);
            }
            helptextEl.parentNode.removeChild(helptextEl);
        }
    };
    return GwHelpText;
}());
exports.GwHelpText = GwHelpText;
exports.gwHelpText = new GwHelpText();


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwPoint_1 = __webpack_require__(59);
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var gw_1 = __webpack_require__(10);
var GwRegisteredSystem_1 = __webpack_require__(2);
/**
 * @public
 * Handles all events triggered by the global events mapped to dragstart, drag, and dragend.
 * To register a system for drag, the element just needs a data-gw-draggable="SystemName" attribute.
 * When the various drag events are triggered, then corresponding methods will be called on the system:
 * ie:
 * gw[SystemName].dragstart
 * gw[SystemName].drag
 * gw[SystemName].dragend
 * (Optional)gw[SystemName].dragcancel (if not present, and a cancel condition fires, then dragend will be fired)
 *
 * e.g. if you had data-gw-draggable="SouthPanel" then a drag operation would call:
 * gw.SouthPanel.dragStart(el, args, e)
 * gw.SouthPanel.drag(el, args, e) - maybe multiple times
 * gw.SouthPanel.dragEnd(el, args, e)
 * gw.SouthPanel.dragCancel(el, args, e) - is Optional, and dragEnd will fire if no drag cancel is found
 * @type {{}}
 */
var GwDraggable = /** @class */ (function (_super) {
    __extends(GwDraggable, _super);
    function GwDraggable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.DRAG_ATTR = "data-gw-draggable";
        _this.beingDragged = null;
        _this.surrenderMouseMoveOwnership = null;
        _this.cursorOffset = null;
        _this.mousePos = null;
        _this.dragHoverInterval = -1;
        _this.currentDraggingSystemName = null;
        _this.dragHoverEnabled = false;
        return _this;
    }
    GwDraggable.prototype.getSystemName = function () {
        return "gwDraggable";
    };
    /**
     * Returns the object currently being dragged. This is important, because we use mouse events to trigger dragging.
     * So the drag and drag end methods will pass the beingDragged element into the corresponding system methods,
     * since the events themselves, may not have the dragged element as the target of the event, like if the user has moved
     * the mouse quickly, etc.
     * @returns {*}
     */
    GwDraggable.prototype.getBeingDragged = function () {
        return this.beingDragged;
    };
    GwDraggable.prototype.isDragging = function () {
        return !!this.beingDragged;
    };
    /**
     * And individual system needs to call this, most likely inside of dragStart,
     * in order to receive calls to the drag method every frame, even if the mouse isn't moving.
     * This is so systems can do things like "scroll the screen" while the user hovers the mouse near the edge.
     */
    GwDraggable.prototype.enableDragHover = function () {
        this.dragHoverEnabled = true;
    };
    GwDraggable.prototype.storeMousePos = function (el, e) {
        this.mousePos = gwUtil_1.gwUtil.getMousePosition(el, e);
    };
    /**
     * calls gw[el.getAttributeName("data-gw-draggable")].dragStart(el, args, e);
     * @param el
     * @param args
     * @param e
     */
    GwDraggable.prototype.start = function (el, args, e) {
        var _this = this;
        if (this.isDragging()) {
            return;
        }
        if (!el.hasAttribute(this.DRAG_ATTR)) {
            return;
        }
        gwEvents_1.gwEvents.closeAllTemporaryUIElements();
        this.beingDragged = el;
        gwUtil_1.gwUtil.addClass(this.beingDragged, "gw-beingDragged");
        this.storeCursorOffset(e);
        this.surrenderMouseMoveOwnership = gwEvents_1.gwEvents.setMouseMoveOwner(this.drag.bind(this));
        this.currentDraggingSystemName = el.getAttribute(this.DRAG_ATTR).split(" ")[0];
        if (!gw_1.gw.draggable[this.currentDraggingSystemName]) {
            throw new Error("No system exists on the gw draggable object named: " + this.currentDraggingSystemName);
        }
        this.storeMousePos(el, e);
        gw_1.gw.draggable[this.currentDraggingSystemName].dragStart(el, args, e);
        if (this.dragHoverEnabled) {
            this.dragHoverInterval = setInterval(function () {
                if (!_this.dragHoverEnabled || !gwEvents_1.gwEvents.areEventsEnabled()) {
                    window.clearInterval(_this.dragHoverInterval);
                    _this.dragHoverInterval = -1;
                    return;
                }
                gw_1.gw.draggable[_this.currentDraggingSystemName].drag(_this.beingDragged, args, e);
            }, 33);
        }
    };
    /**
     * Called inside of dragStart if the owner system has enabled dragHover.
     * This is so systems can do things like "scroll the screen" while the user hovers the mouse near the edge.
     */
    /**
     * calls gw[el.getAttributeName("data-gw-draggable")].drag(getBeingDragged(), args, e);
     * @param e a mouse move event
     */
    GwDraggable.prototype.drag = function (e) {
        if (!this.beingDragged) {
            return;
        }
        this.storeMousePos(this.beingDragged, e);
        gw_1.gw.draggable[this.currentDraggingSystemName].drag(this.beingDragged, {}, e);
    };
    /**
     * calls gw[el.getAttributeName("data-gw-draggable")].dragend(getBeingDragged(), args, e);
     * @param el
     * @param args
     * @param e
     */
    GwDraggable.prototype.end = function (el, args, e) {
        this.abstractDragEndedOrCanceled(el, args, e, false);
    };
    /**
     * calls gw[el.getAttributeName("data-gw-draggable")].dragcancel(getBeingDragged(), args, e);
     * @param el
     * @param args
     * @param e
     */
    GwDraggable.prototype.cancel = function (el, args, e) {
        this.abstractDragEndedOrCanceled(el, args, e, true);
    };
    GwDraggable.prototype.abstractDragEndedOrCanceled = function (el, args, e, isCancel) {
        if (isCancel === void 0) { isCancel = false; }
        if (!this.beingDragged) {
            return;
        }
        window.clearInterval(this.dragHoverInterval);
        this.dragHoverInterval = -1;
        this.dragHoverEnabled = false;
        gwUtil_1.gwUtil.removeClass(this.beingDragged, "gw-beingDragged");
        var systemName = this.currentDraggingSystemName || this.beingDragged.getAttribute(this.DRAG_ATTR) || "undefined";
        if (!gw_1.gw.draggable[systemName]) {
            throw new Error("unable to locate draggable system " + systemName);
        }
        if (isCancel) {
            gw_1.gw.draggable[systemName].dragCancel(this.beingDragged, args, e);
        }
        else {
            gw_1.gw.draggable[systemName].dragEnd(this.beingDragged, args, e);
        }
        this.mousePos = null;
        this.beingDragged = null;
        this.currentDraggingSystemName = null;
        this.storeCursorOffset(e);
        if (this.surrenderMouseMoveOwnership) {
            this.surrenderMouseMoveOwnership();
        }
        this.surrenderMouseMoveOwnership = null;
    };
    GwDraggable.prototype.storeCursorOffset = function (e) {
        if (e == null) {
            this.cursorOffset = GwPoint_1.GwPoint.ZERO;
        }
        else {
            this.cursorOffset = new GwPoint_1.GwPoint(e.offsetX, e.offsetY);
        }
    };
    /**
     * returns a vector with the original offset of the cursor position relative to the 0,0 of the dragged object.
     */
    GwDraggable.prototype.getCursorOffset = function () {
        return this.cursorOffset;
    };
    GwDraggable.prototype.getCurrentMousePos = function () {
        return this.mousePos;
    };
    return GwDraggable;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwDraggable = GwDraggable;
exports.gwDraggable = new GwDraggable();


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gw_1 = __webpack_require__(10);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwDraggableSystem = /** @class */ (function (_super) {
    __extends(GwDraggableSystem, _super);
    function GwDraggableSystem() {
        var _this = _super.call(this) || this;
        if (_this.availableToDraggable()) {
            gw_1.gw.registerDraggableSystem(_this);
        }
        return _this;
    }
    GwDraggableSystem.prototype.availableToDraggable = function () {
        return true;
    };
    return GwDraggableSystem;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwDraggableSystem = GwDraggableSystem;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwTypes_1 = __webpack_require__(20);
var gwDatePickerHelper_1 = __webpack_require__(41);
var gwUtil_1 = __webpack_require__(0);
var GwEraDetail_1 = __webpack_require__(231);
var GwJicHelper = /** @class */ (function () {
    function GwJicHelper() {
        this.eraYearLocalizedSuffix = " Year"; //Updated if available in mapEraDataFromServer
        this.eraMonthLocalizedSuffix = "";
        this.highestEraOrder = 0; // in mapEraDataFromServer
        this.eraOrderIndexToDetails = {}; // in mapEraDataFromServer
        this.eraQuickToDetails = {}; // in mapEraDataFromServer
    }
    GwJicHelper.prototype.mapEraDataFromServer = function () {
        var eraArray = gwUtil_1.gwUtil.getUtilityJson("gw-eraInfo");
        if (!eraArray || eraArray.length === 0) {
            return;
        }
        for (var i = 0; i < eraArray.length; i++) {
            var era = eraArray[i];
            var eraDetail = new GwEraDetail_1.GwEraDetail(era);
            this.eraOrderIndexToDetails[era.order] = eraDetail;
            this.eraOrderIndexToDetails[era.name] = eraDetail;
            this.highestEraOrder = Math.max(this.highestEraOrder, parseInt(era.order));
        }
        var yearSymbol = eraArray[0].yearSymbol;
        if (yearSymbol) {
            this.eraYearLocalizedSuffix = yearSymbol;
        }
        var monthSymbol = eraArray[0].monthSymbol;
        if (monthSymbol) {
            this.eraMonthLocalizedSuffix = monthSymbol;
        }
        this.eraQuickToDetails.M = this.eraOrderIndexToDetails[1];
        this.eraQuickToDetails.T = this.eraOrderIndexToDetails[2];
        this.eraQuickToDetails.S = this.eraOrderIndexToDetails[3];
        this.eraQuickToDetails.H = this.eraOrderIndexToDetails[4];
    };
    GwJicHelper.prototype.getInst = function () {
        return (gwDatePickerHelper_1.gwDatePickerHelper._currInst || {});
    };
    GwJicHelper.prototype.getDateWidget = function (el) {
        var dw = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(el || this.getDateInput(), "gw-DateValueWidget");
        if (!dw) {
            throw new Error("Unable to locate a date widget connected to the Imperial Calendar.");
        }
        return dw;
    };
    GwJicHelper.prototype.getEraInput = function (el) {
        return this.getDateWidget(el).querySelector(".gw-DateValueWidget--era");
    };
    GwJicHelper.prototype.getTotalYearsForCurrentEraSelect = function (el) {
        var eraSelect = this.getEraSelect(el);
        if (!eraSelect) {
            return 0;
        }
        var eraDetails = this.getEraDetailsForValueOrOrder(eraSelect.value);
        if (eraDetails) {
            return eraDetails.total;
        }
        return 0;
    };
    GwJicHelper.prototype.getMonthSelect = function (el) {
        return this.getDateWidget(el).querySelector("#gw-datePicker--month--select");
    };
    GwJicHelper.prototype.getEraYearSelect = function (el) {
        return this.getDateWidget(el).querySelector("#gw-datePicker--eraYear--select");
    };
    GwJicHelper.prototype.getEraSelect = function (el) {
        return this.getDateWidget(el).querySelector("#gw-datePicker--era--select");
    };
    GwJicHelper.prototype.getDateInput = function () {
        return this.getInst().inputEl;
    };
    GwJicHelper.prototype.getEraValueForToday = function () {
        return this.eraOrderIndexToDetails[this.highestEraOrder].name;
    };
    GwJicHelper.prototype.setEraValueFromPaste = function (eraVal, dateInput) {
        this.setEraInputValue(eraVal, dateInput);
    };
    GwJicHelper.prototype.setEraYearSelect = function (eraYear) {
        this.getInst().eraYear = eraYear;
        var eraYearSelect = this.getEraYearSelect(null);
        if (eraYearSelect) {
            gwUtil_1.gwUtil.setOptionOnSelect(eraYearSelect, eraYear + "");
        }
    };
    GwJicHelper.prototype.setEraSelect = function (eraValOrOrder, dateInput) {
        if (dateInput === void 0) { dateInput = null; }
        var eraDetail = this.getEraDetailsForValueOrOrder(eraValOrOrder);
        if (eraDetail) {
            var eraSelect = this.getEraSelect(dateInput);
            if (eraSelect) {
                gwUtil_1.gwUtil.setOptionOnSelect(eraSelect, eraDetail.name);
            }
        }
    };
    GwJicHelper.prototype.setEraInputValue = function (eraValOrOrder, dateInput) {
        if (dateInput === void 0) { dateInput = null; }
        var eraDetail = this.getEraDetailsForValueOrOrder(eraValOrOrder);
        if (eraDetail) {
            var eraInput = this.getEraInput(dateInput);
            if (eraInput) {
                eraInput.value = eraDetail.name;
            }
        }
    };
    GwJicHelper.prototype.getEraInputValue = function (el) {
        var eraInput = this.getEraInput(el);
        if (!eraInput) {
            return null;
        }
        return eraInput.value;
    };
    GwJicHelper.prototype.getEraDetailsForValueOrOrderOrThrow = function (eraValOrOrder) {
        var eraDetail = this.getEraDetailsForValueOrOrder(eraValOrOrder);
        if (!eraDetail) {
            throw new Error("unable to locate era detail information for: " + eraValOrOrder);
        }
        return eraDetail;
    };
    GwJicHelper.prototype.getEraDetailsForValueOrOrder = function (eraValOrOrder) {
        if (eraValOrOrder === undefined) {
            return this.eraOrderIndexToDetails[this.getEraValueForToday()];
        }
        var eraDetail = this.eraOrderIndexToDetails[eraValOrOrder];
        if (eraDetail) {
            return eraDetail;
        }
        if (typeof eraValOrOrder === "string") {
            eraDetail = this.eraQuickToDetails[eraValOrOrder[0].toUpperCase()];
            if (eraDetail) {
                return eraDetail;
            }
            gwUtil_1.gwUtil.forEach(this.eraOrderIndexToDetails, function (detail) {
                if (eraValOrOrder.localeCompare(detail.name, undefined, { sensitivity: "base" }) === 0) {
                    eraDetail = detail;
                    return gwTypes_1.GW_BREAKER;
                }
                return;
            });
        }
        return eraDetail || null;
    };
    GwJicHelper.prototype.eraYearToGregYear = function (eraYear, useEraSelectForValue) {
        if (useEraSelectForValue === void 0) { useEraSelectForValue = false; }
        var eraVal;
        if (useEraSelectForValue) {
            eraVal = this.getEraSelectValue();
        }
        else {
            eraVal = this.getEraInputValue(null) || this.getEraValueForToday();
        }
        var eraDetail = this.getEraDetailsForValueOrOrderOrThrow(eraVal);
        eraYear = +eraYear || this.gregYearToEraYear(new Date()); //Get today's date as an era year, if eraYear is null
        return eraYear + eraDetail.delta;
    };
    GwJicHelper.prototype.gregYearToEraYear = function (gregDateObj, forceUpdate) {
        if (forceUpdate === void 0) { forceUpdate = false; }
        var jicYear = 1;
        for (var i = this.highestEraOrder; i >= 0; i--) {
            var detail = this.eraOrderIndexToDetails[i];
            if (gregDateObj >= detail.start) {
                jicYear = gregDateObj.getFullYear() - detail.delta;
                if (forceUpdate) {
                    //setEraInputValue(i);
                    this.setEraYearSelect(jicYear);
                    this.setEraSelect(i);
                }
                break;
            }
        }
        var jicYearStr = "" + jicYear;
        if (jicYearStr.length < 2) {
            jicYearStr = "0" + jicYearStr;
        }
        return +jicYearStr;
    };
    GwJicHelper.prototype.getEraSelectValue = function () {
        var eraSelect = this.getEraSelect(null);
        if (!eraSelect) {
            eraSelect = this.getEraInput(null);
        }
        var eraName;
        if (eraSelect) {
            eraName = eraSelect.value;
        }
        var finalEraName = eraName || this.getEraValueForToday();
        return finalEraName;
    };
    return GwJicHelper;
}());
exports.GwJicHelper = GwJicHelper;
exports.gwJicHelper = new GwJicHelper();


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwEventDescription_1 = __webpack_require__(61);
var gwEvents_1 = __webpack_require__(3);
var gwKeys_1 = __webpack_require__(23);
var GwKeyListener = /** @class */ (function () {
    function GwKeyListener(keyCode) {
        this.internalTool = false;
        this.meta = false;
        this.ctrl = false;
        this.shift = false;
        this.alt = false;
        this.enableDefault = false;
        this.methodName = undefined;
        this.reactors = undefined;
        this.contextClass = undefined;
        this.eventType = "key";
        this.openMenuOnShortcut = false;
        this.keyCode = keyCode;
    }
    GwKeyListener.prototype.withServerEventId = function (id) {
        this.serverEventId = id;
        return this;
    };
    GwKeyListener.prototype.withOpenMenuOnShortcut = function (bool) {
        this.openMenuOnShortcut = bool;
        return this;
    };
    GwKeyListener.prototype.withShortcutKey = function (key) {
        this.shortcutKey = key;
        return this;
    };
    GwKeyListener.prototype.withMeta = function () {
        this.meta = true;
        return this;
    };
    GwKeyListener.prototype.withAlt = function () {
        this.alt = true;
        return this;
    };
    GwKeyListener.prototype.withInternalTool = function () {
        this.internalTool = true;
        return this;
    };
    GwKeyListener.prototype.withCtrl = function () {
        this.ctrl = true;
        return this;
    };
    GwKeyListener.prototype.withShift = function () {
        this.shift = true;
        return this;
    };
    GwKeyListener.prototype.withEnableDefault = function () {
        this.enableDefault = true;
        return this;
    };
    GwKeyListener.prototype.withMethodName = function (name) {
        this.methodName = name;
        return this;
    };
    GwKeyListener.prototype.withReactors = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.reactors = args;
        return this;
    };
    GwKeyListener.prototype.withContextClass = function (cls) {
        this.contextClass = cls;
        return this;
    };
    GwKeyListener.prototype.useCreateEventDescription = function (functionType) {
        this.createEventDescription = functionType;
        return this;
    };
    /**
     * Function used by "reactor" key listeners, which map key presses to specific events (such as click)
     * on the target node. If the target node contains a data attribute containing an appropriate event
     * description then returns the parsed description, otherwise returns null.
     */
    GwKeyListener.prototype.applyReactorsForKeyEvent = function (el) {
        if (!this.reactors) {
            return null;
        }
        for (var i = 0; i < this.reactors.length; i++) {
            var dataAttr = gwEvents_1.gwEvents.dataPrefix + this.reactors[i];
            var description = GwEventDescription_1.GwEventDescription.parseEventDescription(el, el.getAttribute(dataAttr));
            if (description) {
                // Target node has a matching event description; return it
                description.eventType = "key";
                description.replacesClick = this.reactors[i] === "click";
                return description;
            }
        }
        return null;
    };
    GwKeyListener.prototype.serverShortcut = function () {
        var result = null;
        var target = gwKeys_1.gwKeys.findServerShortcutKeyTarget(this.serverEventId);
        if (target) {
            var method = target.dataset.gwShortcut || target.dataset.gwClick || target.dataset.gwKey;
            // If north panel shortcut, then we need to fire open menu instead of event click
            if (this.openMenuOnShortcut) {
                method = "gwMenus.toggleFromShortcut" + " target:#" + this.serverEventId;
            }
            result = GwEventDescription_1.GwEventDescription.parseEventDescription(target, method);
            if (result) {
                result.eventType = "key";
                result.replacesClick = true;
            }
        }
        return result;
    };
    return GwKeyListener;
}());
exports.GwKeyListener = GwKeyListener;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwTypes_1 = __webpack_require__(20);
var gwUtil_1 = __webpack_require__(0);
var gwFocus_1 = __webpack_require__(8);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwNavigation = /** @class */ (function (_super) {
    __extends(GwNavigation, _super);
    function GwNavigation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * An array of objects with two properties,
         * @type {Array}
         */
        _this.navHandlers = [];
        return _this;
    }
    GwNavigation.prototype.getSystemName = function () {
        return "gwNavigation";
    };
    /**
     * @public
     * Makes use of navigation.registerNavFunction to register a handler that will be used if
     * the given CSS class(es) match the node firing the key event.
     *
     * See comment on navigation.registerNavFunction for more.
     * @param cssClasses - String, or String[], of valid css classes
     * @param globalComponentObject - Object, component object stored on the gw global, ie gw.MenuItem
     */
    GwNavigation.prototype.registerNavClasses = function (cssClasses, globalSystem) {
        var _this = this;
        if (Array.isArray(cssClasses)) {
            gwUtil_1.gwUtil.forEach(cssClasses, function (cssClass) {
                _this.addCssMatchFunction(cssClass, globalSystem);
            });
        }
        else {
            this.addCssMatchFunction(cssClasses, globalSystem);
        }
    };
    /**
     * @private
     * A helper method with a default, class-based nav registration function.
     * @param cssClass the class to check
     * @param globalComponentObject the handler
     */
    GwNavigation.prototype.addCssMatchFunction = function (cssClass, globalSystem) {
        this.registerNavFunction(function (node) {
            return gwUtil_1.gwUtil.hasClass(node, cssClass);
        }, globalSystem);
    };
    /**
     * @public
     * Registers a function and handler that are checked when direction keys are pressed.
     * The function determines whether a keypress should be handled by the supplied handler object,
     * which needs to implement the relevant direction method (up, down, left, right).
     *
     * Nav Functions are checked in order of addition, and the first to return true from the "shouldHandle"
     * function will receive the event.
     * @param shouldHandle a function that returns true if the corresponding handler should handle this key event
     * @param globalComponentObject the object that handles the key nav event
     */
    GwNavigation.prototype.registerNavFunction = function (shouldHandle, globalSystem) {
        this.navHandlers.push({
            shouldHandle: shouldHandle,
            handler: globalSystem
        });
    };
    /**
     * @public
     * Forces the focus onto the west panel.
     */
    GwNavigation.prototype.goWest = function () {
        gwFocus_1.gwFocus.forceFocus("#gw-west-panel", true);
    };
    /**
     * @public
     * Forces the focus onto the north panel.
     */
    GwNavigation.prototype.goNorth = function () {
        gwFocus_1.gwFocus.forceFocus("#gw-north-panel", true);
    };
    /**
     * @public
     * Forces the focus onto the center panel.
     */
    GwNavigation.prototype.goCenter = function () {
        gwFocus_1.gwFocus.forceFocus("#gw-center-panel", true);
    };
    /**
     * @public
     * Forces the focus onto the south panel.
     */
    GwNavigation.prototype.goSouth = function () {
        gwFocus_1.gwFocus.forceFocus("#gw-south-panel", true);
    };
    /**
     * @private
     * Takes the node and the navigation method name, ie "down", "left", and determines if there is a component
     * that has registered to handle navigation events by testing the node's css classes.
     * If a handler is found, then it attempts to execute a matching event name on the handler.
     * passing the node and the matched css class. ie: gw.MenuItem.down(node, "gw-action--inner");
     * @param node - DOM Element
     * @param methodName - The method to be executed on the matched component object.
     */
    GwNavigation.prototype.findNavOwnerAndTriggerMethod = function (node, navDir, info, event) {
        var navObject = null;
        gwUtil_1.gwUtil.forEach(this.navHandlers, function (navHandler) {
            if (navHandler.shouldHandle(node, navDir, info, event)) {
                navObject = navHandler.handler;
                return gwTypes_1.GW_BREAKER;
            }
            return;
        });
        if (navObject === null) {
            return;
        }
        if (navDir === 0 /* up */) {
            navObject.up(node, info, event);
        }
        else if (navDir === 1 /* down */) {
            navObject.down(node, info, event);
        }
        else if (navDir === 2 /* left */) {
            navObject.left(node, info, event);
        }
        else {
            navObject.right(node, info, event);
        }
    };
    /**
     * @private
     * This method is registered on the navigation object, soley to be executed by the events system.
     * See registerNavTypes on the navigation object to have a Component register for navigation events.
     * @param node
     */
    GwNavigation.prototype.left = function (node, info, event) {
        this.findNavOwnerAndTriggerMethod(node, 2 /* left */, info, event);
    };
    /**
     * @private
     * This method is registered on the navigation object, soley to be executed by the events system.
     * See registerNavTypes on the navigation object to have a Component register for navigation events.
     * @param node
     */
    GwNavigation.prototype.right = function (node, info, event) {
        this.findNavOwnerAndTriggerMethod(node, 3 /* right */, info, event);
    };
    /**
     * @private
     * This method is registered on the navigation object, soley to be executed by the events system.
     * See registerNavTypes on the navigation object to have a Component register for navigation events.
     * @param node
     */
    GwNavigation.prototype.up = function (node, info, event) {
        this.findNavOwnerAndTriggerMethod(node, 0 /* up */, info, event);
    };
    /**
     * @private
     * This method is registered on the navigation object, soley to be executed by the events system.
     * See registerNavTypes on the navigation object to have a Component register for navigation events.
     * @param node
     */
    GwNavigation.prototype.down = function (node, info, event) {
        this.findNavOwnerAndTriggerMethod(node, 1 /* down */, info, event);
    };
    /**
     * @private
     * Shared helper used by getNextFocusableSibling, and getPrevFocusableSibling.
     * Takes the name of an iterator method on the util global, and a DOM node, and determines returns the first
     * focusable same level sibling that's found "after" the child itself is found. After obviously changes depending
     * on the direction of the iterator method.
     * @param method - string, name of iterator method on gwUtil. Common usages would be forEach and forEachReverse
     * @param child
     * @returns {*}
     */
    GwNavigation.prototype.abstractGetFocusableSibling = function (method, child) {
        if (!child.parentElement) {
            return null;
        }
        var children = child.parentElement.children;
        var foundSelf = false;
        var finalSibling = null;
        //TODO: TS hack
        gwUtil_1.gwUtil[method](children, function (sibling) {
            if (foundSelf && gwFocus_1.gwFocus.isFocusable(sibling, true)) {
                finalSibling = sibling;
                return gwTypes_1.GW_BREAKER;
            }
            if (!foundSelf && sibling === child) {
                foundSelf = true;
            }
            return;
        });
        return finalSibling;
    };
    /**
     * @public
     * Gets the next focusable sibling at the same level in the child's parent;
     * @param child - the element to find the sibling of.
     * @returns {DOM Element}
     */
    GwNavigation.prototype.getNextFocusableSibling = function (child) {
        return this.abstractGetFocusableSibling("forEach", child);
    };
    /**
     * @public
     * Gets the previous focusable sibling at the same level in the child's parent;
     * @param child - the element to find the sibling of.
     * @returns {DOM Element}
     */
    GwNavigation.prototype.getPrevFocusableSibling = function (child) {
        return this.abstractGetFocusableSibling("forEachReverse", child);
    };
    /**
     * @public
     * sets the focus to self or the first parent that passes the gw.navigation.isFocusable test.
     * @param idOrNode - string id or DOM element
     */
    GwNavigation.prototype.setFocusToClosestFocusableSelfOrParent = function (idOrNode) {
        var node = null;
        if (typeof idOrNode === "string") {
            if (idOrNode.indexOf("#") !== 0) {
                idOrNode = "#" + idOrNode;
            }
            node = gwUtil_1.gwUtil.getDomNode(idOrNode);
        }
        else {
            node = idOrNode;
        }
        while (node && node.id !== "gw-body") {
            if (gwFocus_1.gwFocus.isFocusable(node, true)) {
                gwFocus_1.gwFocus.forceFocus(node);
                break;
            }
            node = node.parentElement;
        }
    };
    return GwNavigation;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwNavigation = GwNavigation;
exports.gwNavigation = new GwNavigation();


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(42);


/* harmony default export */ __webpack_exports__["a"] = (function(values, p, valueof) {
  if (valueof == null) valueof = __WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_drag__ = __webpack_require__(262);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_drag__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_nodrag__ = __webpack_require__(153);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_nodrag__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_nodrag__["b"]; });




/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespaces__ = __webpack_require__(90);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */].hasOwnProperty(prefix) ? {space: __WEBPACK_IMPORTED_MODULE_0__namespaces__["a" /* default */][prefix], local: name} : name;
});


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["a"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function none() {}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return event; });
/* harmony export (immutable) */ __webpack_exports__["a"] = customEvent;
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_on__ = __webpack_require__(93);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var current = __WEBPACK_IMPORTED_MODULE_0__selection_on__["c" /* event */], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rgb__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__object__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__string__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constant__ = __webpack_require__(158);









/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(__WEBPACK_IMPORTED_MODULE_7__constant__["a" /* default */])(b)
      : (t === "number" ? __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */]
      : t === "string" ? ((c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]) : __WEBPACK_IMPORTED_MODULE_6__string__["a" /* default */])
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* color */] ? __WEBPACK_IMPORTED_MODULE_1__rgb__["a" /* default */]
      : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date__["a" /* default */]
      : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array__["a" /* default */]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object__["a" /* default */]
      : __WEBPACK_IMPORTED_MODULE_4__number__["a" /* default */])(a, b);
});


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Color;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return brighter; });
/* harmony export (immutable) */ __webpack_exports__["e"] = color;
/* harmony export (immutable) */ __webpack_exports__["h"] = rgbConvert;
/* harmony export (immutable) */ __webpack_exports__["g"] = rgb;
/* harmony export (immutable) */ __webpack_exports__["b"] = Rgb;
/* unused harmony export hslConvert */
/* harmony export (immutable) */ __webpack_exports__["f"] = hsl;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(97);


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Rgb, rgb, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Hsl, hsl, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = extend;
/* harmony default export */ __webpack_exports__["a"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = basis;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["b"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_selection_index__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_transition_index__ = __webpack_require__(21);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transition_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_active__ = __webpack_require__(342);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__src_active__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_interrupt__ = __webpack_require__(163);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__src_interrupt__["a"]; });






/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = now;
/* harmony export (immutable) */ __webpack_exports__["a"] = Timer;
/* harmony export (immutable) */ __webpack_exports__["c"] = timer;
/* harmony export (immutable) */ __webpack_exports__["d"] = timerFlush;
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["a"] = (map);


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dsv__ = __webpack_require__(103);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dsv__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_csv__ = __webpack_require__(357);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_csv__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_tsv__ = __webpack_require__(358);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_2__src_tsv__["b"]; });





/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

/* harmony default export */ __webpack_exports__["a"] = (function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
});


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return (Math.random() - 0.5) * 1e-6;
});


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_quadtree__ = __webpack_require__(362);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_quadtree__["a"]; });



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
});


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__ = __webpack_require__(380);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_locale__ = __webpack_require__(168);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_locale__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__ = __webpack_require__(169);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__ = __webpack_require__(386);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__ = __webpack_require__(387);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__ = __webpack_require__(388);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__["a"]; });








/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = conicEqualAreaRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__conic__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cylindricalEqualArea__ = __webpack_require__(405);




function conicEqualAreaRaw(y0, y1) {
  var sy0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y0), n = (sy0 + Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(n) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]) return Object(__WEBPACK_IMPORTED_MODULE_2__cylindricalEqualArea__["a" /* cylindricalEqualAreaRaw */])(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(c) / n;

  function project(x, y) {
    var r = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(c - 2 * n * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y)) / n;
    return [r * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x *= n), r0 - r * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(x, Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(r0y)) / n * Object(__WEBPACK_IMPORTED_MODULE_0__math__["s" /* sign */])(r0y), Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_1__conic__["a" /* conicProjection */])(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
});


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = conicProjection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(18);



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = __WEBPACK_IMPORTED_MODULE_0__math__["o" /* pi */] / 3,
      m = Object(__WEBPACK_IMPORTED_MODULE_1__index__["b" /* projectionMutator */])(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi1 = _[1] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */]) : [phi0 * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */], phi1 * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */]];
  };

  return p;
}


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = fitExtent;
/* harmony export (immutable) */ __webpack_exports__["c"] = fitSize;
/* harmony export (immutable) */ __webpack_exports__["d"] = fitWidth;
/* harmony export (immutable) */ __webpack_exports__["b"] = fitHeight;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__stream__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__path_bounds__ = __webpack_require__(184);



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  Object(__WEBPACK_IMPORTED_MODULE_0__stream__["a" /* default */])(object, projection.stream(__WEBPACK_IMPORTED_MODULE_1__path_bounds__["a" /* default */]));
  fitBounds(__WEBPACK_IMPORTED_MODULE_1__path_bounds__["a" /* default */].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = mercatorRaw;
/* harmony export (immutable) */ __webpack_exports__["b"] = mercatorProjection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rotation__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




function mercatorRaw(lambda, phi) {
  return [lambda, Object(__WEBPACK_IMPORTED_MODULE_0__math__["n" /* log */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["v" /* tan */])((__WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["d" /* atan */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["k" /* exp */])(y)) - __WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */]];
};

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / __WEBPACK_IMPORTED_MODULE_0__math__["w" /* tau */]);
});

function mercatorProjection(project) {
  var m = Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = __WEBPACK_IMPORTED_MODULE_0__math__["o" /* pi */] * scale(),
        t = m(Object(__WEBPACK_IMPORTED_MODULE_1__rotation__["a" /* default */])(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = hierarchy;
/* harmony export (immutable) */ __webpack_exports__["b"] = computeHeight;
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__count__ = __webpack_require__(419);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__each__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__eachBefore__ = __webpack_require__(421);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__eachAfter__ = __webpack_require__(422);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sum__ = __webpack_require__(423);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sort__ = __webpack_require__(424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__path__ = __webpack_require__(425);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ancestors__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__descendants__ = __webpack_require__(427);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__leaves__ = __webpack_require__(428);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__links__ = __webpack_require__(429);












function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: __WEBPACK_IMPORTED_MODULE_0__count__["a" /* default */],
  each: __WEBPACK_IMPORTED_MODULE_1__each__["a" /* default */],
  eachAfter: __WEBPACK_IMPORTED_MODULE_3__eachAfter__["a" /* default */],
  eachBefore: __WEBPACK_IMPORTED_MODULE_2__eachBefore__["a" /* default */],
  sum: __WEBPACK_IMPORTED_MODULE_4__sum__["a" /* default */],
  sort: __WEBPACK_IMPORTED_MODULE_5__sort__["a" /* default */],
  path: __WEBPACK_IMPORTED_MODULE_6__path__["a" /* default */],
  ancestors: __WEBPACK_IMPORTED_MODULE_7__ancestors__["a" /* default */],
  descendants: __WEBPACK_IMPORTED_MODULE_8__descendants__["a" /* default */],
  leaves: __WEBPACK_IMPORTED_MODULE_9__leaves__["a" /* default */],
  links: __WEBPACK_IMPORTED_MODULE_10__links__["a" /* default */],
  copy: node_copy
};


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = optional;
/* harmony export (immutable) */ __webpack_exports__["b"] = required;
function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return phi; });
/* harmony export (immutable) */ __webpack_exports__["c"] = squarifyRatio;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dice__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slice__ = __webpack_require__(72);



var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) Object(__WEBPACK_IMPORTED_MODULE_0__dice__["a" /* default */])(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else Object(__WEBPACK_IMPORTED_MODULE_1__slice__["a" /* default */])(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

/* harmony default export */ __webpack_exports__["a"] = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi));


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_collection__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_dispatch__ = __webpack_require__(30);



/* harmony default export */ __webpack_exports__["a"] = (function(url, callback) {
  var request,
      event = Object(__WEBPACK_IMPORTED_MODULE_1_d3_dispatch__["a" /* dispatch */])("beforesend", "progress", "load", "error"),
      mimeType,
      headers = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["c" /* map */])(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", …).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", …).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
});

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__ = __webpack_require__(120);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["e"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_locale__ = __webpack_require__(198);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__src_locale__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_isoFormat__ = __webpack_require__(199);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__src_isoFormat__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_isoParse__ = __webpack_require__(484);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__src_isoParse__["a"]; });






/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return timeFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return timeParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return utcFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return utcParse; });
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(198);


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_path__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__curve_linear__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__point__ = __webpack_require__(122);





/* harmony default export */ __webpack_exports__["a"] = (function() {
  var x = __WEBPACK_IMPORTED_MODULE_3__point__["a" /* x */],
      y = __WEBPACK_IMPORTED_MODULE_3__point__["b" /* y */],
      defined = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(true),
      context = null,
      curve = __WEBPACK_IMPORTED_MODULE_2__curve_linear__["a" /* default */],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = Object(__WEBPACK_IMPORTED_MODULE_0_d3_path__["a" /* path */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = x;
/* harmony export (immutable) */ __webpack_exports__["b"] = y;
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = point;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cardinal__ = __webpack_require__(79);



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > __WEBPACK_IMPORTED_MODULE_0__math__["f" /* epsilon */]) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > __WEBPACK_IMPORTED_MODULE_0__math__["f" /* epsilon */]) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new __WEBPACK_IMPORTED_MODULE_1__cardinal__["a" /* Cardinal */](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = sum;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(52);


/* harmony default export */ __webpack_exports__["a"] = (function(series) {
  var sums = series.map(sum);
  return Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RedBlackNode;
function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

/* harmony default export */ __webpack_exports__["b"] = (RedBlackTree);


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = createEdge;
/* harmony export (immutable) */ __webpack_exports__["b"] = createBorderEdge;
/* harmony export (immutable) */ __webpack_exports__["d"] = setEdgeEnd;
/* harmony export (immutable) */ __webpack_exports__["a"] = clipEdges;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Diagram__ = __webpack_require__(53);


function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = __WEBPACK_IMPORTED_MODULE_0__Diagram__["e" /* edges */].push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  __WEBPACK_IMPORTED_MODULE_0__Diagram__["b" /* cells */][left.index].halfedges.push(index);
  __WEBPACK_IMPORTED_MODULE_0__Diagram__["b" /* cells */][right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = __WEBPACK_IMPORTED_MODULE_0__Diagram__["e" /* edges */].length,
      edge;

  while (i--) {
    if (!connectEdge(edge = __WEBPACK_IMPORTED_MODULE_0__Diagram__["e" /* edges */][i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > __WEBPACK_IMPORTED_MODULE_0__Diagram__["f" /* epsilon */]
            || Math.abs(edge[0][1] - edge[1][1]) > __WEBPACK_IMPORTED_MODULE_0__Diagram__["f" /* epsilon */])) {
      delete __WEBPACK_IMPORTED_MODULE_0__Diagram__["e" /* edges */][i];
    }
  }
}


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwPerfAnalyzer_1 = __webpack_require__(60);
var gwAjax_1 = __webpack_require__(15);
var GwFileRequest = /** @class */ (function () {
    function GwFileRequest(inline) {
        this._requestId = this.generateId();
        this._isInline = inline;
    }
    GwFileRequest.prototype.downloadDirectly = function (parameters) {
        this.submitForm("FileContents.do", parameters);
    };
    GwFileRequest.prototype.postDownloadRequest = function (eventSource) {
        if (eventSource) {
            gwPerfAnalyzer_1.gwPerfAnalyzer.startRequest(eventSource);
            $("#gw-event-source").val(eventSource);
        }
        this.submitForm("", {});
    };
    /**
     * Submit main form in a regular way (w/o ajax Form plugin)
     * @param action: form action
     * @param parameters: additional parameters to submit
     */
    GwFileRequest.prototype.submitForm = function (action, parameters) {
        var _this = this;
        var htmlForm = $("#gw-root-form")[0];
        this.wrapWithParameters(htmlForm, parameters, function () {
            var target = "formWindow" + _this._requestId;
            var newWindow = window.open("about:blank", target);
            if (!newWindow) {
                console.error("Cannot open new window. Stop downloading");
                return;
            }
            var oldAction = htmlForm.action;
            var oldTarget = htmlForm.target;
            htmlForm.action = action;
            htmlForm.target = target;
            htmlForm.submit();
            _this.checkDownloadStatus(newWindow);
            if (oldAction) {
                htmlForm.action = oldAction;
            }
            else {
                htmlForm.removeAttribute("action");
            }
            if (oldTarget) {
                htmlForm.target = oldTarget;
            }
            else {
                htmlForm.removeAttribute("target");
            }
            gwUtil_1.gwUtil.clearEventParam();
            gwPerfAnalyzer_1.gwPerfAnalyzer.requestSent();
        });
    };
    GwFileRequest.prototype.wrapWithParameters = function (form, parameters, formCode) {
        var inputs = [];
        for (var param in parameters) {
            if (!parameters.hasOwnProperty(param)) {
                continue;
            }
            inputs.push(this.createInput(form, param, parameters[param]));
        }
        inputs.push(this.createInput(form, GwFileRequest.REQUEST_ID_PARAM, this._requestId));
        formCode();
        inputs.forEach(function ($input) {
            $input.remove();
        });
    };
    GwFileRequest.prototype.createInput = function (form, name, value) {
        var $input = $("<input>", {
            name: name,
            value: value,
            type: "hidden"
        });
        $(form).append($input);
        return $input;
    };
    GwFileRequest.prototype.checkDownloadStatus = function (download) {
        var _this = this;
        setTimeout(function () {
            var parameters = {};
            parameters[GwFileRequest.STATUS_PARAM] = _this._requestId;
            gwAjax_1.gwAjax.ajaxRequest(parameters, function (response) {
                if (response.success) {
                    if (!_this._isInline) {
                        download.close();
                    }
                }
                else {
                    // likely the server sent an error
                    var data = JSON.parse(download.document.body.innerText);
                    _this.showError(data);
                    download.close();
                }
            }, function (error) {
                // status request failed, just close the window likely it does not contain anything interesting
                download.close();
                console.error("Something went wrong: " + error);
            });
        }, GwFileRequest.WAIT_TILL_STATUS_REQUEST);
    };
    GwFileRequest.prototype.showError = function (data) {
        if (data.targets) {
            var length_1 = data.targets.length;
            if (length_1 !== 0) {
                gwUtil_1.gwUtil.replaceTargets(0, 0, 40 / length_1, data.targets);
            }
        }
    };
    GwFileRequest.prototype.generateId = function () {
        var possibleChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        var id = "";
        for (var i = 0; i < 5; i++) {
            id += possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));
        }
        return id + Date.now();
    };
    GwFileRequest.REQUEST_ID_PARAM = "downloadRequestId";
    GwFileRequest.STATUS_PARAM = "__downloadStatus";
    GwFileRequest.WAIT_TILL_STATUS_REQUEST = 100;
    return GwFileRequest;
}());
exports.GwFileRequest = GwFileRequest;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwPageLoadBar = /** @class */ (function (_super) {
    __extends(GwPageLoadBar, _super);
    function GwPageLoadBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.percent = 0;
        _this.filling = ".gw-page-load-bar--filling";
        _this.clearId = -1;
        return _this;
    }
    GwPageLoadBar.prototype.getSystemName = function () {
        return "gwPageLoadBar";
    };
    /**
     * @public
     * Needs to be called on full page reload
     */
    GwPageLoadBar.prototype.init = function () {
        this.setPercent(0);
    };
    /**
     * @public
     * Moves the progress bar to a percent filled.
     * @param num: float as percent of 100
     */
    GwPageLoadBar.prototype.go = function (num) {
        this.clearTimeouts();
        var n = num || 0;
        if (typeof n !== "number") {
            n = parseInt(n);
        }
        if (n > 100) {
            gwUtil_1.gwUtil.devlog("Warning: attempting to set a progress percent higher than 100:", n);
            n = 100;
        }
        else if (n < this.percent && this.percent !== 100) {
            gwUtil_1.gwUtil.devlog("Warning: attempting to set a lower progress percent before 100 completion:", n + " " + this.percent);
            return;
        }
        if (n === 100 && this.percent === 100) {
            gwUtil_1.gwUtil.devlog("Warning: attempting to set a progress of 100 when the progress is already 100:");
        }
        this.startFilling(n);
    };
    /**
     * @private
     * @param val
     */
    GwPageLoadBar.prototype.startFilling = function (val) {
        if (val === 100) {
            this.clearId = setTimeout(this.hide.bind(this), 0);
        }
        this.setPercent(val);
        this.show();
    };
    /**
     * @private
     */
    GwPageLoadBar.prototype.show = function () {
        var inner = this.getInner();
        gwUtil_1.gwUtil.addClass(inner, this.filling);
        inner.style.opacity = "1";
    };
    /**
     * @private
     */
    GwPageLoadBar.prototype.hide = function () {
        var inner = this.getInner();
        gwUtil_1.gwUtil.removeClass(inner, this.filling);
        inner.style.opacity = "0";
    };
    /**
     * @private
     */
    GwPageLoadBar.prototype.clearTimeouts = function () {
        if (this.clearId > 0) {
            clearTimeout(this.clearId);
        }
        this.clearId = -1;
    };
    /**
     * @private
     */
    GwPageLoadBar.prototype.getInner = function () {
        return gwUtil_1.gwUtil.getDomNode(".gw-page-load-bar--inner");
    };
    /**
     * @private
     * @param val
     */
    GwPageLoadBar.prototype.setPercent = function (val) {
        this.percent = val;
        this.getInner().style.width = val + "%";
    };
    return GwPageLoadBar;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwPageLoadBar = GwPageLoadBar;
exports.gwPageLoadBar = new GwPageLoadBar();


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var GwCheckboxGroup = /** @class */ (function (_super) {
    __extends(GwCheckboxGroup, _super);
    function GwCheckboxGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwCheckboxGroup.prototype.getSystemName = function () {
        return "gwCheckboxGroup";
    };
    GwCheckboxGroup.prototype.setOptions = function (classIdTagOrNode, renderId, options) {
        var checkboxGroup = gwUtil_1.gwUtil.getDomNode(classIdTagOrNode);
        if (!checkboxGroup) {
            return;
        }
        while (checkboxGroup.firstChild) {
            checkboxGroup.removeChild(checkboxGroup.firstChild);
        }
        options
            .map(function (option) {
            var checkbox = document.createElement("input");
            checkbox.setAttribute("type", "checkbox");
            checkbox.setAttribute("name", renderId);
            checkbox.setAttribute("value", option.key);
            var label = document.createElement("label");
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(option.label));
            var optionDiv = gwUtil_1.gwUtil.createDiv("gw-editableCheckbox");
            optionDiv.appendChild(label);
            return optionDiv;
        })
            .forEach(function (optionDiv) {
            checkboxGroup.appendChild(optionDiv);
        });
    };
    GwCheckboxGroup.prototype.setValues = function (checkboxGroupNode, values) {
        var el = gwUtil_1.gwUtil.getDomNode(checkboxGroupNode);
        if (!el) {
            return;
        }
        if (!Array.isArray(values)) {
            values = [values];
        }
        var checkboxes = gwUtil_1.gwUtil.getDomNodes(".gw-editableCheckbox", el);
        for (var i = 0; i < checkboxes.length; i++) {
            var checkboxInput = gwUtil_1.gwUtil.getDomNodeByAttr("type", "checkbox", checkboxes[i]);
            if (!checkboxInput) {
                continue;
            }
            checkboxInput.checked = values.indexOf(checkboxInput.value) !== -1;
        }
    };
    GwCheckboxGroup.prototype.getValues = function (checkboxGroupNode) {
        var checkboxes = gwUtil_1.gwUtil.getDomNodesByAttr("type", "checkbox", checkboxGroupNode);
        var values = [];
        if (checkboxes) {
            for (var i = 0; i < checkboxes.length; i++) {
                if (checkboxes[i].checked) {
                    values.push(checkboxes[i].value);
                }
            }
        }
        return values;
    };
    GwCheckboxGroup.prototype.enable = function (checkboxGroupNode, enabled) {
        if (enabled === void 0) { enabled = false; }
        var checkboxes = gwUtil_1.gwUtil.getDomNodesByAttr("type", "checkbox", checkboxGroupNode);
        if (checkboxes) {
            for (var i = 0; i < checkboxes.length; i++) {
                checkboxes[i].disabled = !enabled;
            }
        }
    };
    return GwCheckboxGroup;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwCheckboxGroup = GwCheckboxGroup;
exports.gwCheckboxGroup = new GwCheckboxGroup();


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var GwRangeRadio = /** @class */ (function (_super) {
    __extends(GwRangeRadio, _super);
    function GwRangeRadio() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwRangeRadio.prototype.getSystemName = function () {
        return "gwRangeRadio";
    };
    GwRangeRadio.prototype.setValue = function (classIdTagOrNode, renderId, value) {
        var radioRange = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        var radios = gwUtil_1.gwUtil.getDomNodesByAttr("name", renderId, radioRange);
        for (var i = 0; i < radios.length; i++) {
            radios[i].checked = radios[i].value === value;
        }
    };
    GwRangeRadio.prototype.getValue = function (node) {
        var radios = gwUtil_1.gwUtil.getDomNodesByAttr("type", "radio", node);
        var value = null;
        if (radios) {
            for (var i = 0; i < radios.length; i++) {
                if (radios[i].checked) {
                    value = radios[i].value;
                    break;
                }
            }
        }
        return value;
    };
    GwRangeRadio.prototype.enable = function (classIdTagOrNode, enabled) {
        if (enabled === void 0) { enabled = false; }
        var radioRange = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        var radios = gwUtil_1.gwUtil.getDomNodesByAttr("type", "radio", radioRange);
        for (var i = 0; i < radios.length; i++) {
            radios[i].disabled = !enabled;
        }
    };
    return GwRangeRadio;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwRangeRadio = GwRangeRadio;
exports.gwRangeRadio = new GwRangeRadio();


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwEvents_1 = __webpack_require__(3);
var gwStorage_1 = __webpack_require__(24);
var gwResizer_1 = __webpack_require__(35);
var gwUtil_1 = __webpack_require__(0);
var GwDraggableSystem_1 = __webpack_require__(83);
/**
 * The south panel (also known as the workspace) is displayed at the bottom of the UI and contains one or more
 * worksheets, which can contain arbitrary panels, inputs and so on. You can switch between worksheets via tabs at
 * the top of the workspace.
 *
 * The south panel is in one of three states:
 * - Hidden entirely
 * - Showing normally
 * - Minimized (just the worksheet tab labels showing)
 *
 * The server determines whether the south panel is hidden. On every render it will figure out the current worksheet,
 * if any, and then render it. The client side code cannot hide the south panel directly, it must cause a server
 * request that will then figure out if there is still a current worksheet and render accordingly. All tab changes
 * also require a server round trip and re-render, as the client only has the content for the "current" worksheet.
 *
 * The client is in control of the south panel height and whether it is minimized. These values are both kept in
 * local storage and the controls for resizing and minimizing the south panel are purely client side. So when the
 * panel is minimized all its contents is available on the client side, just not all visible.
 *
 * The very first time the south panel is displayed there will be no stored height or minimization flag and, in that
 * case, the client side code will set the south panel height to be a proportion of the overall UI height.
 *
 * Resizing the south panel is done via a drag control so it implements the GwDraggableSystem interface.
 */
var GwSouthPanel = /** @class */ (function (_super) {
    __extends(GwSouthPanel, _super);
    function GwSouthPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         *  Used to store a boolean indicating whether the south panel is minimized - if unset, assume false
         */
        _this.IS_MINIMIZED_KEY = "SouthPanel_Min";
        /**
         * Used to store the south panel height in pixels - if unset need to calculate default height
         */
        _this.HEIGHT_KEY = "SouthPanel.size";
        /**
         * Used when there is no stored south panel height; used to calculate how high it should be relative to the
         * center panel
         */
        _this.DEFAULT_HEIGHT_PERCENTAGE = 0.4;
        /**
         * Minimum number of pixels to allow for the center panel, to stop the south panel from entirely covering it.
         * This ensures at least a little of the center panel is visible and also leaves space for the south panel
         * "minimizer" control.
         */
        _this.MINIMUM_CENTER_PANEL_HEIGHT = 10;
        /**
         * If the south panel is smaller than the "snapLine" height (in pixels) then it is minimized automatically
         */
        _this._snapLine = 80;
        /**
         * Used to calculate the offset of the drag bar from it's original position.
         * @type GwPoint
         */
        _this._startPos = null;
        return _this;
    }
    GwSouthPanel.prototype.getSystemName = function () {
        return "gwSouthPanel";
    };
    /**
     * Initialization, called after server round trip
     */
    GwSouthPanel.prototype.init = function (isFullPageReload) {
        this.setSnapLineFromCss();
        this.setPanelToSavedHeightAfterRender();
    };
    /**
     * Called by the resizer to calculate the size of the center panel, to ensure that the south panel will fit in the
     * available space. The south panel will try to return to its saved height, if available. If there's not room for
     * that, or it has no saved height, then it will try to fill up 40% of the available space.
     * @param {number} availablePixels the amount of space available for the south panel
     * @returns {number} the height of the south panel
     */
    GwSouthPanel.prototype.ensureHeightFits = function (availablePixels) {
        if (this.isHidden()) {
            // South panel hidden entirely
            return 0;
        }
        if (this.isMinimized()) {
            // Can't negotiate height of minimized panel
            return this.computeActualHeight();
        }
        var storedHeight = this.getStoredHeight();
        var effectiveAvailablePixels = availablePixels - this.MINIMUM_CENTER_PANEL_HEIGHT;
        if (storedHeight !== null && storedHeight <= effectiveAvailablePixels) {
            return storedHeight;
        }
        var newHeight = storedHeight === null
            ? Math.min(Math.floor(availablePixels * this.DEFAULT_HEIGHT_PERCENTAGE), effectiveAvailablePixels)
            : effectiveAvailablePixels;
        // If too small, forcibly minimize. Otherwise update height
        if (newHeight < this._snapLine) {
            gwStorage_1.gwStorage.set(this.IS_MINIMIZED_KEY, true);
            this.applyMinimization();
            return this.computeActualHeight();
        }
        else {
            gwStorage_1.gwStorage.set(this.HEIGHT_KEY, newHeight);
            this.getPanelEl().style.height = newHeight + "px";
            return newHeight;
        }
    };
    /**
     * Toggles south panel minimization
     * Public event handler
     */
    GwSouthPanel.prototype.toggleCollapse = function () {
        gwStorage_1.gwStorage.toggleFlag(this.IS_MINIMIZED_KEY);
        this.restorePanelHeight();
    };
    /**
     * Open the south panel if it is minimized
     * Public event handler
     */
    GwSouthPanel.prototype.unMinimize = function () {
        if (this.isMinimized()) {
            this.toggleCollapse();
        }
    };
    /**
     * Opens the south panel if currently minimized, in addition to firing the worksheet tab event. Firing the tab
     * event will cause a server round trip and re-render
     * Public event handler
     */
    GwSouthPanel.prototype.worksheetTabClick = function (node, args, e) {
        gwStorage_1.gwStorage.set(this.IS_MINIMIZED_KEY, false);
        var outerAction = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(node, "gw-action--outer");
        if (outerAction) {
            args.id = outerAction.id;
        }
        gwEvents_1.gwEvents.methods.fireEvent(node, args, e);
    };
    /**
     * Part of the GwDraggableSystem interface, called by gwDraggable.ts when the south panel is being resized
     */
    GwSouthPanel.prototype.drag = function (el, args, e) {
        this.moveDragBarTo(el, e);
    };
    /**
     * Part of the GwDraggableSystem interface, called by gwDraggable.ts when the south panel is being resized
     */
    GwSouthPanel.prototype.dragStart = function (el, args, e) {
        gwUtil_1.gwUtil.addClass(this.getPanelEl(), "gw-beingResized");
        this._startPos = gwUtil_1.gwUtil.getMousePosition(el, e);
        this.moveDragBarTo(el, e);
    };
    /**
     * Part of the GwDraggableSystem interface, called by gwDraggable.ts when the south panel is being resized
     */
    GwSouthPanel.prototype.dragEnd = function (el, args, e) {
        this.resetDragBar(el);
        gwUtil_1.gwUtil.removeClass(this.getPanelEl(), "gw-beingResized");
        this.setPanelHeightOnEvent(el, e);
        this._startPos = null;
    };
    /**
     * Part of the GwDraggableSystem interface, called by gwDraggable.ts when the south panel is being resized
     */
    GwSouthPanel.prototype.dragCancel = function (el, args, e) {
        this.resetDragBar(el);
        gwUtil_1.gwUtil.removeClass(this.getPanelEl(), "gw-beingResized");
        this.restorePanelHeight();
        this._startPos = null;
    };
    /**
     * Called when the user has dragged the south panel to a new height. Clear minimization and then attempt
     * to set height according to the mouse position - if that makes the panel smaller than the "snap line"
     * setPanelHeight will re-minimize it.
     */
    GwSouthPanel.prototype.setPanelHeightOnEvent = function (el, e) {
        var mousePos = gwUtil_1.gwUtil.getMousePosition(el, e);
        var pixelHeight = (gwResizer_1.gwResizer.windowHeight - mousePos.y);
        gwStorage_1.gwStorage.set(this.IS_MINIMIZED_KEY, false);
        this.setPanelHeight(pixelHeight);
    };
    GwSouthPanel.prototype.restorePanelHeight = function () {
        this.setPanelHeight(this.getStoredHeight());
    };
    /**
     * Read the snap line height configured in CSS, if possible. This allows the snap line to be configured via
     * style sheet, rather than being hard coded in this file.
     */
    GwSouthPanel.prototype.setSnapLineFromCss = function () {
        var panelMinHeight = this.getPanelEl().style.minHeight;
        if (panelMinHeight) {
            this._snapLine = parseInt(panelMinHeight) || this._snapLine;
        }
    };
    /**
     * Called during initialization - that is after the server has re-rendered - to set the newly rendered panel's
     * height to the value chosen by the user. Later in initialization the resizer will ensure that the panel will
     * actually fit in the available space.
     */
    GwSouthPanel.prototype.setPanelToSavedHeightAfterRender = function () {
        if (!this.isHidden()) {
            this.applyMinimization();
            if (!this.isMinimized()) {
                var storedHeight = this.getStoredHeight();
                if (storedHeight !== null) {
                    this.getPanelEl().style.height = storedHeight + "px";
                }
            }
        }
    };
    GwSouthPanel.prototype.computeActualHeight = function () {
        return parseFloat(window.getComputedStyle(this.getPanelEl()).height);
    };
    /**
     * Called when a client side action (resizing or minimization) has changed the height of the panel. Notifiers
     * the resizer when it is done, and the resizer will call back to ensure the proposed height works.
     */
    GwSouthPanel.prototype.setPanelHeight = function (pixelHeight) {
        var panelEl = this.getPanelEl();
        if (this.isMinimized() || (pixelHeight !== null && pixelHeight < this._snapLine)) {
            gwStorage_1.gwStorage.set(this.IS_MINIMIZED_KEY, true);
            pixelHeight = null;
        }
        if (pixelHeight) {
            var maxHeight = gwResizer_1.gwResizer.windowHeight ? gwResizer_1.gwResizer.windowHeight : pixelHeight;
            pixelHeight = Math.min(pixelHeight, maxHeight);
            pixelHeight = Math.max(pixelHeight, this._snapLine);
            gwStorage_1.gwStorage.set(this.HEIGHT_KEY, pixelHeight);
            gwStorage_1.gwStorage.set(this.IS_MINIMIZED_KEY, false);
            panelEl.style.height = pixelHeight + "px";
        }
        else {
            panelEl.style.height = "";
        }
        this.applyMinimization();
        gwResizer_1.gwResizer.recalcCenterPanel();
    };
    GwSouthPanel.prototype.isHidden = function () {
        return gwUtil_1.gwUtil.hasClass(this.getPanelEl(), "gw-placeholder");
    };
    GwSouthPanel.prototype.isMinimized = function () {
        return gwStorage_1.gwStorage.get(this.IS_MINIMIZED_KEY) || false;
    };
    GwSouthPanel.prototype.getStoredHeight = function () {
        return gwStorage_1.gwStorage.get(this.HEIGHT_KEY) || null;
    };
    /**
     * Check whether the south panel is minimized and then show/hide the appropriate south panel elements
     */
    GwSouthPanel.prototype.applyMinimization = function () {
        var isMin = this.isMinimized();
        gwUtil_1.gwUtil.conditionalAddRemoveClass(isMin, "#gw-south-panel", ".gw-makeSouthPanel--min");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(isMin, "#gw-SouthPanel--toggle", "gw-minimized");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(isMin, "#gw-south-panel-toggleMinMax_float", "gw-minimized");
    };
    GwSouthPanel.prototype.getPanelEl = function () {
        var panelEl = document.getElementById("gw-south-panel");
        if (!panelEl) {
            throw new Error("Unable to locate the south panel in the DOM");
        }
        return panelEl;
    };
    GwSouthPanel.prototype.moveDragBarTo = function (el, e) {
        var mousePos = gwUtil_1.gwUtil.getMousePosition(el, e);
        if (!this._startPos) {
            throw new Error("found null start pos for south panel drag");
        }
        el.style.top = (mousePos.y - this._startPos.y) + "px";
        el.style.right = "0";
    };
    GwSouthPanel.prototype.resetDragBar = function (el) {
        el.style.right = null;
        el.style.top = null;
    };
    return GwSouthPanel;
}(GwDraggableSystem_1.GwDraggableSystem));
exports.GwSouthPanel = GwSouthPanel;
exports.gwSouthPanel = new GwSouthPanel();


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwCurrencyInfo = /** @class */ (function () {
    function GwCurrencyInfo(infoArr) {
        if (infoArr.length !== 5) {
            throw new Error("Currency info attribute does not have all 5 required values: " + infoArr);
        }
        this.code = infoArr[0]; //Currency Code: ie USD
        this.symb = infoArr[1]; //Currency Symbol: ie $
        this.grouping = infoArr[2]; //Grouping separator: ie ',' in 1,234
        this.radix = infoArr[3]; //Radix separator: ie '.' in 123.45
        this.maxDecimalDigits = +infoArr[4]; //Max allowed decimals: ie 2 = .00, 0 = no radix
    }
    GwCurrencyInfo.getCurrencyInfo = function (currencyEl) {
        var info = currencyEl.getAttribute("data-gw-currency-info");
        if (!info) {
            return null;
        }
        var infoArr = info.split(";");
        return new GwCurrencyInfo(infoArr);
    };
    return GwCurrencyInfo;
}());
exports.GwCurrencyInfo = GwCurrencyInfo;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var gw_1 = __webpack_require__(10);
var gwInputs_1 = __webpack_require__(5);
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwForm_1 = __webpack_require__(25);
var GwConfirm = /** @class */ (function (_super) {
    __extends(GwConfirm, _super);
    function GwConfirm() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwConfirm.prototype.getSystemName = function () {
        return "gwConfirm";
    };
    /**
     * @private
     * Checks the targeted node associated with the eventDescription and returns
     * a list of input nodes that need to be confirmed.
     */
    GwConfirm.prototype.getInputsToBeConfirmed = function (eventDescription) {
        var _this = this;
        var changeNode = eventDescription.eventTargetNode;
        var confirmationNodes = [];
        var hasConfirmData = changeNode && changeNode.dataset && changeNode.dataset.gwConfirm;
        if (hasConfirmData) {
            var $inputsToCheck = this.$getInputsToCheck(changeNode);
            if ($inputsToCheck.length > 0) {
                gwUtil_1.gwUtil.forEach($inputsToCheck, function (confirmChild) {
                    if (_this.valueDiffersFromDefault(confirmChild)) {
                        confirmationNodes.push(confirmChild);
                    }
                });
            }
        }
        return confirmationNodes;
    };
    /**
     * @private
     * Based on the type of node, searches the current node and it's children and returns a list of nodes
     * to whose values will be checked to see if they've changed.  If multi-input, calls
     *   gw[changeNode.getAttributeName("data-gw-multi-input")].getConfirmTargets(changeNode)
     * @param changeNode
     * @returns {{set, expr}|*|{ID, NAME, TAG}|jQuery}
     */
    GwConfirm.prototype.$getInputsToCheck = function (changeNode) {
        var multiPartNode = gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(changeNode, "data-gw-multi-input");
        if (multiPartNode) {
            var systemName = multiPartNode.getAttribute("data-gw-multi-input");
            if (systemName !== null) {
                if (!gw_1.gw.globals[systemName]) {
                    throw new Error("Attempting to confirm a target system not registered with gw.globals " + systemName);
                }
                return gw_1.gw.globals[systemName].getConfirmTargets(changeNode); //TODO: TS type
            }
        }
        return $(changeNode).find("input, select");
    };
    /**
     * Save the current value of an input after a user has confirmed they want the change. Only
     * called for nodes that require confirmation before a value change. Does nothing if
     * node is not an input.
     * Assumption: we don't support multiselect select controls
     */
    GwConfirm.prototype.saveConfirmedValue = function (node) {
        var inputType = gwInputs_1.gwInputs.inputType(node);
        if (inputType === "select") {
            node.dataset.gwConfirmedSelectedIndex = "" + node.selectedIndex;
        }
        else if (inputType === "text") {
            node.dataset.gwConfirmedValue = node.value;
        }
        else if (inputType === "checkbox") {
            node.dataset.gwConfirmedChecked = "" + node.checked;
        }
        else if (inputType === "radio") {
            gwUtil_1.gwUtil.forEach(gwInputs_1.gwInputs.radioButtonsInGroup(node), function (radio) {
                radio.dataset.gwConfirmedChecked = radio.checked;
            });
        }
    };
    /**
     * @private
     * Restore previous value of an input after a user has cancelled an input change. Only
     * called for nodes that require confirmation before a value change. Does nothing if
     * node is not an input.
     * Assumption: we don't support multiselect select controls
     */
    GwConfirm.prototype.cancelValueChange = function (node) {
        if (node instanceof HTMLSelectElement) {
            node.selectedIndex = typeof (node.dataset.gwConfirmedSelectedIndex) !== "undefined" ? parseInt(node.dataset.gwConfirmedSelectedIndex) : gwInputs_1.gwInputs.defaultSelectedIndex(node);
        }
        else if (node instanceof HTMLTextAreaElement) {
            node.value = typeof (node.dataset.gwConfirmedValue) !== "undefined" ? node.dataset.gwConfirmedValue : node.defaultValue;
        }
        else {
            var inputType = gwInputs_1.gwInputs.inputType(node);
            if (inputType === "checkbox") {
                node.checked = typeof (node.dataset.gwConfirmedChecked) !== "undefined" ? node.dataset.gwConfirmedChecked === "true" : node.defaultChecked;
            }
            else if (inputType === "radio") {
                gwUtil_1.gwUtil.forEach(gwInputs_1.gwInputs.radioButtonsInGroup(node), function (radio) {
                    var confirmedChecked = radio.dataset.gwConfirmedChecked;
                    radio.checked = typeof (confirmedChecked) !== "undefined" ? confirmedChecked === "true" : radio.defaultChecked;
                });
                // Standard input
            }
            else {
                node.value = typeof (node.dataset.gwConfirmedValue) !== "undefined" ? node.dataset.gwConfirmedValue : node.defaultValue;
            }
        }
        gwForm_1.gwForm.elementChanged(node);
    };
    /**
     * @private
     * Based on the inputType of {@param node}, check to see if the current value
     * differs from the default value.
     *
     * @param node node for which current and default values will be compared
     * @returns {boolean} return true if the current value differs from the default value
     *     else returns false
     */
    GwConfirm.prototype.valueDiffersFromDefault = function (node) {
        var inputType = gwInputs_1.gwInputs.inputType(node);
        if (node instanceof HTMLSelectElement) {
            return node.selectedIndex !== (typeof (node.dataset.gwConfirmedSelectedIndex) !== "undefined" ? parseInt(node.dataset.gwConfirmedSelectedIndex) : gwInputs_1.gwInputs.defaultSelectedIndex(node));
        }
        else if (node instanceof HTMLTextAreaElement) {
            return node.value !== (typeof (node.dataset.gwConfirmedValue) !== "undefined" ? node.dataset.gwConfirmedValue : node.defaultValue);
        }
        else {
            if (inputType === "checkbox") {
                return node.checked !== (typeof (node.dataset.gwConfirmedChecked) !== "undefined" ? node.dataset.gwConfirmedChecked === "true" : node.defaultChecked);
            }
            else if (inputType === "radio") {
                var changed_1 = false;
                gwUtil_1.gwUtil.forEach(gwInputs_1.gwInputs.radioButtonsInGroup(node), function (radio) {
                    var confirmedChecked = radio.dataset.gwConfirmedChecked;
                    changed_1 = (radio.checked === (typeof (confirmedChecked) !== "undefined" ? confirmedChecked === "true" : radio.defaultChecked));
                    // Break out if we've changed
                    return (!changed_1);
                });
                return changed_1;
                // Standard Input
            }
            else {
                return node.value !== (typeof (node.dataset.gwConfirmedValue) !== "undefined" ? node.dataset.gwConfirmedValue : node.defaultValue);
            }
        }
    };
    GwConfirm.prototype.isConfirm = function (el) {
        return el && el.hasAttribute("data-gw-confirm");
    };
    /**
     * @public
     * Grabs method using key {@param methodKey} from multi input config object passed via
     * "data-gw-multi-input" attribute on {@param changeNode}.
     *
     * @param changeNode
     * @param methodKey
     * @returns {null}
     */
    GwConfirm.prototype.getMethodFromMultiInputConfig = function (changeNode, methodKey) {
        var multiInputConfig = changeNode.getAttribute("data-gw-multi-input");
        if (multiInputConfig) {
            var multiInputConfigObject = JSON.parse(multiInputConfig);
            if (multiInputConfigObject && multiInputConfigObject[methodKey]) {
                return multiInputConfigObject[methodKey];
            }
        }
        return null;
    };
    /**
     * @public
     * Check if executing the given event needs user confirmation. If so display a confirmation dialog
     * to the user, giving them a chance to cancel it. The event description is the result of calling
     * getEventDescription and contains details of the target node, event type and the method to be
     * executed plus its arguments.
     *
     * @return {boolean} true if the event should proceed, false if it has been cancelled by the user
     */
    GwConfirm.prototype.confirmEvent = function (eventDescription) {
        var node = eventDescription.eventTargetNode;
        if (!node) {
            throw new Error("Attempting to confirm an event with no eventTargetNode");
        }
        // If this is a click event, then it's an action widget we need to confirm
        if (eventDescription.eventType === "click" || eventDescription.replacesClick) {
            if (node.hasAttribute("data-gw-confirm")) {
                gwEvents_1.gwEvents.disableNavigationConfirmationUntilUserCancelsConfirm();
                var clickConfirmationResult = !!window.confirm(node.dataset.gwConfirm);
                if (!clickConfirmationResult) {
                    gwEvents_1.gwEvents.confirmationCancelled();
                    return false;
                }
            }
        }
        else if (eventDescription.eventType === "change") {
            var confirmationNodes = this.getInputsToBeConfirmed(eventDescription);
            if (confirmationNodes && confirmationNodes.length > 0) {
                gwEvents_1.gwEvents.disableNavigationConfirmationUntilUserCancelsConfirm();
                var changeConfirmationResult = window.confirm(node.dataset.gwConfirm);
                var confirmEventFunc = changeConfirmationResult ? this.saveConfirmedValue.bind(this) : this.cancelValueChange.bind(this);
                gwUtil_1.gwUtil.forEach(confirmationNodes, confirmEventFunc);
                if (!changeConfirmationResult) {
                    gwEvents_1.gwEvents.confirmationCancelled();
                    return false;
                }
            }
        }
        return true;
    };
    return GwConfirm;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwConfirm = GwConfirm;
exports.gwConfirm = new GwConfirm();


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwJic_1 = __webpack_require__(40);
var GwDateInfo = /** @class */ (function () {
    function GwDateInfo(inputEl) {
        this.currentDay = 0;
        this.currentMonth = 0;
        this.currentYear = 0;
        this.selectedDay = 0;
        this.selectedMonth = 0;
        this.selectedYear = 0;
        this.drawMonth = 0;
        this.drawYear = 0;
        this.eraYear = 1;
        this.lastVal = null;
        this.disableDaysAfter = null;
        this.disableDaysBefore = null;
        this.disableTestFoundDate1 = 0;
        if (GwDateInfo.infoCounter > 1000000) {
            GwDateInfo.infoCounter = 0;
        }
        this.uuid = (GwDateInfo.infoCounter++) + "." + window.performance.now();
        this.$input = $(inputEl);
        this.inputEl = inputEl;
        this.$inputParent = $(inputEl).parent(); // associated target
        this.dateIconEl = document.getElementById(inputEl.name + "_dateIcon");
        this.isJIC = gwJic_1.gwJic.isJIC(inputEl);
    }
    GwDateInfo.infoCounter = 0;
    return GwDateInfo;
}());
exports.GwDateInfo = GwDateInfo;


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bisectLeft; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bisector__ = __webpack_require__(136);



var ascendingBisect = Object(__WEBPACK_IMPORTED_MODULE_1__bisector__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["c"] = (bisectRight);


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(36);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */])(f(d), x);
  };
}


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = pair;
/* harmony default export */ __webpack_exports__["a"] = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__variance__ = __webpack_require__(139);


/* harmony default export */ __webpack_exports__["a"] = (function(array, f) {
  var v = Object(__WEBPACK_IMPORTED_MODULE_0__variance__["a" /* default */])(array, f);
  return v ? Math.sqrt(v) : v;
});


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(42);


/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tickIncrement;
/* harmony export (immutable) */ __webpack_exports__["c"] = tickStep;
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__min__ = __webpack_require__(145);


/* harmony default export */ __webpack_exports__["a"] = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(__WEBPACK_IMPORTED_MODULE_0__min__["a" /* default */])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function length(d) {
  return d.length;
}


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(12);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([[document.querySelector(selector)]], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([[selector]], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (matcher);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = EnterNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(12);



/* harmony default export */ __webpack_exports__["b"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Selection */](this._enter || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(update) {
  return new Array(update.length);
});


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = styleValue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(92);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = yesdrag;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noevent__ = __webpack_require__(154);



/* harmony default export */ __webpack_exports__["a"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["k" /* select */])(view).on("dragstart.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["k" /* select */])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", __WEBPACK_IMPORTED_MODULE_1__noevent__["a" /* default */], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
});


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return rgbBasisClosed; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basisClosed__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color__ = __webpack_require__(43);





/* harmony default export */ __webpack_exports__["a"] = ((function rgbGamma(y) {
  var color = Object(__WEBPACK_IMPORTED_MODULE_3__color__["b" /* gamma */])(y);

  function rgb(start, end) {
    var r = color((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* rgb */])(start)).r, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* rgb */])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_3__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["f" /* rgb */])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis__["b" /* default */]);
var rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed__["a" /* default */]);


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(98);


/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(__WEBPACK_IMPORTED_MODULE_0__basis__["a" /* basis */])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(95);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
});


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
});


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(95);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(__WEBPACK_IMPORTED_MODULE_0__value__["a" /* default */])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(65);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_schedule__ = __webpack_require__(14);


/* harmony default export */ __webpack_exports__["a"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["d" /* STARTING */] && schedule.state < __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["b" /* ENDING */];
    schedule.state = __WEBPACK_IMPORTED_MODULE_0__transition_schedule__["a" /* ENDED */];
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);



/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["m" /* interpolateNumber */]
      : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* color */] ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["o" /* interpolateRgb */]
      : (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["a" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["o" /* interpolateRgb */])
      : __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["s" /* interpolateString */])(a, b);
});


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_linear__ = __webpack_require__(332);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_0__src_linear__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_quad__ = __webpack_require__(333);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubic__ = __webpack_require__(334);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_poly__ = __webpack_require__(335);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_sin__ = __webpack_require__(336);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_exp__ = __webpack_require__(337);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_circle__ = __webpack_require__(338);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_bounce__ = __webpack_require__(339);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_back__ = __webpack_require__(340);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_elastic__ = __webpack_require__(341);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__["b"]; });





















/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sin; });
/* unused harmony export pi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return max; });
var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = x;
/* harmony export (immutable) */ __webpack_exports__["c"] = y;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_collection__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_timer__ = __webpack_require__(66);




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ __webpack_exports__["a"] = (function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = Object(__WEBPACK_IMPORTED_MODULE_1_d3_collection__["c" /* map */])(),
      stepper = Object(__WEBPACK_IMPORTED_MODULE_2_d3_timer__["d" /* timer */])(step),
      event = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
});


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatGroup__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatNumerals__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__formatSpecifier__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__formatTypes__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__identity__ = __webpack_require__(385);








var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["a"] = (function(locale) {
  var group = locale.grouping && locale.thousands ? Object(__WEBPACK_IMPORTED_MODULE_1__formatGroup__["a" /* default */])(locale.grouping, locale.thousands) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? Object(__WEBPACK_IMPORTED_MODULE_2__formatNumerals__["a" /* default */])(locale.numerals) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = __WEBPACK_IMPORTED_MODULE_4__formatTypes__["a" /* default */][type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__["b" /* prefixExponent */] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatSpecifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatTypes__ = __webpack_require__(170);


// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!__WEBPACK_IMPORTED_MODULE_0__formatTypes__["a" /* default */][type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDefault__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatRounded__ = __webpack_require__(384);




/* harmony default export */ __webpack_exports__["a"] = ({
  "": __WEBPACK_IMPORTED_MODULE_0__formatDefault__["a" /* default */],
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(__WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */])(x * 100, p); },
  "r": __WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */],
  "s": __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__["a" /* default */],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefixExponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(108);


var prefixExponent;

/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areaRingSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return areaStream; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noop__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stream__ = __webpack_require__(32);





var areaRingSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])();

var areaSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineStart: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineEnd: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? __WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */] + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */];
  },
  sphere: function() {
    areaSum.add(__WEBPACK_IMPORTED_MODULE_1__math__["w" /* tau */]);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */];
  lambda0 = lambda, cosPhi0 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi = phi / 2 + __WEBPACK_IMPORTED_MODULE_1__math__["q" /* quarterPi */]), sinPhi0 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi);
}

function areaPoint(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */];
  phi = phi / 2 + __WEBPACK_IMPORTED_MODULE_1__math__["q" /* quarterPi */]; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi),
      sinPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(adLambda),
      v = k * sdLambda * Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(adLambda);
  areaRingSum.add(Object(__WEBPACK_IMPORTED_MODULE_1__math__["e" /* atan2 */])(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ __webpack_exports__["c"] = (function(object) {
  areaSum.reset();
  Object(__WEBPACK_IMPORTED_MODULE_3__stream__["a" /* default */])(object, areaStream);
  return areaSum * 2;
});


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = circleStream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cartesian__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(392);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rotation__ = __webpack_require__(69);





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(radius),
      sinRadius = Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * __WEBPACK_IMPORTED_MODULE_2__math__["w" /* tau */];
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * __WEBPACK_IMPORTED_MODULE_2__math__["w" /* tau */];
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["g" /* spherical */])([cosRadius, -sinRadius * Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(t), -sinRadius * Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["a" /* cartesian */])(point), point[0] -= cosRadius;
  Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["e" /* cartesianNormalizeInPlace */])(point);
  var radius = Object(__WEBPACK_IMPORTED_MODULE_2__math__["b" /* acos */])(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + __WEBPACK_IMPORTED_MODULE_2__math__["w" /* tau */] - __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */]) % __WEBPACK_IMPORTED_MODULE_2__math__["w" /* tau */];
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  var center = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])([0, 0]),
      radius = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(90),
      precision = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= __WEBPACK_IMPORTED_MODULE_2__math__["h" /* degrees */], x[1] *= __WEBPACK_IMPORTED_MODULE_2__math__["h" /* degrees */];
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */],
        p = precision.apply(this, arguments) * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */];
    ring = [];
    rotate = Object(__WEBPACK_IMPORTED_MODULE_3__rotation__["b" /* rotateRadians */])(-c[0] * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */], -c[1] * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */], 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), circle) : precision;
  };

  return circle;
});


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
});


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], -__WEBPACK_IMPORTED_MODULE_1__math__["l" /* halfPi */]]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] : -__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */],
          delta = Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(lambda1 - lambda0);
      if (Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(delta - __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */]) < __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? __WEBPACK_IMPORTED_MODULE_1__math__["l" /* halfPi */] : -__WEBPACK_IMPORTED_MODULE_1__math__["l" /* halfPi */]);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */]) { // line crosses antimeridian
        if (Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(lambda0 - sign0) < __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]) lambda0 -= sign0 * __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]; // handle degeneracies
        if (Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(lambda1 - sign1) < __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]) lambda1 -= sign1 * __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */];
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(lambda0 - lambda1);
  return Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(sinLambda0Lambda1) > __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]
      ? Object(__WEBPACK_IMPORTED_MODULE_1__math__["d" /* atan */])((Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi0) * (cosPhi1 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi1)) * Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(lambda1)
          - Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi1) * (cosPhi0 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi0)) * Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * __WEBPACK_IMPORTED_MODULE_1__math__["l" /* halfPi */];
    stream.point(-__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], phi);
    stream.point(0, phi);
    stream.point(__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], phi);
    stream.point(__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], 0);
    stream.point(__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], -phi);
    stream.point(0, -phi);
    stream.point(-__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], -phi);
    stream.point(-__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], 0);
    stream.point(-__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */], phi);
  } else if (Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(from[0] - to[0]) > __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]) {
    var lambda = from[0] < to[0] ? __WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */] : -__WEBPACK_IMPORTED_MODULE_1__math__["o" /* pi */];
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rejoin__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polygonContains__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_array__ = __webpack_require__(9);






/* harmony default export */ __webpack_exports__["a"] = (function(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = Object(__WEBPACK_IMPORTED_MODULE_0__buffer__["a" /* default */])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = Object(__WEBPACK_IMPORTED_MODULE_4_d3_array__["n" /* merge */])(segments);
        var startInside = Object(__WEBPACK_IMPORTED_MODULE_3__polygonContains__["a" /* default */])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          Object(__WEBPACK_IMPORTED_MODULE_1__rejoin__["a" /* default */])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
});

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - __WEBPACK_IMPORTED_MODULE_2__math__["l" /* halfPi */] - __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */] : __WEBPACK_IMPORTED_MODULE_2__math__["l" /* halfPi */] - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - __WEBPACK_IMPORTED_MODULE_2__math__["l" /* halfPi */] - __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */] : __WEBPACK_IMPORTED_MODULE_2__math__["l" /* halfPi */] - b[1]);
}


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noop__ = __webpack_require__(22);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
});


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pointEqual__ = __webpack_require__(179);


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ __webpack_exports__["a"] = (function(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (Object(__WEBPACK_IMPORTED_MODULE_0__pointEqual__["a" /* default */])(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
});

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(a[0] - b[0]) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */] && Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(a[1] - b[1]) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */];
});


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cartesian__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(1);




var sum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])();

/* harmony default export */ __webpack_exports__["a"] = (function(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(lambda), -Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + __WEBPACK_IMPORTED_MODULE_2__math__["q" /* quarterPi */],
        sinPhi0 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(phi0),
        cosPhi0 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + __WEBPACK_IMPORTED_MODULE_2__math__["q" /* quarterPi */],
          sinPhi1 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(phi1),
          cosPhi1 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */],
          k = sinPhi0 * sinPhi1;

      sum.add(Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* atan2 */])(k * sign * Object(__WEBPACK_IMPORTED_MODULE_2__math__["t" /* sin */])(absDelta), cosPhi0 * cosPhi1 + k * Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(absDelta)));
      angle += antimeridian ? delta + sign * __WEBPACK_IMPORTED_MODULE_2__math__["w" /* tau */] : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["c" /* cartesianCross */])(Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["a" /* cartesian */])(point0), Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["a" /* cartesian */])(point1));
        Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["e" /* cartesianNormalizeInPlace */])(arc);
        var intersection = Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["c" /* cartesianCross */])(normal, arc);
        Object(__WEBPACK_IMPORTED_MODULE_1__cartesian__["e" /* cartesianNormalizeInPlace */])(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * Object(__WEBPACK_IMPORTED_MODULE_2__math__["c" /* asin */])(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -__WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */] || angle < __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */] && sum < -__WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */]) ^ (winding & 1);
});


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cartesian__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__circle__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pointEqual__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__index__ = __webpack_require__(176);






/* harmony default export */ __webpack_exports__["a"] = (function(radius) {
  var cr = Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(radius),
      delta = 6 * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */],
      smallRadius = cr > 0,
      notHemisphere = Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* abs */])(cr) > __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */]; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    Object(__WEBPACK_IMPORTED_MODULE_1__circle__["a" /* circleStream */])(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(lambda) * Object(__WEBPACK_IMPORTED_MODULE_2__math__["g" /* cos */])(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */] : -__WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */]), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || Object(__WEBPACK_IMPORTED_MODULE_3__pointEqual__["a" /* default */])(point0, point2) || Object(__WEBPACK_IMPORTED_MODULE_3__pointEqual__["a" /* default */])(point1, point2)) {
            point1[0] += __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */];
            point1[1] += __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */];
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !Object(__WEBPACK_IMPORTED_MODULE_3__pointEqual__["a" /* default */])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["a" /* cartesian */])(a),
        pb = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["a" /* cartesian */])(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["c" /* cartesianCross */])(pa, pb),
        n2n2 = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["d" /* cartesianDot */])(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["c" /* cartesianCross */])(n1, n2),
        A = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["f" /* cartesianScale */])(n1, c1),
        B = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["f" /* cartesianScale */])(n2, c2);
    Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["b" /* cartesianAddInPlace */])(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["d" /* cartesianDot */])(A, u),
        uu = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["d" /* cartesianDot */])(u, u),
        t2 = w * w - uu * (Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["d" /* cartesianDot */])(A, A) - 1);

    if (t2 < 0) return;

    var t = Object(__WEBPACK_IMPORTED_MODULE_2__math__["u" /* sqrt */])(t2),
        q = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["f" /* cartesianScale */])(u, (-w - t) / uu);
    Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["b" /* cartesianAddInPlace */])(q, A);
    q = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["g" /* spherical */])(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* abs */])(delta - __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */]) < __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */],
        meridian = polar || delta < __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */];

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* abs */])(q[0] - lambda0) < __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */] ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */] ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["f" /* cartesianScale */])(u, (-w + t) / uu);
      Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["b" /* cartesianAddInPlace */])(q1, A);
      return [q, Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["g" /* spherical */])(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */] - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_4__index__["a" /* default */])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-__WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */], radius - __WEBPACK_IMPORTED_MODULE_2__math__["o" /* pi */]]);
});


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__length__ = __webpack_require__(183);


var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return Object(__WEBPACK_IMPORTED_MODULE_0__length__["a" /* default */])(object);
});


/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noop__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stream__ = __webpack_require__(32);





var lengthSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    lambda0,
    sinPhi0,
    cosPhi0;

var lengthStream = {
  sphere: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  point: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineStart: lengthLineStart,
  lineEnd: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  polygonStart: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  polygonEnd: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */];
}

function lengthPointFirst(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */];
  lambda0 = lambda, sinPhi0 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi), cosPhi0 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */];
  var sinPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(phi),
      cosPhi = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(phi),
      delta = Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(lambda - lambda0),
      cosDelta = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(delta),
      sinDelta = Object(__WEBPACK_IMPORTED_MODULE_1__math__["t" /* sin */])(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(Object(__WEBPACK_IMPORTED_MODULE_1__math__["e" /* atan2 */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["u" /* sqrt */])(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ __webpack_exports__["a"] = (function(object) {
  lengthSum.reset();
  Object(__WEBPACK_IMPORTED_MODULE_3__stream__["a" /* default */])(object, lengthStream);
  return +lengthSum;
});


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noop__ = __webpack_require__(22);


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  lineEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  polygonStart: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  polygonEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["a"] = (boundsStream);


/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__conicEqualArea__ = __webpack_require__(110);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__conicEqualArea__["b" /* default */])()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
});


/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = equirectangularRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */])(equirectangularRaw)
      .scale(152.63);
});


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = packEnclose;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__enclose__ = __webpack_require__(188);


function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = Object(__WEBPACK_IMPORTED_MODULE_0__enclose__["a" /* default */])(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

/* harmony default export */ __webpack_exports__["a"] = (function(circles) {
  packEnclose(circles);
  return circles;
});


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(431);


/* harmony default export */ __webpack_exports__["a"] = (function(circles) {
  var i = 0, n = (circles = Object(__WEBPACK_IMPORTED_MODULE_0__array__["a" /* shuffle */])(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* slice */].call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
});

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = constantZero;
function constantZero() {
  return 0;
}

/* harmony default export */ __webpack_exports__["b"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
});


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);


/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);


/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__request__ = __webpack_require__(117);


/* harmony default export */ __webpack_exports__["a"] = (function(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = Object(__WEBPACK_IMPORTED_MODULE_0__request__["a" /* default */])(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
});

function responseOf(parse, row) {
  return function(request) {
    return parse(request.responseText, row);
  };
}


/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return implicit; });
/* harmony export (immutable) */ __webpack_exports__["a"] = ordinal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_collection__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(33);



var implicit = {name: "implicit"};

function ordinal(range) {
  var index = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["c" /* map */])(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(__WEBPACK_IMPORTED_MODULE_0_d3_collection__["c" /* map */])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return +x;
});


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calendar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_time__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_time_format__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__array__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__continuous__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__nice__ = __webpack_require__(196);








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_5__continuous__["b" /* default */])(__WEBPACK_IMPORTED_MODULE_5__continuous__["c" /* deinterpolateLinear */], __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["m" /* interpolateNumber */]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["e" /* bisector */])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["A" /* tickStep */])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["A" /* tickStep */])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(__WEBPACK_IMPORTED_MODULE_4__array__["a" /* map */].call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(Object(__WEBPACK_IMPORTED_MODULE_6__nice__["a" /* default */])(d, interval))
        : scale;
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_5__continuous__["a" /* copy */])(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return calendar(__WEBPACK_IMPORTED_MODULE_2_d3_time__["D" /* timeYear */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["n" /* timeMonth */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["B" /* timeWeek */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["a" /* timeDay */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["e" /* timeHour */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["j" /* timeMinute */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["r" /* timeSecond */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["h" /* timeMillisecond */], __WEBPACK_IMPORTED_MODULE_3_d3_time_format__["c" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_time__ = __webpack_require__(75);


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? __WEBPACK_IMPORTED_MODULE_0_d3_time__["P" /* utcMonday */].ceil(week) : Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["P" /* utcMonday */])(week);
          week = __WEBPACK_IMPORTED_MODULE_0_d3_time__["F" /* utcDay */].offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? __WEBPACK_IMPORTED_MODULE_0_d3_time__["l" /* timeMonday */].ceil(week) : Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["l" /* timeMonday */])(week);
          week = __WEBPACK_IMPORTED_MODULE_0_d3_time__["a" /* timeDay */].offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + __WEBPACK_IMPORTED_MODULE_0_d3_time__["a" /* timeDay */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["D" /* timeYear */])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["t" /* timeSunday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["D" /* timeYear */])(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["v" /* timeThursday */])(d) : __WEBPACK_IMPORTED_MODULE_0_d3_time__["v" /* timeThursday */].ceil(d);
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["v" /* timeThursday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["D" /* timeYear */])(d), d) + (Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["D" /* timeYear */])(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["l" /* timeMonday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["D" /* timeYear */])(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + __WEBPACK_IMPORTED_MODULE_0_d3_time__["F" /* utcDay */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["_7" /* utcYear */])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["X" /* utcSunday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["_7" /* utcYear */])(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["Z" /* utcThursday */])(d) : __WEBPACK_IMPORTED_MODULE_0_d3_time__["Z" /* utcThursday */].ceil(d);
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["Z" /* utcThursday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["_7" /* utcYear */])(d), d) + (Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["_7" /* utcYear */])(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(__WEBPACK_IMPORTED_MODULE_0_d3_time__["P" /* utcMonday */].count(Object(__WEBPACK_IMPORTED_MODULE_0_d3_time__["_7" /* utcYear */])(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isoSpecifier; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultLocale__ = __webpack_require__(120);


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : Object(__WEBPACK_IMPORTED_MODULE_0__defaultLocale__["d" /* utcFormat */])(isoSpecifier);

/* harmony default export */ __webpack_exports__["a"] = (formatIso);


/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_path__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__curve_linear__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__line__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__point__ = __webpack_require__(122);






/* harmony default export */ __webpack_exports__["a"] = (function() {
  var x0 = __WEBPACK_IMPORTED_MODULE_4__point__["a" /* x */],
      x1 = null,
      y0 = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(0),
      y1 = __WEBPACK_IMPORTED_MODULE_4__point__["b" /* y */],
      defined = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(true),
      context = null,
      curve = __WEBPACK_IMPORTED_MODULE_2__curve_linear__["a" /* default */],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = Object(__WEBPACK_IMPORTED_MODULE_0_d3_path__["a" /* path */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return Object(__WEBPACK_IMPORTED_MODULE_3__line__["a" /* default */])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return curveRadialLinear; });
/* harmony export (immutable) */ __webpack_exports__["b"] = curveRadial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linear__ = __webpack_require__(76);


var curveRadialLinear = curveRadial(__WEBPACK_IMPORTED_MODULE_0__linear__["a" /* default */]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = lineRadial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__curve_radial__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__line__ = __webpack_require__(121);



function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(Object(__WEBPACK_IMPORTED_MODULE_0__curve_radial__["b" /* default */])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return lineRadial(Object(__WEBPACK_IMPORTED_MODULE_1__line__["a" /* default */])().curve(__WEBPACK_IMPORTED_MODULE_0__curve_radial__["a" /* curveRadialLinear */]));
});


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(50);


/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / __WEBPACK_IMPORTED_MODULE_0__math__["j" /* pi */]);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, __WEBPACK_IMPORTED_MODULE_0__math__["m" /* tau */]);
  }
});


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(50);


var ka = 0.89081309152928522810,
    kr = Math.sin(__WEBPACK_IMPORTED_MODULE_0__math__["j" /* pi */] / 10) / Math.sin(7 * __WEBPACK_IMPORTED_MODULE_0__math__["j" /* pi */] / 10),
    kx = Math.sin(__WEBPACK_IMPORTED_MODULE_0__math__["m" /* tau */] / 10) * kr,
    ky = -Math.cos(__WEBPACK_IMPORTED_MODULE_0__math__["m" /* tau */] / 10) * kr;

/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = __WEBPACK_IMPORTED_MODULE_0__math__["m" /* tau */] * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var sqrt3 = Math.sqrt(3);

/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ __webpack_exports__["a"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CardinalClosed;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noop__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cardinal__ = __webpack_require__(79);



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  areaEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(__WEBPACK_IMPORTED_MODULE_1__cardinal__["c" /* point */])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["b"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CardinalOpen;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cardinal__ = __webpack_require__(79);


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(__WEBPACK_IMPORTED_MODULE_0__cardinal__["c" /* point */])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["b"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = createCell;
/* harmony export (immutable) */ __webpack_exports__["a"] = cellHalfedgeStart;
/* unused harmony export cellHalfedgeEnd */
/* harmony export (immutable) */ __webpack_exports__["d"] = sortCellHalfedges;
/* harmony export (immutable) */ __webpack_exports__["b"] = clipCells;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Edge__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Diagram__ = __webpack_require__(53);



function createCell(site) {
  return __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */].length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */][halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */].length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!__WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */][halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */][halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */][halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] || Math.abs(endY - startY) > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */]) {
          halfedges.splice(iHalfedge, 0, __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */].push(Object(__WEBPACK_IMPORTED_MODULE_0__Edge__["b" /* createBorderEdge */])(site, end,
              Math.abs(endX - x0) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] && y1 - endY > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? [x0, Math.abs(startX - x0) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? startY : y1]
              : Math.abs(endY - y1) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] && x1 - endX > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? [Math.abs(startY - y1) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? startX : x1, y1]
              : Math.abs(endX - x1) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] && endY - y0 > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? [x1, Math.abs(startX - x1) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? startY : y0]
              : Math.abs(endY - y0) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] && endX - x0 > __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? [Math.abs(startY - y0) < __WEBPACK_IMPORTED_MODULE_1__Diagram__["f" /* epsilon */] ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */].push(Object(__WEBPACK_IMPORTED_MODULE_0__Edge__["b" /* createBorderEdge */])(site = cover.site, v00, v01)) - 1,
        __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */].push(Object(__WEBPACK_IMPORTED_MODULE_0__Edge__["b" /* createBorderEdge */])(site, v01, v11)) - 1,
        __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */].push(Object(__WEBPACK_IMPORTED_MODULE_0__Edge__["b" /* createBorderEdge */])(site, v11, v10)) - 1,
        __WEBPACK_IMPORTED_MODULE_1__Diagram__["e" /* edges */].push(Object(__WEBPACK_IMPORTED_MODULE_0__Edge__["b" /* createBorderEdge */])(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][iCell]) {
      if (!cell.halfedges.length) {
        delete __WEBPACK_IMPORTED_MODULE_1__Diagram__["b" /* cells */][iCell];
      }
    }
  }
}


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return firstCircle; });
/* harmony export (immutable) */ __webpack_exports__["a"] = attachCircle;
/* harmony export (immutable) */ __webpack_exports__["b"] = detachCircle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RedBlackTree__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Diagram__ = __webpack_require__(53);



var circlePool = [];

var firstCircle;

function Circle() {
  Object(__WEBPACK_IMPORTED_MODULE_0__RedBlackTree__["a" /* RedBlackNode */])(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -__WEBPACK_IMPORTED_MODULE_1__Diagram__["g" /* epsilon2 */]) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = __WEBPACK_IMPORTED_MODULE_1__Diagram__["c" /* circles */]._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  __WEBPACK_IMPORTED_MODULE_1__Diagram__["c" /* circles */].insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    __WEBPACK_IMPORTED_MODULE_1__Diagram__["c" /* circles */].remove(circle);
    circlePool.push(circle);
    Object(__WEBPACK_IMPORTED_MODULE_0__RedBlackTree__["a" /* RedBlackNode */])(circle);
    arc.circle = null;
  }
}


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Transform;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return identity; });
/* harmony export (immutable) */ __webpack_exports__["b"] = transform;
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwInputs_1 = __webpack_require__(5);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var GwServerEventEnum;
(function (GwServerEventEnum) {
    GwServerEventEnum["STARTED_EDITING"] = "STARTED_EDITING";
    GwServerEventEnum["CANCELED_EDITING"] = "CANCELED_EDITING";
    GwServerEventEnum["COMMITTED"] = "COMMITTED";
    GwServerEventEnum["FAILED_COMMITTING"] = "FAILED_COMMITTING";
})(GwServerEventEnum = exports.GwServerEventEnum || (exports.GwServerEventEnum = {}));
var GwServerEvents = /** @class */ (function (_super) {
    __extends(GwServerEvents, _super);
    function GwServerEvents() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwServerEvents.prototype.getSystemName = function () {
        return "gwServerEvents";
    };
    GwServerEvents.prototype.orderSpecificInit = function () {
        this.processServerEvents();
    };
    GwServerEvents.prototype.processServerEvents = function () {
        var _this = this;
        var serverEvents = gwUtil_1.gwUtil.getUtilityJson("gw-serverEvents");
        if (serverEvents) {
            serverEvents.forEach(function (serverEvent) {
                _this.handleEvent(serverEvent.event, serverEvent.args);
            });
        }
    };
    GwServerEvents.prototype.handleEvent = function (event, args) {
        switch (event) {
            case GwServerEventEnum.STARTED_EDITING:
                this.onStartEditing(args);
                break;
            case GwServerEventEnum.CANCELED_EDITING:
                break;
            case GwServerEventEnum.COMMITTED:
                break;
            case GwServerEventEnum.FAILED_COMMITTING:
                break;
            default:
                throw new Error("Received unknown Server Event: " + event);
        }
    };
    GwServerEvents.prototype.onStartEditing = function (args) {
        var target = args.target;
        var container;
        if (target === "Worksheet") {
            container = gwUtil_1.gwUtil.getDomNode("#gw-south-panel");
        }
        else {
            container = gwUtil_1.gwUtil.getDomNode("#gw-center-panel");
        }
        if (container) {
            gwInputs_1.gwInputs.focusFirstInput(container);
        }
    };
    return GwServerEvents;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwServerEvents = GwServerEvents;
exports.gwServerEvents = new GwServerEvents();


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwKeys_1 = __webpack_require__(23);
var gwFocus_1 = __webpack_require__(8);
var gwForm_1 = __webpack_require__(25);
var gwScroll_1 = __webpack_require__(27);
var gwFileValue_1 = __webpack_require__(219);
var GwOrderDependantInitializableSystem_1 = __webpack_require__(11);
var plApp_1 = __webpack_require__(29);
var GwClientCommand;
(function (GwClientCommand) {
    GwClientCommand["EDITABLE_CONTROLLERS"] = "EDITABLE_CONTROLLERS";
    GwClientCommand["REDIRECT"] = "REDIRECT";
    GwClientCommand["POPUP"] = "POPUP";
    GwClientCommand["REGISTER_KEY_SHORTCUTS"] = "REGISTER_KEY_SHORTCUTS";
    GwClientCommand["REGISTER_DROPZONES"] = "REGISTER_DROPZONES";
    GwClientCommand["DEFERRED_DOWNLOAD"] = "DEFERRED_DOWNLOAD";
    GwClientCommand["FOCUS"] = "FOCUS";
    GwClientCommand["TITLE"] = "TITLE";
})(GwClientCommand = exports.GwClientCommand || (exports.GwClientCommand = {}));
var GwOps = /** @class */ (function (_super) {
    __extends(GwOps, _super);
    function GwOps() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwOps.prototype.getSystemName = function () {
        return "gwOps";
    };
    GwOps.prototype.orderSpecificInit = function () {
        this.processClientOps();
    };
    GwOps.prototype.processClientOps = function () {
        var _this = this;
        var clientCommands = gwUtil_1.gwUtil.getUtilityJson("gw-clientCommands");
        if (clientCommands) {
            clientCommands.forEach(function (clientCommand) {
                _this.handleCommand(clientCommand.command, clientCommand.args);
            });
        }
    };
    GwOps.prototype.handleCommand = function (command, args) {
        switch (command) {
            case GwClientCommand.EDITABLE_CONTROLLERS.valueOf():
                gwForm_1.gwForm.setEditableControllers(args.ec_ids);
                break;
            case GwClientCommand.REDIRECT:
                this.redirect(args.method, args.url, args.postParams, args.isMultiClusterNav);
                break;
            case GwClientCommand.POPUP:
                this.popup(args.url, args.target, args.features);
                break;
            case GwClientCommand.REGISTER_KEY_SHORTCUTS:
                this.registerShortcuts(args);
                break;
            case GwClientCommand.REGISTER_DROPZONES:
                gwFileValue_1.gwFileValue.registerDropzone(args);
                break;
            case GwClientCommand.DEFERRED_DOWNLOAD:
                gwFileValue_1.gwFileValue.downloadManually(args);
                break;
            case GwClientCommand.FOCUS:
                gwFocus_1.gwFocus.forceFocus("#" + args.focusId, false);
                gwScroll_1.gwScroll.saveScrollPositions();
                break;
            case GwClientCommand.TITLE:
                this.setTitle(args.title);
                break;
            default:
                gwUtil_1.gwUtil.devlog("Encountered unknown client command: ", command);
        }
    };
    GwOps.prototype.redirect = function (method, url, parameters, isMultiClusterNav) {
        plApp_1.gwApp.prepareForExitPointNavigation(isMultiClusterNav === "true");
        if (method === "POST") {
            var form = document.createElement("form");
            form.action = url;
            form.method = "POST";
            form.target = "_top";
            if (parameters) {
                for (var name_1 in parameters) {
                    if (parameters.hasOwnProperty(name_1)) {
                        var input = document.createElement("input");
                        input.type = "hidden";
                        input.name = name_1;
                        input.value = parameters[name_1];
                        form.appendChild(input);
                    }
                }
            }
            document.body.appendChild(form);
            form.submit();
        }
        else {
            window.location.href = url;
        }
    };
    GwOps.prototype.popup = function (url, target, features) {
        window.open(url, target, features);
    };
    GwOps.prototype.registerShortcuts = function (shortcutMap) {
        gwKeys_1.gwKeys.clearServerKeyboardShortcuts();
        for (var shortcut in shortcutMap) {
            if (shortcutMap.hasOwnProperty(shortcut)) {
                gwKeys_1.gwKeys.addServerKeyboardShortcut(shortcut, shortcutMap[shortcut]);
            }
        }
    };
    GwOps.prototype.setTitle = function (newTitle) {
        document.title = newTitle;
    };
    return GwOps;
}(GwOrderDependantInitializableSystem_1.GwOrderDependantInitializableSystem));
exports.GwOps = GwOps;
exports.gwOps = new GwOps();


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwDisplayKey_1 = __webpack_require__(16);
var GwFileRequest_1 = __webpack_require__(127);
var gwAjax_1 = __webpack_require__(15);
var GwFileValue = /** @class */ (function (_super) {
    __extends(GwFileValue, _super);
    function GwFileValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fileInputSuffix = "--file";
        _this.fileTextSuffix = "--text";
        return _this;
    }
    GwFileValue.prototype.getSystemName = function () {
        return "gwFileValue";
    };
    GwFileValue.prototype.browseHandler = function (node, args, event) {
        this.getFileInputOrThrow(args.id).click();
        event.preventDefault();
    };
    GwFileValue.prototype.fileChangeHandler = function (node, args, event) {
        var _this = this;
        if (!node.files) {
            return;
        }
        this.uploadFiles(args.id, node.files, function () {
            _this.clearFileInput(node);
            gwUtil_1.gwUtil.refresh();
        });
    };
    GwFileValue.prototype.registerDropzone = function (dropzoneMap) {
        dropzoneMap.dropzoneElementIds.forEach(function (elementId) {
            gwUtil_1.gwUtil.getDomNode("#" + elementId)
                .setAttribute("data-gw-drop", "gwFileValue.dropFileHandler sourceWidgetId:" + dropzoneMap.fileInputElementId);
        });
    };
    GwFileValue.prototype.dropFileHandler = function (node, args, event) {
        var _this = this;
        this.uploadFiles(args.sourceWidgetId, event.dataTransfer.files, function () {
            _this.clearFileInput(_this.getFileInputOrThrow(args.sourceWidgetId));
            gwUtil_1.gwUtil.refresh();
        });
    };
    GwFileValue.prototype.convertToMB = function (size) {
        return Math.round((size / GwFileValue.BYTES_PER_MB) * 10) / 10;
    };
    GwFileValue.prototype.showAlert = function (messageText) {
        alert(messageText);
    };
    GwFileValue.prototype.uploadSizeError = function (sizeLimit, tooBigFileNames) {
        if (!tooBigFileNames || tooBigFileNames.length < 1) {
            return;
        }
        var errMsg = gwDisplayKey_1.gwDisplayKey.get("Web.Client.Document.Upload.Failure.Size", tooBigFileNames.length, this.convertToMB(sizeLimit));
        var maxFilesInMsg = 20;
        var len = Math.min(tooBigFileNames.length, maxFilesInMsg);
        for (var i = 0; i < len; i++) {
            errMsg += "\n\t" + tooBigFileNames[i];
        }
        if (tooBigFileNames.length > maxFilesInMsg) {
            errMsg += "\n\t...";
        }
        this.showAlert(errMsg);
    };
    GwFileValue.prototype.uploadTotalSizeError = function (numRejectedFiles, totalSize, availableSpace) {
        if (totalSize <= 0) {
            return;
        }
        this.showAlert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.Document.Upload.Failure.TotalSize", numRejectedFiles, this.convertToMB(totalSize), this.convertToMB(availableSpace)));
    };
    GwFileValue.prototype.uploadTotalCountError = function (numRejectedFiles, availableCount) {
        if (numRejectedFiles <= 0) {
            return;
        }
        this.showAlert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.Document.Upload.Failure.TotalCount", numRejectedFiles, availableCount));
    };
    GwFileValue.prototype.uploadOtherError = function (otherErrors) {
        var otherErrorCount = otherErrors.length;
        if (otherErrorCount < 1) {
            return;
        }
        var errMsg = "";
        var maxOtherErrorsInMsg = 20;
        otherErrors.length = maxOtherErrorsInMsg;
        otherErrors.forEach(function (otherError) {
            if (otherError !== 0) {
                errMsg += "\n";
            }
            // TODO: html encode otherErrors[otherError]
            errMsg += otherErrors[otherError];
        });
        if (otherErrorCount > maxOtherErrorsInMsg) {
            errMsg += "\n...";
        }
        this.showAlert(errMsg);
    };
    GwFileValue.prototype.processUploadResponse = function (response) {
        if (response.errors) {
            for (var errorGeneralIndex in response.errors.errorGeneral) {
                if (response.errors.errorGeneral.hasOwnProperty(errorGeneralIndex)) {
                    this.showAlert(response.errors.errorGeneral[errorGeneralIndex]);
                }
            }
            if (response.errors.errorReasonSize) {
                this.uploadSizeError(response.errors.errorReasonSize.sizeLimit, response.errors.errorReasonSize.files);
            }
            if (response.errors.errorReasonTotalSize) {
                if (response.errors.errorReasonTotalSize.rejectedDueToSizeCount) {
                    this.uploadTotalSizeError(response.errors.errorReasonTotalSize.rejectedDueToSizeCount, response.errors.errorReasonTotalSize.spaceRequested, response.errors.errorReasonTotalSize.availableSpace);
                }
                if (response.errors.errorReasonTotalSize.rejectedDueToQuotaExceededCount) {
                    this.uploadTotalCountError(response.errors.errorReasonTotalSize.rejectedDueToQuotaExceededCount, response.errors.errorReasonTotalSize.availableCount);
                }
            }
            if (response.errors.errorReasonOther) {
                this.uploadOtherError(response.errors.errorReasonOther);
            }
        }
        return response.success;
    };
    GwFileValue.prototype.verifyUploadFiles = function (fileWidgetId, files) {
        var fileWidget = document.getElementById(fileWidgetId);
        if (fileWidget) {
            var uploadFileInfoJsonStr = fileWidget.getAttribute("data-gw-file-info");
            if (uploadFileInfoJsonStr) {
                var uploadFileInfo = JSON.parse(uploadFileInfoJsonStr);
                var filteredFiles = [];
                var tooBigFileNames = [];
                var totalSize = 0;
                // First calculate the total upload size of all files that
                // do not exceed the individual size limit
                var len = files.length;
                if (uploadFileInfo.hasOwnProperty("maxFileSize")) {
                    for (var i = 0; i < len; i++) {
                        if (files[i].size <= uploadFileInfo.maxFileSize) {
                            filteredFiles[filteredFiles.length] = files[i];
                            totalSize += files[i].size;
                        }
                        else {
                            tooBigFileNames.push(files[i].name);
                        }
                    }
                    // Show an alert for individual files too big
                    if (tooBigFileNames.length > 0) {
                        this.uploadSizeError(uploadFileInfo.maxFileSize, tooBigFileNames);
                        return false;
                    }
                    // Don't bother continuing if no files qualified for upload
                    if (filteredFiles.length <= 0) {
                        gwUtil_1.gwUtil.devlog("Could not find any qualified files.");
                        return false;
                    }
                }
                // Reject the entire upload if the total size is too big
                // Note that 'availableSpace' may be less than 'totalSizeLimit' because of prior files
                // uploaded in this session that have not yet been committed.
                if (uploadFileInfo.hasOwnProperty("availableSpace") && (totalSize > uploadFileInfo.availableSpace)) {
                    this.uploadTotalSizeError(filteredFiles.length, totalSize, uploadFileInfo.availableSpace);
                    return false;
                }
                // Reject the entire upload if the total count is too big
                // Note that 'availableCount' may be less than 'countLimit' because of prior files
                // uploaded in this session that have not yet been committed.
                if (uploadFileInfo.hasOwnProperty("maxFileUploadCount") && uploadFileInfo.maxFileUploadCount > 0 &&
                    filteredFiles.length > uploadFileInfo.availableFileUploadCount) {
                    this.uploadTotalCountError(filteredFiles.length, uploadFileInfo.availableFileUploadCount);
                    return false;
                }
            }
        }
        return true;
    };
    GwFileValue.prototype.uploadFiles = function (fileWidgetId, files, completeCallback) {
        var _this = this;
        if (!this.verifyUploadFiles(fileWidgetId, files)) {
            return;
        }
        var $fileText = $("#" + fileWidgetId + this.fileTextSuffix).first();
        $fileText.val(this.fileName(files));
        var xhr = new XMLHttpRequest();
        xhr.open("POST", gwUtil_1.gwUtil.getUtilityInfo("fileUploadUrl"));
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        xhr.send(this.createFormData(fileWidgetId, files));
        xhr.addEventListener("load", function () {
            // TODO skwon: Any way we can determine whether it is actually json?  Response type?  Tie to return code?
            var data = JSON.parse(xhr.response);
            _this.processUploadResponse(data);
            completeCallback();
            _this.postOnChange(fileWidgetId);
        });
    };
    GwFileValue.prototype.downloadManually = function (parameters) {
        var isInline = parameters.contentDisposition === "inline";
        new GwFileRequest_1.GwFileRequest(isInline).downloadDirectly({
            widgetId: parameters.fileInputElementId,
            contentDisposition: parameters.contentDisposition
        });
    };
    GwFileValue.prototype.downloadHandler = function (node, args, event) {
        new GwFileRequest_1.GwFileRequest(args.inline === "true")
            .postDownloadRequest(args.id + args.suffix);
    };
    GwFileValue.prototype.postOnChange = function (fileWidgetId) {
        var postOnChange = this.getFileInputOrThrow(fileWidgetId).getAttribute("data-gw-postOnChange");
        if (postOnChange === "refresh") {
            gwUtil_1.gwUtil.refresh(fileWidgetId);
        }
    };
    GwFileValue.prototype.getFileInput = function (fileWidgetId) {
        return gwUtil_1.gwUtil.getInputElement("#" + fileWidgetId + this.fileInputSuffix);
    };
    GwFileValue.prototype.getFileInputOrThrow = function (fileWidgetId) {
        var fileInput = this.getFileInput(fileWidgetId);
        if (fileInput === null) {
            throw new Error("Unable to locate file input widget for: " + fileWidgetId);
        }
        return fileInput;
    };
    GwFileValue.prototype.fileName = function (files) {
        var name = "";
        for (var i = 0; i < files.length; i++) {
            if (i !== 0) {
                name += " ";
            }
            name += files.item(i).name;
        }
        return name;
    };
    GwFileValue.prototype.createFormData = function (widgetId, files) {
        var fd = new FormData();
        fd.append("widgetId", widgetId);
        for (var i = 0; i < files.length; i++) {
            fd.append("fileContent", files.item(i));
        }
        fd.append(gwUtil_1.gwUtil.CSRF_PARAM_NAME, gwAjax_1.gwAjax.getCsrfToken());
        return fd;
    };
    GwFileValue.prototype.clearFileInput = function (fileInput) {
        fileInput.setAttribute("value", "");
    };
    GwFileValue.BYTES_PER_MB = 1048576;
    return GwFileValue;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwFileValue = GwFileValue;
exports.gwFileValue = new GwFileValue();


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwReflection_1 = __webpack_require__(54);
var gwUtil_1 = __webpack_require__(0);
var gwInputs_1 = __webpack_require__(5);
var gwCheckboxGroup_1 = __webpack_require__(129);
var gwDateValue_1 = __webpack_require__(55);
var gwRangeRadio_1 = __webpack_require__(130);
var GwReflectionType;
(function (GwReflectionType) {
    GwReflectionType[GwReflectionType["readonly"] = 0] = "readonly";
    GwReflectionType[GwReflectionType["input"] = 1] = "input";
    GwReflectionType[GwReflectionType["checkbox"] = 2] = "checkbox";
    GwReflectionType[GwReflectionType["checkboxGroup"] = 3] = "checkboxGroup";
    GwReflectionType[GwReflectionType["radioRange"] = 4] = "radioRange";
    GwReflectionType[GwReflectionType["dateInput"] = 5] = "dateInput";
    GwReflectionType[GwReflectionType["NULL"] = 6] = "NULL";
})(GwReflectionType = exports.GwReflectionType || (exports.GwReflectionType = {}));
var GwReflectionTrigger = /** @class */ (function () {
    function GwReflectionTrigger(triggerNode) {
        this.listeners = [];
        this.reflectionType = GwReflectionType.NULL;
        this.id = triggerNode.id;
        this.widget = triggerNode;
    }
    GwReflectionTrigger.prototype.setReflectionType = function (t) {
        this.reflectionType = t;
    };
    GwReflectionTrigger.prototype.getValue = function () {
        if (this.reflectionType === GwReflectionType.NULL) {
            return;
        }
        if (this.reflectionType === GwReflectionType.readonly) {
            var reflectorNode = gwUtil_1.gwUtil.getDomNode(".gw-value-reflector", this.widget);
            if (!reflectorNode) {
                console.warn("Read only element: #" + this.id + " needs to be a reflector in order to reflect values further");
                return;
            }
            return reflectorNode.innerText;
        }
        if (this.reflectionType === GwReflectionType.input) {
            return gwInputs_1.gwInputs.getValueById(this.id);
        }
        if (this.reflectionType === GwReflectionType.checkbox) {
            var node = gwUtil_1.gwUtil.getDomNodeByAttr("name", this.id, this.widget);
            if (!node) {
                return;
            }
            return gwInputs_1.gwInputs.getValueAsBoolean(node);
        }
        if (this.reflectionType === GwReflectionType.checkboxGroup) {
            return gwCheckboxGroup_1.gwCheckboxGroup.getValues(this.widget);
        }
        if (this.reflectionType === GwReflectionType.radioRange) {
            return gwRangeRadio_1.gwRangeRadio.getValue(this.widget);
        }
        if (this.reflectionType === GwReflectionType.dateInput) {
            return gwDateValue_1.gwDateValue.getValue(this.widget);
        }
    };
    /**
     * Returns true, if this triggered has already triggered
     */
    GwReflectionTrigger.prototype.hasTriggered = function () {
        return gwReflection_1.gwReflection.cycleEventsCache.indexOf(this.id) !== -1;
    };
    /**
     * Dispatch trigger change event.
     * @param isDirectChange indicates that this change is direct event from the input. false, by default
     */
    GwReflectionTrigger.prototype.dispatchChangeEvent = function (isDirectChange) {
        if (isDirectChange === void 0) { isDirectChange = false; }
        if (gwReflection_1.gwReflection.cycleEventsCache.indexOf(this.id) === -1) {
            gwReflection_1.gwReflection.cycleEventsCache.push(this.id);
        }
        this.listeners.forEach(function (listener) { return listener(isDirectChange); });
    };
    GwReflectionTrigger.prototype.addChangeListener = function (listener) {
        this.listeners.push(listener);
    };
    /**
     * For internal use. All direct changes need to trigger events with use of this function.
     * @private
     */
    GwReflectionTrigger.prototype.internalDispatchChangeEvent = function () {
        gwReflection_1.gwReflection.cycleEventsCache = [];
        this.dispatchChangeEvent(true);
    };
    return GwReflectionTrigger;
}());
exports.GwReflectionTrigger = GwReflectionTrigger;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var GwShuttleBoxInfo_1 = __webpack_require__(222);
var GwRangeValue = /** @class */ (function (_super) {
    __extends(GwRangeValue, _super);
    function GwRangeValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwRangeValue.prototype.getSystemName = function () {
        return "gwRangeValue";
    };
    GwRangeValue.prototype.getShuttleBoxInputs = function (classIdTagOrNode) {
        var parent = exports.gwRangeValue.getRangeShuttleWidgetNode(classIdTagOrNode);
        if (!parent) {
            throw new Error("cannot find parent for range shuttle widget");
        }
        return new GwShuttleBoxInfo_1.GwShuttleBoxInfo(parent);
    };
    GwRangeValue.prototype.getRangeShuttleWidgetNode = function (classIdTagOrNode) {
        return gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(gwUtil_1.gwUtil.getDomNode(classIdTagOrNode), "gw-RangeShuttleValueWidget");
    };
    GwRangeValue.prototype.updateHidden = function (shuttleBoxInfo, node, selectedState) {
        if (!node || !node.value) {
            throw new Error("Node is invalid for updates");
        }
        for (var i = 0; i < shuttleBoxInfo.hidden.children.length; i++) {
            var hidden = shuttleBoxInfo.hidden.children[i];
            if (hidden && hidden.value && hidden.value === node.value) {
                hidden.selected = selectedState;
                return;
            }
        }
        throw new Error("Node does not exist in hidden");
    };
    GwRangeValue.prototype.setOptions = function (classIdTagOrNode, options) {
        var select = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        while (select.firstChild) {
            select.removeChild(select.firstChild);
        }
        options
            .map(function (option) {
            var htmlOption = document.createElement("option");
            htmlOption.value = option.key;
            htmlOption.innerText = option.label;
            return htmlOption;
        })
            .forEach(function (htmlOption) {
            select.add(htmlOption);
        });
    };
    GwRangeValue.prototype.setValue = function (classIdTagOrNode, value) {
        gwUtil_1.gwUtil.setOptionOnSelect(classIdTagOrNode, value);
    };
    GwRangeValue.prototype.setValues = function (classIdTagOrNode, values) {
        gwUtil_1.gwUtil.setOptionsOnSelect(classIdTagOrNode, values);
    };
    GwRangeValue.prototype.isMultiple = function (classIdTagOrNode) {
        var select = gwUtil_1.gwUtil.getDomNode(classIdTagOrNode);
        if (select) {
            return select.hasAttribute("multiple");
        }
        return false;
    };
    // TODO: currently a similar check is done in the renderer, but that check is not based on if anything is actually highlighted
    // the real UX for this would be to only highlight the button if something was highlighted in the relevant list
    GwRangeValue.prototype.updateButtons = function (shuttleBoxInfo) {
        var parent = shuttleBoxInfo.parent;
        var leftButton = gwUtil_1.gwUtil.getDomNodeOrThrow(".gw-shuttle-left-button", parent);
        var rightButton = gwUtil_1.gwUtil.getDomNodeOrThrow(".gw-shuttle-right-button", parent);
        var leftSelectHasOptions = shuttleBoxInfo.left.getElementsByTagName("option").length > 0;
        var rightSelectHasOptions = shuttleBoxInfo.right.getElementsByTagName("option").length > 0;
        gwUtil_1.gwUtil.conditionalAddRemoveClass(!leftSelectHasOptions, rightButton, "gw-disabled");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(!rightSelectHasOptions, leftButton, "gw-disabled");
        if (leftSelectHasOptions) {
            shuttleBoxInfo.left.removeAttribute("disabled");
        }
        if (rightSelectHasOptions) {
            shuttleBoxInfo.right.removeAttribute("disabled");
        }
    };
    GwRangeValue.prototype.moveRight = function (buttonEl) {
        var shuttleSelect = this.getShuttleBoxInputs(buttonEl);
        for (var i = shuttleSelect.left.children.length - 1; i >= 0; i--) {
            var option = shuttleSelect.left.children[i];
            if (option.selected) {
                shuttleSelect.right.appendChild(option.cloneNode(true));
                shuttleSelect.left.removeChild(option);
                this.updateHidden(shuttleSelect, option, true);
            }
        }
        this.updateButtons(shuttleSelect);
        if (this.needsRefresh(buttonEl)) {
            gwUtil_1.gwUtil.refresh(); //TODO: this was passing the node here, which was doing nothing
        }
    };
    GwRangeValue.prototype.moveLeft = function (buttonEl) {
        var shuttleSelect = this.getShuttleBoxInputs(buttonEl);
        for (var i = shuttleSelect.right.children.length - 1; i >= 0; i--) {
            var option = shuttleSelect.right.children[i];
            if (option.selected) {
                shuttleSelect.left.appendChild(option.cloneNode(true));
                shuttleSelect.right.removeChild(option);
                this.updateHidden(shuttleSelect, option, false);
            }
        }
        this.updateButtons(shuttleSelect);
        if (this.needsRefresh(buttonEl)) {
            gwUtil_1.gwUtil.refresh(); //TODO: this was passing the node here, which was doing nothing
        }
    };
    GwRangeValue.prototype.needsRefresh = function (classIdTagOrNode) {
        var node = gwUtil_1.gwUtil.getDomNodeOrThrow(classIdTagOrNode);
        var widget = gwEvents_1.gwEvents.findEnclosingWidget(node);
        return !!widget && widget.getAttribute("data-gw-change") === "refresh";
    };
    return GwRangeValue;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwRangeValue = GwRangeValue;
exports.gwRangeValue = new GwRangeValue();


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwShuttleBoxInfo = /** @class */ (function () {
    function GwShuttleBoxInfo(parentWidgetForRangeShuttle) {
        var shuttleSelects = parentWidgetForRangeShuttle.getElementsByTagName("select");
        this.left = shuttleSelects[1];
        this.right = shuttleSelects[2];
        this.hidden = shuttleSelects[0];
        this.parent = parentWidgetForRangeShuttle;
    }
    return GwShuttleBoxInfo;
}());
exports.GwShuttleBoxInfo = GwShuttleBoxInfo;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwInputs_1 = __webpack_require__(5);
var gwAjax_1 = __webpack_require__(15);
var GwSumReflection = /** @class */ (function (_super) {
    __extends(GwSumReflection, _super);
    function GwSumReflection() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.updatedValues = {};
        return _this;
    }
    GwSumReflection.prototype.getSystemName = function () {
        var t = "gwSumReflection";
        return t;
    };
    GwSumReflection.prototype.clearValues = function () {
        this.updatedValues = {};
    };
    GwSumReflection.prototype.updateValue = function (node, args) {
        var sumValueWidgetId = args.sumValueWidgetId;
        if (!this.updatedValues.hasOwnProperty(sumValueWidgetId)) {
            this.updatedValues[sumValueWidgetId] = {};
        }
        this.updatedValues[sumValueWidgetId][node.id] = gwInputs_1.gwInputs.getValueById(node.id);
        this.recalculateSum(sumValueWidgetId, node);
    };
    GwSumReflection.prototype.recalculateSum = function (sumValueWidgetId, inputNode) {
        var requestObject = {
            sumValueWidgetId: sumValueWidgetId,
            updatedValues: this.updatedValues[sumValueWidgetId]
        };
        var requestParams = {};
        requestParams["__calcSum"] = JSON.stringify(requestObject);
        gwAjax_1.gwAjax.ajaxRequest(requestParams, this.handleResponse.bind(this, sumValueWidgetId, inputNode), this.handleError.bind(this, inputNode));
    };
    /**
     * Handles a response from the server with the reflected value.
     */
    GwSumReflection.prototype.handleResponse = function (sumValueWidgetId, inputNode, response) {
        if (response["ready"] === true) {
            gwInputs_1.gwInputs.clearInvalidValueStatus(inputNode);
            var sum = response["sum"];
            var altSum = response["altSum"];
            if (altSum === undefined) {
                this.updateSumValue(sumValueWidgetId, sum);
            }
            else {
                this.updateSumAndAltSumValue(sumValueWidgetId, sum, altSum);
            }
        }
        return;
    };
    GwSumReflection.prototype.updateSumValue = function (sumValueWidgetId, sumValue) {
        var node = document.querySelector("#" + sumValueWidgetId + " .gw-vw--value");
        node.innerText = sumValue;
    };
    GwSumReflection.prototype.updateSumAndAltSumValue = function (sumValueWidgetId, sumValue, altSumValue) {
        var node = document.querySelector("#" + sumValueWidgetId + " .gw-SumValue--modelValue");
        node.innerText = sumValue;
        var altSumNode = document.querySelector("#" + sumValueWidgetId + " .gw-SumValue--altValue");
        altSumNode.innerText = altSumValue;
    };
    GwSumReflection.prototype.handleError = function (inputNode, errorType, response) {
        gwInputs_1.gwInputs.addInvalidValueStatus(inputNode);
        return 1 /* UNABLE_TO_PROCESS */;
    };
    return GwSumReflection;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwSumReflection = GwSumReflection;
exports.gwSumReflection = new GwSumReflection();


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwFocus_1 = __webpack_require__(8);
var GwInitializableSystem_1 = __webpack_require__(4);
var gwUtil_1 = __webpack_require__(0);
var gwAnimation_1 = __webpack_require__(57);
var gwSouthPanel_1 = __webpack_require__(131);
var GwMessages = /** @class */ (function (_super) {
    __extends(GwMessages, _super);
    function GwMessages() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.NAV_ATTR = "data-gw-nav";
        _this.ERROR_CLASS = "gw-navHasErrors";
        _this.WARNING_CLASS = "gw-navHasWarnings";
        _this.ERROR_QUICK_BUTTON_ID = "gw-quickErrorButton";
        _this.focusElementOnNextPageLoad = null;
        _this.errorsOnCurrentPage = false;
        _this.possiblyHighlightErrorButton = false;
        return _this;
    }
    GwMessages.prototype.getSystemName = function () {
        return "gwMessages";
    };
    /**
     * @Optimize, could do this entire init method server side and mark elements there, instead of modifying the dom here
     * Marks any widgets that lead to the destination of the errors as being in an error state.
     * If there's a focusElementOnNextPageLoad, then moves the focus to that element.
     */
    GwMessages.prototype.init = function () {
        this.updateWebMessageIndicators();
    };
    GwMessages.prototype.updateWebMessageIndicators = function () {
        var _this = this;
        //@Optimize
        //Remove any error classes we've added previously to nav elements
        gwUtil_1.gwUtil.removeClass("." + this.ERROR_CLASS, this.ERROR_CLASS);
        gwUtil_1.gwUtil.removeClass("." + this.WARNING_CLASS, this.WARNING_CLASS);
        this.possiblyHighlightErrorButton = !this.errorsOnCurrentPage;
        this.errorsOnCurrentPage = false;
        this.iterateMessagesWidgetsWithErrors(function (messagesWidget) {
            _this.errorsOnCurrentPage = true;
            var southPanelAsParent = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(messagesWidget, "gw-south-panel");
            if (southPanelAsParent) {
                gwUtil_1.gwUtil.addClass(southPanelAsParent, _this.ERROR_CLASS);
            }
        });
        // If we hadn't seen any errors before, and now found one, then blink the button
        this.possiblyHighlightErrorButton = this.possiblyHighlightErrorButton && this.errorsOnCurrentPage;
        //If a messageGroup points to an off page element error, then we'll highlight the nav element that takes you there
        var messageGroups = gwUtil_1.gwUtil.getDomNodesByAttr(this.NAV_ATTR);
        gwUtil_1.gwUtil.forEach(messageGroups, function (messageGroup) {
            _this.markNavElementAsHavingErrors(messageGroup.getAttribute(_this.NAV_ATTR), gwUtil_1.gwUtil.hasClass(messageGroup, "gw-MessagesWidget--group-warning"));
        });
        if (this.focusElementOnNextPageLoad) {
            this.highlight(null, { id: this.focusElementOnNextPageLoad });
            this.focusElementOnNextPageLoad = null;
        }
        this.updateQuickErrorButton();
    };
    GwMessages.prototype.updateQuickErrorButton = function () {
        var button = this.getQuickErrorButtonOrThrow();
        gwUtil_1.gwUtil.conditionalAddRemoveClass(this.errorsOnCurrentPage, button, "gw-hasErrors");
        if (this.possiblyHighlightErrorButton) {
            gwAnimation_1.gwAnimation.addAnimation(button, "hugepulse");
        }
    };
    GwMessages.prototype.willFocusElementOnNextPageLoad = function () {
        return !!this.focusElementOnNextPageLoad;
    };
    GwMessages.prototype.getQuickErrorButtonOrThrow = function () {
        var button = document.getElementById(this.ERROR_QUICK_BUTTON_ID);
        if (!button) {
            throw new Error("missing quick error button at id: " + this.ERROR_QUICK_BUTTON_ID);
        }
        return button;
    };
    GwMessages.prototype.iterateMessagesWidgetsWithErrors = function (cb) {
        gwUtil_1.gwUtil.forEach(gwUtil_1.gwUtil.getDomNodes(".gw-MessagesWidget--group-error"), function (errorGroup) {
            var messagesWidget = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(errorGroup, ".gw-MessagesWidget");
            if (messagesWidget && !gwUtil_1.gwUtil.hasAnyClass(messagesWidget, ["gw-hidden", "gw-placeholder"])) {
                cb(messagesWidget);
            }
        });
    };
    GwMessages.prototype.quickErrorButton = function (el, args) {
        this.iterateMessagesWidgetsWithErrors(function (messagesWidget) {
            var southPanelAsParent = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(messagesWidget, "gw-south-panel");
            if (southPanelAsParent) {
                gwSouthPanel_1.gwSouthPanel.unMinimize();
            }
            var webMessage = messagesWidget.querySelector(".gw-WebMessage");
            if (webMessage) {
                var subGroup = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(webMessage, ".gw-MessagesWidget--severity-sub-group");
                if (subGroup === null) {
                    return;
                }
                gwUtil_1.gwUtil.removeClass(subGroup, "gw-collapsed");
                // If we found a webMessage in an unknown destination group, then it won't be focusable, so focus the toggle button
                // NOTE: Disabled animate on focus for now; Chrome on Mac OS seems to have problems applying this animation - works
                // in Windows Chrome, Mac/Win Firefox.  Win IE 11 doesn't run the animation but it does not render strangely
                // like Chrome on Mac OS.
                if (gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(subGroup, "gw-MessagesWidget--group-UNKNOWN") !== null) {
                    var toggleButton = subGroup.querySelector(".gw-toggle-button");
                    gwFocus_1.gwFocus.forceFocus(toggleButton, false);
                }
                else {
                    gwFocus_1.gwFocus.forceFocus(webMessage, false);
                }
            }
        });
    };
    GwMessages.prototype.toggleGroup = function (el, args) {
        var group = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(el, ".gw-MessagesWidget--destination-group");
        if (!group) {
            return;
        }
        gwUtil_1.gwUtil.toggleClass(group, "gw-collapsed");
    };
    /**
     * Toggles the group of messages open or closed.
     */
    GwMessages.prototype.toggleSubGroup = function (el, args) {
        var group = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(el, ".gw-MessagesWidget--severity-sub-group");
        if (!group) {
            return;
        }
        gwUtil_1.gwUtil.toggleClass(group, "gw-collapsed");
    };
    GwMessages.prototype.markNavElementAsHavingErrors = function (navId, hasOnlyWarnings) {
        if (hasOnlyWarnings === void 0) { hasOnlyWarnings = false; }
        gwUtil_1.gwUtil.addClass("#" + navId, hasOnlyWarnings ? this.WARNING_CLASS : this.ERROR_CLASS);
    };
    // Widget ID specific methods
    /**
     * Move the focus to a field, animate it to show it, which will also scroll the page to include it if not currently visible.
     */
    GwMessages.prototype.highlight = function (el, args) {
        gwFocus_1.gwFocus.forceFocus("#" + args.id, true);
    };
    /**
     * Requires the NAV_ATTR to be present on the element.
     * If present, then fires the event of the associated navigation element.
     */
    GwMessages.prototype.navigate = function (el, args) {
        var navOwner = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(el, "gw-MessagesWidget--destination-group");
        if (!navOwner) {
            throw new Error("Could not find parent group for Message Widget." + (el.id || el.name || el.innerHTML));
        }
        var navId = navOwner.getAttribute(this.NAV_ATTR);
        if (navId) {
            if (args.next) {
                this.focusElementOnNextPageLoad = args.next;
            }
            gwUtil_1.gwUtil.fireEvent(navId + args.suffix);
        }
    };
    /**
     * If the web message widget has an action listener, then it has specific functionality to fire an event,
     * passing the parameter of the the WebMessage source id.
     */
    GwMessages.prototype.action = function (el, args) {
        gwUtil_1.gwUtil.setEventParam("action", args.param.replace(/\+\+actionValue\+colon\+\+/g, ":")); //TODO: undo, right now the action string comes down with :'s in it, and the event system parses them as args.
        gwUtil_1.gwUtil.fireEvent(args.id + args.suffix);
    };
    return GwMessages;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwMessages = GwMessages;
exports.gwMessages = new GwMessages();


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwResizer_1 = __webpack_require__(35);
var gwMenus_1 = __webpack_require__(26);
var gwStorage_1 = __webpack_require__(24);
var GwDraggableSystem_1 = __webpack_require__(83);
var gwUtil_1 = __webpack_require__(0);
var GwWestPanel = /** @class */ (function (_super) {
    __extends(GwWestPanel, _super);
    function GwWestPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.westPanelLastActiveIDs = "WestPanel.lastActive";
        _this.westPanelMinKey = "WestPanel_Min";
        _this.westPanelSizeKey = "WestPanel.size";
        _this.westPanelSnapLine = 80; //TODO: could make this a preference
        /**
         * Used to calculate the offset of the drag bar from it's original position.
         * @type gw.Point
         */
        _this.startPos = null;
        return _this;
    }
    GwWestPanel.prototype.getSystemName = function () {
        return "gwWestPanel";
    };
    GwWestPanel.prototype.init = function () {
        this._restoreWestPanel();
    };
    /**
     * @public
     * Toggles the WestPanel expanding or collapsing.
     */
    GwWestPanel.prototype.toggleMinMax = function () {
        gwStorage_1.gwStorage.toggleFlag(this.westPanelMinKey);
        this.restoreWestPanelWidth();
        gwResizer_1.gwResizer.check();
    };
    /**
     * Only used by gwStorage.registerComponentRestoreFunction.
     * Restores the various client only UI settings relating to the west panel.
     */
    GwWestPanel.prototype._restoreWestPanel = function () {
        this.openLastActiveMenuItem();
        this.restoreWestPanelWidth();
    };
    /**
     * We diff-replace the currently open active menu in the west panel when the user switches to a new location, which closes the menu, which is undesired.
     * So now we save off the last active menus and open them all up again after the diff.
     */
    GwWestPanel.prototype.openLastActiveMenuItem = function () {
        var lastIds = gwStorage_1.gwStorage.get(this.westPanelLastActiveIDs);
        if (Array.isArray(lastIds)) {
            lastIds.forEach(function (id) {
                var el = document.getElementById(id);
                if (el) {
                    gwMenus_1.gwMenus.openSubMenu(el);
                }
            });
        }
        var newIds = [];
        gwUtil_1.gwUtil.forEach(this.getWestPanelEl().querySelectorAll(".gw-staticMenus.gw-active"), function (el) {
            if (el.hasAttribute("id")) {
                newIds.push(el.id);
            }
        });
        gwStorage_1.gwStorage.set(this.westPanelLastActiveIDs, newIds);
    };
    GwWestPanel.prototype.toggleActionMenu = function () {
        gwMenus_1.gwMenus.toggleSubMenu(".gw-MenuActionsWidget");
    };
    /**
     * Dragging
     */
    GwWestPanel.prototype.setWestPanelSizingOnEvent = function (el, args, e) {
        var mousePos = gwUtil_1.gwUtil.getMousePosition(el, e);
        var pixelWidth = mousePos.x;
        this.setWestPanelSizing(pixelWidth);
        gwResizer_1.gwResizer.check();
    };
    GwWestPanel.prototype.restoreWestPanelWidth = function (recalculateCenterPanel) {
        if (recalculateCenterPanel === void 0) { recalculateCenterPanel = true; }
        var width = gwStorage_1.gwStorage.get(this.westPanelSizeKey) || null;
        var isMin = gwStorage_1.gwStorage.get(this.westPanelMinKey);
        if (isMin) {
            width = "min";
        }
        this.setWestPanelSizing(width, recalculateCenterPanel);
    };
    GwWestPanel.prototype.setWestPanelSizing = function (pixelWidth, recalculateCenterPanel) {
        if (recalculateCenterPanel === void 0) { recalculateCenterPanel = true; }
        var wp = this.getWestPanelEl();
        if (!wp) {
            return;
        }
        if (pixelWidth) {
            if (pixelWidth === "min" || (typeof pixelWidth === "number" && pixelWidth < this.westPanelSnapLine)) {
                gwStorage_1.gwStorage.set(this.westPanelMinKey, true);
                pixelWidth = null;
            }
        }
        if (pixelWidth) {
            pixelWidth = +pixelWidth;
            var maxWidth = gwResizer_1.gwResizer.windowWidth ? (gwResizer_1.gwResizer.windowWidth * .8) : pixelWidth;
            pixelWidth = Math.min(pixelWidth, maxWidth);
            pixelWidth = Math.max(pixelWidth, this.westPanelSnapLine);
            gwStorage_1.gwStorage.set(this.westPanelSizeKey, pixelWidth);
            gwStorage_1.gwStorage.set(this.westPanelMinKey, false);
            wp.style.width = pixelWidth + "px";
        }
        else {
            wp.style.width = "";
        }
        var isMin = gwStorage_1.gwStorage.get(this.westPanelMinKey);
        gwUtil_1.gwUtil.conditionalAddRemoveClass(isMin, "#gw-west-panel", ".gw-makeWestPanel--min");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(isMin, ".gw-MenuActionsWidget", ".gw-makeWestPanel--min");
        if (recalculateCenterPanel) {
            gwResizer_1.gwResizer.recalcCenterPanel();
        }
    };
    GwWestPanel.prototype.getWestPanelEl = function () {
        var westPanelEl = document.getElementById("gw-west-panel");
        if (!westPanelEl) {
            throw new Error("Unable to locate the west panel element");
        }
        return westPanelEl;
    };
    GwWestPanel.prototype.moveDragBarTo = function (el, e) {
        var mousePos = gwUtil_1.gwUtil.getMousePosition(el, e);
        if (!this.startPos) {
            throw new Error("found null start position");
        }
        el.style.top = "0";
        el.style.right = (this.startPos.x - mousePos.x) + "px";
    };
    GwWestPanel.prototype.resetDragBar = function (el) {
        el.style.right = null;
        el.style.top = null;
    };
    /**
     * Called by draggable.js
     * @param el
     * @param args
     * @param e
     */
    GwWestPanel.prototype.drag = function (el, args, e) {
        this.moveDragBarTo(el, e);
    };
    /**
     * Called by draggable.js
     * @param el
     * @param args
     * @param e
     */
    GwWestPanel.prototype.dragStart = function (el, args, e) {
        gwUtil_1.gwUtil.addClass(this.getWestPanelEl(), "gw-beingResized");
        this.startPos = gwUtil_1.gwUtil.getMousePosition(el, e);
        this.moveDragBarTo(el, e);
    };
    /**
     * Called by draggable.js
     * @param el
     * @param args
     * @param e
     */
    GwWestPanel.prototype.dragEnd = function (el, args, e) {
        this.resetDragBar(el);
        gwUtil_1.gwUtil.removeClass(this.getWestPanelEl(), "gw-beingResized");
        this.setWestPanelSizingOnEvent(el, args, e);
        this.startPos = null;
    };
    /**
     * Called by draggable.js
     * @param el
     * @param args
     * @param e
     */
    GwWestPanel.prototype.dragCancel = function (el, args, e) {
        this.resetDragBar(el);
        gwUtil_1.gwUtil.removeClass(this.getWestPanelEl(), "gw-beingResized");
        this.setWestPanelSizing(gwStorage_1.gwStorage.get(this.westPanelSizeKey));
        this.startPos = null;
    };
    return GwWestPanel;
}(GwDraggableSystem_1.GwDraggableSystem));
exports.GwWestPanel = GwWestPanel;
exports.gwWestPanel = new GwWestPanel();


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwDisplayKey_1 = __webpack_require__(16);
var gwCurrencyHelper_1 = __webpack_require__(227);
var gwInputs_1 = __webpack_require__(5);
var GwCurrencyInfo_1 = __webpack_require__(132);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwCurrency = /** @class */ (function (_super) {
    __extends(GwCurrency, _super);
    function GwCurrency() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwCurrency.prototype.getSystemName = function () {
        return "gwCurrency";
    };
    GwCurrency.prototype.init = function (isFullPageReload) {
        this.setupCurrencyMacroCharacters();
    };
    GwCurrency.prototype.setupCurrencyMacroCharacters = function () {
        var macrosArr = gwUtil_1.gwUtil.getUtilityJson("gw-currencyMacros");
        if (!macrosArr) {
            return;
        }
        var finalObj = {};
        finalObj[macrosArr[0]] = gwCurrencyHelper_1.gwCurrencyHelper.macroZeroMap.thousand;
        finalObj[macrosArr[1]] = gwCurrencyHelper_1.gwCurrencyHelper.macroZeroMap.million;
        finalObj[macrosArr[2]] = gwCurrencyHelper_1.gwCurrencyHelper.macroZeroMap.billion;
        finalObj[macrosArr[3]] = gwCurrencyHelper_1.gwCurrencyHelper.macroZeroMap.trillion;
        Object.freeze(finalObj);
        gwCurrencyHelper_1.gwCurrencyHelper.macros = finalObj;
        gwCurrencyHelper_1.gwCurrencyHelper.macroChars = Object.keys(finalObj);
    };
    GwCurrency.prototype.escapeCurrencySymb = function (cSymb) {
        // $ is the only char we need to escape
        var escapedSymb = cSymb.replace("$", "\\\$");
        if (cSymb.length > 1) {
            escapedSymb = "(" + escapedSymb + ")";
        }
        return escapedSymb;
    };
    GwCurrency.prototype.getCurrencyFormatRegEx = function (currencyInfo) {
        var escapedCurrSymb = this.escapeCurrencySymb(currencyInfo.symb);
        var regStr = "^-?" + escapedCurrSymb + "?(([1-9]\\d{0,2}(" + currencyInfo.grouping + "\\d{3})*)|\\d+)?";
        if (currencyInfo.maxDecimalDigits > 0) {
            regStr += "(\\" + currencyInfo.radix + "\\d{1," + currencyInfo.maxDecimalDigits + "})?"; // Radix followed by up to digits
        }
        regStr += escapedCurrSymb + "?";
        regStr += "$"; // end of string
        return new RegExp(regStr, "igm");
    };
    GwCurrency.prototype.stripFirstAndLastCharsIfParens = function (pastedValue) {
        if (pastedValue && pastedValue[0] === "(" && pastedValue[pastedValue.length - 1] === ")") {
            return pastedValue.substring(1, pastedValue.length - 1);
        }
        return pastedValue;
    };
    /**
     * Method called when paste is triggered on a currency input.
     * 1. Does extra logic to determine whether we need to throw up an alert if the pasted value is formatted correctly.
     * @param el
     * @param args
     * @param e
     */
    GwCurrency.prototype.pasteOnCurrencyInput = function (el, args, e) {
        var clipboardData = e.clipboardData || window.clipboardData;
        var pastedData = clipboardData.getData("Text");
        var cInfo = GwCurrencyInfo_1.GwCurrencyInfo.getCurrencyInfo(el);
        if (!cInfo) {
            return true;
        }
        // Trim leading/trailing white space.  The trimmed pasted data can be surrounded by parentheses to denote a
        // negative number (no need to add a negative sign to the testValue as the testValue is only used for validation)
        var testValue = this.stripFirstAndLastCharsIfParens(pastedData.trim());
        var regEx = this.getCurrencyFormatRegEx(cInfo);
        if (!regEx.test(testValue)) {
            alert(gwDisplayKey_1.gwDisplayKey.get("Web.Client.ConfirmPasteBadCurrency", pastedData));
            e.stopPropagation();
            e.preventDefault();
            return false;
        }
        return true;
    };
    /**
     * Method called when copy or cut is triggered on a currency input.
     * 1. Does extra logic to determine whether it should affix the prefix and suffix to the clipboard value.
     * 2. If the value is determined to be negative, then moves the prefix or suffix currency symbols inside of the
     *    negative symbol. ie: -$500.98 or ($500.98)
     * @param el
     * @param args
     * @param e
     */
    GwCurrency.prototype.copyOnCurrencyInput = function (el, args, e) {
        var val = el.value;
        var selectionStart = el.selectionStart;
        var selectionEnd = el.selectionEnd;
        var name = el.getAttribute("name");
        var prefixEl = document.getElementById(name + "_prefix");
        var suffixEl = document.getElementById(name + "_suffix");
        var prefixVal = prefixEl ? prefixEl.innerHTML : "";
        var suffixVal = suffixEl ? suffixEl.innerHTML : "";
        if (!gwCurrencyHelper_1.gwCurrencyHelper.getConfigValue(gwCurrencyHelper_1.gwCurrencyHelper.COPY_SYMBOL)) {
            prefixVal = "";
            suffixVal = "";
        }
        var finalVal = val;
        var selectAll = selectionEnd === selectionStart;
        // If they have selected a specific selection range, then only give them that
        if (!selectAll) {
            finalVal = val.substring(selectionStart, selectionEnd);
        }
        if (selectAll || selectionStart === 0) {
            var firstChar = finalVal[0];
            if (firstChar === "-" || firstChar === "(") {
                finalVal = firstChar + prefixVal + finalVal.substring(1);
            }
            else {
                finalVal = prefixVal + finalVal;
            }
        }
        if (selectAll || selectionEnd >= val.length) {
            if (finalVal[finalVal.length - 1] === ")") {
                finalVal = finalVal.substring(0, finalVal.length - 2) + suffixVal + ")";
            }
            else {
                finalVal += suffixVal;
            }
        }
        if (e.clipboardData || window.clipboardData) {
            (e.clipboardData || window.clipboardData).setData("text", finalVal);
        }
        else {
            gwUtil_1.gwUtil.devlog("clipboardData object not present on event or window");
        }
        // If this is a cut, then we need to manually delete the selected area since we'll be preventingDefault
        if (e.type === "cut") {
            el.value = val.substring(0, selectionStart) + val.substring(selectionEnd, val.length);
            el.setSelectionRange(selectionStart, selectionStart);
            gwInputs_1.gwInputs.notifySystemsOfInputValueChange(el, "currencyinfo");
        }
    };
    GwCurrency.prototype.valueChangedSoProcessCurrencyInfo = function (el) {
        gwCurrencyHelper_1.gwCurrencyHelper.valueChangedSoProcessCurrencyInfo(el);
    };
    return GwCurrency;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwCurrency = GwCurrency;
exports.gwCurrency = new GwCurrency();


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwPrefPanel_1 = __webpack_require__(28);
var GwCurrencyInfo_1 = __webpack_require__(132);
var gwUtil_1 = __webpack_require__(0);
var GwCurrencyHelper = /** @class */ (function () {
    function GwCurrencyHelper() {
        this.MACRO_CHARS = "enableMacroChars";
        this.COPY_SYMBOL = "copyAndCutGrabSymbol";
        this.maxIllegalCharsBeforePunting = 3;
        this.macros = {};
        this.macroChars = [];
        /**
         * Currency Macros
         * Currently only single chars are supported. Macro characters are NOT case sensitive.
         * Examples:
         * 107b => 107,000,000,000
         * 1.9m => 1,900,000
         * These are not multipliers, so changing the values to anything other than 0s will not have the effect you expect
         * display.properties defines the single keys for each amount, per language
         */
        this.macroZeroMap = {
            thousand: "000",
            million: "000000",
            billion: "000000000",
            trillion: "000000000000"
        };
        /**
         * Closure Variables
         */
        this.nonDigitChars = new RegExp("[^0-9]", "g");
        this.cursorIndex = -1;
        this.cursorOffset = -1;
        this.i = -1;
    }
    GwCurrencyHelper.prototype.getConfigValue = function (constKey) {
        return gwPrefPanel_1.gwPrefPanel.getPrefValueById(constKey);
    };
    /**
     * @private
     * helper method for valueChangedSoProcessCurrencyInfo
     */
    GwCurrencyHelper.prototype.decrementOffsetIfIndexGreaterThanOrEqualTo = function (valOrDefaultI) {
        if (valOrDefaultI === undefined) {
            valOrDefaultI = this.i;
        }
        if (valOrDefaultI <= this.cursorIndex) {
            this.cursorOffset--;
        }
    };
    /**
     * @private
     * helper method for valueChangedSoProcessCurrencyInfo
     */
    GwCurrencyHelper.prototype.addCursorOffsetToCursorIndex = function () {
        this.cursorIndex += this.cursorOffset;
        this.cursorOffset = 0;
    };
    GwCurrencyHelper.prototype.finalizeElValue = function (el, val, optCursorPos) {
        var prev = el.hasAttribute("data-gw-prev") ? el.getAttribute("data-gw-prev") : "";
        if (prev !== null) {
            el.setAttribute("data-gw-undo", prev);
        }
        el.setAttribute("data-gw-prev", val);
        el.value = val;
        if (optCursorPos && document.activeElement === el) {
            el.setSelectionRange(optCursorPos, optCursorPos);
        }
    };
    /**
     * Runs on data-gw-currency-info elements to do inline automatic locale specific currency formatting.
     * requires: 'data-gw-currency-info="USD;$;,;.;2" where the semi-colon separated values are:
     * 1. International Currency Code: ex USD
     * 2. Currency Symbol: ex $
     * 3. Thousands Grouping Separator: ex ,
     * 4. Radix Separator: ex .
     * 5. Maximum Allowed Decimal Places: ex 2
     *
     * Features:
     * a. automatically adds grouping separators on the fly
     * b. restricts any invalid input
     * c. typing a matching radix or grouping symbol will move the cursor past the existing one
     * d. caps major digits to maxCurrencyDigits
     * e. Parses the macros in gw.currency.macros to convert things like 1.5m into 1,500,000 if enableMacroChars == true
     * f. adds and removes leading 0s when needed
     * g. delete key when to the right of a grouping symbol will move the cursor to the left of the symbol
     * h. typing or pasting a value with () for negative will convert them to a leading -
     * @param el
     * @param args
     * @param e
     */
    GwCurrencyHelper.prototype.valueChangedSoProcessCurrencyInfo = function (el) {
        // ###################################################
        // ### 1. Bail out if conditions aren't met        ###
        // ###################################################
        if (!el) {
            return;
        }
        var cInfo = GwCurrencyInfo_1.GwCurrencyInfo.getCurrencyInfo(el);
        if (!cInfo) {
            return;
        }
        var val = el.value;
        if (!gwUtil_1.gwUtil.hasValue(val) || val.length === 0) {
            this.finalizeElValue(el, "");
            return;
        }
        // ###################################################
        // ### 2. Setup All the Variables                  ###
        // ###################################################
        var originalVal = val.slice(0);
        var lastVal = el.getAttribute("data-gw-prev") || "";
        var diffLengthFromLast = val.length - lastVal.length;
        var addedChar = diffLengthFromLast === 1;
        var deletedChar = diffLengthFromLast === -1;
        //get the cursor position, convert it to a 0 index to play nice with string indexes, we'll undo it at the end
        this.cursorIndex = (el.selectionEnd || el.selectionStart) - 1;
        this.cursorOffset = 0;
        var charAtCursor = val[this.cursorIndex] || "";
        var lastValCharAtCursor = lastVal[this.cursorIndex + 1] || "";
        var userTypedRadix = addedChar && charAtCursor === cInfo.radix;
        var userTypedGrouping = addedChar && charAtCursor === cInfo.grouping;
        var userDeletedRadix = deletedChar && lastValCharAtCursor === cInfo.radix;
        var userDeletedGrouping = deletedChar && lastValCharAtCursor === cInfo.grouping;
        // ###################################################
        // ### 2a. Process Pasted Curr and Symbol          ###
        // ###################################################
        // TODO: Multi Currency: here, we'd have a list of currencies supported in this input
        var cCodeStrExtractedFromVal = null;
        var cSymbStrExtractedFromVal = null;
        // Walk that list, see if the value is present, then change the currency of this field's selector to it
        // For now, we'll just pull the single currency code and symbol
        var cCodeIndex = val.indexOf(cInfo.code);
        if (cCodeIndex > -1) {
            cCodeStrExtractedFromVal = cInfo.code;
            val = val.replace(cInfo.code, "");
            // Any amount of the currency code located before the cursorIndex needs to decrement the cursorIndex
            this.cursorIndex -= Math.min(cInfo.code.length, (this.cursorIndex - cCodeIndex));
        }
        var cSymbIndex = val.indexOf(cInfo.symb);
        if (cSymbIndex > -1) {
            cSymbStrExtractedFromVal = cInfo.symb;
            val = val.replace(cInfo.symb, "");
            // Any amount of the currency sy located before the cursorIndex needs to decrement the cursorIndex
            this.cursorIndex -= Math.min(cInfo.symb.length, (this.cursorIndex - cSymbIndex));
        }
        // TODO: Multi Currency: then take the cCodeExtracted or cSymbExtracted and set the drop down selector to it if supported
        var supportedCurrencies = {}; // Get this list globally or from the element's dropdown
        if (supportedCurrencies[cCodeStrExtractedFromVal] || supportedCurrencies[cSymbStrExtractedFromVal]) {
            // TODO: Then set the select dropdown to be supportedCurrencies[cCodeStrExtractedFromVal] || supportedCurrencies[cSymbStrExtractedFromVal]
        }
        // ###################################################
        // ### 2b. Clean Invalid, exit if nothing remains  ###
        // ###################################################
        var isNegative = false;
        if (val[0] === "-" || val[0] === "(") {
            isNegative = true;
            // The - or ( symbol will be peeled off by the next legal characters regex
            this.decrementOffsetIfIndexGreaterThanOrEqualTo(1);
            var closingBracketPos = val.indexOf(")");
            // If we found a closing bracket, and it was before the cursor position, then decrement cursorIndex
            // The character itself will be peeled off by the legal char regex
            if (closingBracketPos > -1) {
                this.decrementOffsetIfIndexGreaterThanOrEqualTo(closingBracketPos);
            }
        }
        // Legal characters are 0-9, the grouping separator, and the radix (but only if allowed digits is greater than 0
        var regStr = "[0-9\\" + cInfo.grouping + (cInfo.maxDecimalDigits > 0 ? "\\" + cInfo.radix : "");
        // Plus any defined macro characters
        if (this.getConfigValue(this.MACRO_CHARS)) {
            regStr += this.macroChars.join("");
        }
        regStr += "]";
        var legalChars = new RegExp(regStr, "g");
        var preCleanValueLength = val.length;
        var arrOfChars = val.match(legalChars) || [];
        var postCleanValueLength = val.length;
        // Now, if there was a large number of illegal characters trimmed, we will decide not to format this value
        // And instead just print the original value to show the user they've probably made a mistake.
        if (preCleanValueLength - postCleanValueLength > this.maxIllegalCharsBeforePunting) {
            this.finalizeElValue(el, originalVal);
            return;
        }
        // No valid characters were matched, so just set the vals and bail
        if (arrOfChars === null || arrOfChars.length === 0) {
            val = isNegative ? "-" : "";
            this.finalizeElValue(el, val, 1);
            return;
        }
        val = arrOfChars.join("");
        // ###################################################
        // ### 3. Check for and Do Macros                  ###
        // ###################################################
        // We only process the first macro found here, leaving any trailing ones in string for the user to see as an error state
        var ch;
        var finalVal = "";
        var macroFired = false;
        var left;
        var right;
        if (this.getConfigValue(this.MACRO_CHARS)) {
            var macro = void 0;
            var lead = void 0;
            var split = void 0;
            for (this.i = 0; this.i < val.length; this.i++) {
                ch = val[this.i];
                macro = (this.macros[ch.toLowerCase()] || this.macros[ch.toUpperCase()]);
                if (!macroFired && macro) {
                    macroFired = true;
                    lead = val.substring(0, this.i);
                    // ie: 1.7b
                    if (lead.indexOf(cInfo.radix) > -1) {
                        split = lead.split(cInfo.radix);
                        left = split[0];
                        right = split[1];
                        // ie: 1 + 7 + (number of zeroes in macro - the length of right)
                        finalVal = left + right + (macro.substring(right.length, macro.length));
                    }
                    else {
                        finalVal = lead + macro;
                    }
                    this.cursorIndex = finalVal.length; //Maybe - 1 here
                }
                else {
                    finalVal += ch;
                }
            }
        }
        else {
            finalVal = val;
        }
        // We will throw out much of the logic we use after user input, since the macro changes that logic
        if (macroFired) {
            charAtCursor = "";
            lastValCharAtCursor = "";
            userTypedRadix = false;
            userTypedGrouping = false;
            userDeletedRadix = false;
            userDeletedGrouping = false;
            this.cursorOffset = 0;
        }
        // ###################################################
        // ### 4. Adjust Cursor based on user action       ###
        // ###################################################
        if (addedChar) {
            //user typed an illegal character, so we will offset the cursor back
            if (!charAtCursor.match(legalChars)) {
                this.cursorOffset--;
            }
            else if (userTypedGrouping) {
                this.cursorOffset++;
                if (val[this.cursorIndex + 1] === cInfo.grouping) {
                    this.cursorOffset++;
                }
            }
            else if (userTypedRadix) {
                this.cursorOffset++;
                if (val[this.cursorIndex + 1] === cInfo.radix) {
                    this.cursorOffset++;
                }
            }
        }
        else if (deletedChar) {
            if (userDeletedGrouping) {
                // Not needed in current implementation
            }
            else if (userDeletedRadix) {
                // Not needed in current implementation
            }
        }
        this.addCursorOffsetToCursorIndex();
        // ###################################################
        // ### 5. Split on Radix into Left and Right       ###
        // ###################################################
        left = "";
        right = "";
        var foundRadix = true;
        if (userTypedRadix) {
            //split left and right on cursorIndex
            right = finalVal.substring(this.cursorIndex);
            left = finalVal.substring(0, this.cursorIndex);
        }
        else {
            //split on the right most radix to preserve the most digits in case there are multiple radix
            var finalValSplit = finalVal.split(cInfo.radix);
            if (finalValSplit.length === 1) {
                // There was no radix, so it all goes into the left
                left = finalValSplit[0];
                foundRadix = false;
            }
            else {
                right = finalValSplit.pop();
                left = finalValSplit.join("");
            }
        }
        // We don't do much special voodoo on the right hand side, just clean invalid
        right = right.replace(this.nonDigitChars, "").substring(0, cInfo.maxDecimalDigits);
        // ###################################################
        // ### 6. Process Left String                      ###
        // ###################################################
        var tempLeft = "";
        var inLeadZeroChain = true;
        var foundLeadZero = false;
        // Remove all grouping and radix from left string, tallying the ones left of the cursorIndex
        // And remove all leading zeroes
        for (this.i = 0; this.i < left.length; this.i++) {
            ch = left[this.i];
            if (ch === "0" && inLeadZeroChain) {
                // If we've already found a leading zero, then start decrementing indexes
                if (foundLeadZero) {
                    this.decrementOffsetIfIndexGreaterThanOrEqualTo();
                }
                foundLeadZero = true;
                continue;
            }
            // Found a non zero digit, so break the chain
            inLeadZeroChain = false;
            if (ch === cInfo.radix || ch === cInfo.grouping) {
                this.decrementOffsetIfIndexGreaterThanOrEqualTo();
                continue;
            }
            // Was not a leading zero, nor a radix or a grouping, so add it
            tempLeft = tempLeft + ch;
        }
        this.addCursorOffsetToCursorIndex();
        if (foundLeadZero && tempLeft.length === 0) {
            tempLeft = "0";
        }
        left = tempLeft;
        // ###################################################
        // ### 7. Add group separators back to left string ###
        // ###################################################
        var tempLeftArr = [];
        // Now walk from right to left in left hand string, and add any needed grouping chars
        var groupingCounter = 0;
        var leftLength = left.length;
        for (this.i = leftLength - 1; this.i >= 0; this.i--) {
            ch = left[this.i];
            tempLeftArr.push(ch);
            groupingCounter++;
            // Every 3 digits add a grouping char
            if (groupingCounter === 3 && this.i !== 0) {
                groupingCounter = 0;
                tempLeftArr.push(cInfo.grouping);
                if (this.i < this.cursorIndex) {
                    this.cursorOffset++;
                }
            }
        }
        left = tempLeftArr.reverse().join("");
        this.addCursorOffsetToCursorIndex();
        // ###################################################
        // ### 8. Done - Set Values, negative, cursorIndex   ###
        // ###################################################
        finalVal = left;
        if (foundRadix) {
            finalVal = finalVal + cInfo.radix + right;
        }
        // If the final value is empty, meaning we trimmed all the 0s, then add one back, or
        // If the final value starts with a radix, then we add a zero, unless the user deleted the zero previously
        if (finalVal.length === 0 || (finalVal[0] === cInfo.radix && lastValCharAtCursor !== "0")) {
            this.cursorIndex++;
            finalVal = "0" + finalVal;
        }
        if (isNegative) {
            this.cursorIndex++;
            finalVal = "-" + finalVal;
        }
        //At the start we subtracted 1 from the cursor position to convert it to a 0 index, now we add that 1 back
        this.finalizeElValue(el, finalVal, this.cursorIndex + 1);
    };
    return GwCurrencyHelper;
}());
exports.GwCurrencyHelper = GwCurrencyHelper;
exports.gwCurrencyHelper = new GwCurrencyHelper();


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwInitializableSystem_1 = __webpack_require__(4);
var gwNavigation_1 = __webpack_require__(86);
var gwUtil_1 = __webpack_require__(0);
var gwInputs_1 = __webpack_require__(5);
var GwAutoCompleteRequest_1 = __webpack_require__(229);
var gwFocus_1 = __webpack_require__(8);
var gwEvents_1 = __webpack_require__(3);
var gwAjax_1 = __webpack_require__(15);
var GwTextValue = /** @class */ (function (_super) {
    __extends(GwTextValue, _super);
    function GwTextValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeoutKey = -1;
        /**
         * The delay after the last keypress before the autocomplete will be refreshed and rendered
         * @type {number}
         */
        _this.autocompleteDelay = 300;
        /**
         * Keeps track of whether there is currently an autocomplete visible to
         * keep every click from searching for a visible autocomplete div
         * @type {boolean}
         */
        _this.autocompleteVisible = false;
        /**
         * Caches the last value we sent a request to the server for, preventing a new
         * autocomplete request on focus if the value hasn't changed and the autocomplete
         * is still visible.
         * @type {string}
         */
        _this.autocompletedValueCache = null;
        /**
         * The current entry in the autocomplete dropdown when using arrow keys to navigate up and down
         * @type {object}
         */
        _this.currentAutocompleteEntry = null;
        return _this;
    }
    GwTextValue.prototype.getSystemName = function () {
        return "gwTextValue";
    };
    GwTextValue.prototype.init = function () {
        gwNavigation_1.gwNavigation.registerNavFunction(function (node) {
            return node.hasAttribute("data-gw-autocomplete");
        }, exports.gwTextValue);
    };
    GwTextValue.prototype.cancelAnyPendingAutocomplete = function () {
        if (this.timeoutKey >= 0) {
            clearTimeout(this.timeoutKey);
            this.timeoutKey = -1;
        }
    };
    /**
     * @public
     * Fetches and Renders autocomplete information for the given node
     * @param node the Input node that needs the autocomplete
     */
    GwTextValue.prototype.autocomplete = function (node) {
        this.cancelAnyPendingAutocomplete();
        this.timeoutKey = setTimeout(this.fetchAutocompleteData.bind(this, node.name), this.autocompleteDelay);
    };
    /**
     * @private
     * Builds the request object to send a request for autocomplete results
     * @param widgetId the renderId of the widget being autocompleted
     */
    GwTextValue.prototype.fetchAutocompleteData = function (widgetId) {
        this.timeoutKey = -1;
        var node = gwUtil_1.gwUtil.getDomNodeByName(widgetId);
        if (!node) {
            return;
        }
        var nodeValue = gwInputs_1.gwInputs.getValueWithMaskTrimmed(node);
        var minChars = +gwUtil_1.gwUtil.getDatasetPropOrDefault(node, "gwCharThreshold", "1");
        if (nodeValue.length < minChars) {
            this.closeAutocomplete();
            return;
        }
        if (this.autocompletedValueCache !== nodeValue) {
            this.autocompletedValueCache = nodeValue;
            var requestObject = new GwAutoCompleteRequest_1.GwAutoCompleteRequest(nodeValue, node.selectionStart, widgetId);
            var dependentFieldNames = gwUtil_1.gwUtil.getDatasetPropOrDefault(node, "gwDependantFields").split(",");
            if (dependentFieldNames[0]) {
                for (var i = 0; i < dependentFieldNames.length; i++) {
                    var fieldName = dependentFieldNames[i];
                    var fieldInput = gwUtil_1.gwUtil.getDomNodeByName(fieldName);
                    if (fieldInput) {
                        requestObject.additionalArgs[fieldName] = fieldInput.value;
                    }
                }
            }
            var requestParams = {};
            requestParams["__autocomplete"] = JSON.stringify(requestObject);
            gwAjax_1.gwAjax.ajaxRequest(requestParams, this.renderAutocompleteData.bind(this, widgetId), this.handleAutocompleteError.bind(this, widgetId));
        }
    };
    /**
     * @private
     * Handles a server response for autocomplete, creates the autocomplete elements under the input, or
     * destroys them if they are visible but there's nothing to show
     * @param widgetName the id of the autocomplete widget
     * @param data the data from the server
     */
    GwTextValue.prototype.renderAutocompleteData = function (widgetName, data) {
        if (data.results.length > 0) {
            this.createAutocompleteEntries(widgetName, data.results);
        }
        else {
            this.destroyAutocompleteEntriesIfVisible(widgetName);
        }
    };
    /**
     * @private
     * Create autocomplete entries matching the given result list under the input widget with the given name.
     * @param widgetName name of the autocomplete widget
     * @param results a non empty list of autocomplete results
     */
    GwTextValue.prototype.createAutocompleteEntries = function (widgetName, results) {
        var node = gwUtil_1.gwUtil.getDomNodeByAttr("name", widgetName);
        if (node) {
            // Remove the focus tag, then put it back when the element is blurred. This allows us to click to select without popping the panel back up.
            // Also watch for the return key, which can be used to select the current autocomplete entry
            node.removeAttribute("data-gw-focus");
            var $parent = $(node).parent();
            $parent.addClass("gw-autocomplete--container");
            // Add a blur tag to the parent, which will be removed when the panel is closed.
            $parent.attr("data-gw-blur", "gwTextValue.blurOnContainer");
            var $div = $(".gw-autocomplete", $parent);
            if ($div.length === 0) {
                $div = $("<div class='gw-autocomplete'></div>");
                $parent.append($div);
            }
            $div.empty();
            for (var i = 0; i < results.length; i++) {
                var entryDiv = $("<div class='gw-autocomplete--entry'></div>");
                var displayHtml = this.replaceStyles(results[i].displayText);
                entryDiv.append(displayHtml);
                entryDiv[0].dataset.gwEntryValue = results[i].text;
                entryDiv[0].dataset.gwClick = "gwTextValue.clickAutocompleteEntry name:" + node.name;
                entryDiv[0].dataset.gwMouseenter = "gwTextValue.enterAutocompleteEntry";
                entryDiv[0].dataset.gwMouseout = "gwTextValue.exitAutocompleteEntry";
                entryDiv[0].tabIndex = -1;
                $div.append(entryDiv);
            }
            this.renderAutocomplete(node, $div[0]);
            this.autocompleteVisible = true;
            this.currentAutocompleteEntry = null;
            this.setCurrentAutocompleteEntry($div[0].firstChild);
            this.setTextFromMatchingItem(node, results[0].text);
        }
    };
    GwTextValue.prototype.setInputValue = function (input, newValue) {
        var fullNewValue = newValue;
        var mask = input.getAttribute("data-gw-input-mask");
        if (mask && mask.length > newValue.length) {
            fullNewValue = newValue + mask.substring(newValue.length);
        }
        if (input.value !== fullNewValue) {
            input.value = fullNewValue;
            return true;
        }
        return false;
    };
    GwTextValue.prototype.setTextFromMatchingItem = function (input, text) {
        var currentValue = gwInputs_1.gwInputs.getValueWithMaskTrimmed(input);
        if (input.selectionStart && input.selectionEnd
            && input.selectionStart < input.selectionEnd && input.selectionEnd >= currentValue.length) {
            currentValue = currentValue.substring(0, input.selectionStart);
        }
        if (currentValue && text.toLowerCase().indexOf(currentValue.toLowerCase()) === 0) {
            this.setInputValue(input, text);
            input.setSelectionRange(currentValue.length, text.length, "backward");
        }
    };
    /**
     * Renders autocomplete using the input as a reference to position
     * Attempts to align it to the left edge of the input it's displayed for.
     * - If it's offscreen right, then aligns itself to the right of the input
     * @param input - text input
     * @param autocomplete - the dom element for the dropdown to be aligned
     *
     * @link - gw.resizer.windowHeight, gw.resizer.windowWidth
     * @private
     */
    GwTextValue.prototype.renderAutocomplete = function (input, autocomplete) {
        autocomplete.style.display = "block";
        var inputRect = input.getBoundingClientRect();
        var inputWidth = inputRect.right - inputRect.left;
        // The autocomplete widget is initialized as display:none to remain hidden.  Querying the bounds in the current
        // frame returns null results so we push the query into the next animation frame, which will have the correct values
        // and also serves to batch some of the multiple calls.
        window.requestAnimationFrame(function () {
            var targetWidth = autocomplete.offsetWidth > inputWidth ? autocomplete.offsetWidth : inputWidth;
            autocomplete.style.width = targetWidth + "px";
            var noRoomWhenStartingLeft = inputRect.left + targetWidth > window.innerWidth;
            var canFitInsideWindow = window.innerWidth - targetWidth > 0;
            if (noRoomWhenStartingLeft && canFitInsideWindow) {
                // If there's not enough to render starting on the left edge of the input but enough room to render
                // from the right edge of the screen to the left
                autocomplete.style.left = (window.innerWidth - targetWidth) + "px";
            }
            else {
                // Start rendering on the left
                autocomplete.style.left = inputRect.left + "px";
                if (noRoomWhenStartingLeft) {
                    // Set up horizontal scrolling
                    autocomplete.style.width = (window.innerWidth - inputRect.left) + "px";
                    autocomplete.style.overflowY = "auto";
                }
            }
            var noRoomWhenStartingBottom = inputRect.bottom + autocomplete.scrollHeight > window.innerHeight;
            var canFitAboveInput = inputRect.top - autocomplete.scrollHeight > 0;
            if (noRoomWhenStartingBottom && canFitAboveInput) {
                // If there's not enough room to render below, but enough room to render above
                autocomplete.style.top = (inputRect.top - autocomplete.offsetHeight) + "px";
            }
            else {
                if (noRoomWhenStartingBottom) {
                    // Set up vertical scrolling
                    autocomplete.style.overflowY = "auto";
                    // Render wherever there's more room
                    if (inputRect.top > (window.innerHeight - inputRect.bottom)) {
                        // Render above
                        // if the top has enough space for the autocomplete div
                        if (inputRect.top > autocomplete.offsetHeight) {
                            autocomplete.style.top = inputRect.top - autocomplete.offsetHeight + "px";
                            autocomplete.style.height = autocomplete.offsetHeight + "px";
                        }
                        else {
                            // otherwise we take the whole space we allow to on the top
                            autocomplete.style.top = 0 + "px";
                            autocomplete.style.height = inputRect.top + "px";
                        }
                    }
                    else {
                        // Render below
                        // if bottom space is enough the autocomplete div height
                        if ((window.innerHeight - inputRect.bottom) > autocomplete.offsetHeight) {
                            autocomplete.style.top = inputRect.bottom + "px";
                            autocomplete.style.height = autocomplete.offsetHeight + "px";
                        }
                        else {
                            // if not enough space then we will just take as much as possible
                            autocomplete.style.top = inputRect.bottom + "px";
                            autocomplete.style.height = (window.innerHeight - inputRect.bottom) + "px";
                        }
                    }
                }
                else {
                    // Render below
                    autocomplete.style.top = inputRect.bottom + "px";
                }
            }
        });
    };
    /**
     * @private
     * Called if there is an error while calling the server to fetch autocomplete entries
     * @param widgetName name of the autocomplete widget
     */
    GwTextValue.prototype.handleAutocompleteError = function (widgetName) {
        this.destroyAutocompleteEntriesIfVisible(widgetName);
        gwFocus_1.gwFocus.clearFocus();
    };
    /**
     * @private
     * Destroy any visible autocomplete entries under the widget with the given name.
     * @param widgetName name of the autocomplete widget
     */
    GwTextValue.prototype.destroyAutocompleteEntriesIfVisible = function (widgetName) {
        this.closeAutocomplete();
    };
    /**
     * Replaces "markers" with a div containing a markup class plus the tag for styling
     * @param displayText the display text to replace
     * @returns the displayText with divs inserted
     */
    GwTextValue.prototype.replaceStyles = function (displayText) {
        displayText = displayText.replace(/\[(\w+)\]/g, "<div class=\"gw-autocomplete--markup gw-$1\">");
        return displayText.replace(/\[\/\w+]/g, "</div>");
    };
    GwTextValue.prototype.setCurrentAutocompleteEntry = function (newEntry) {
        if (this.currentAutocompleteEntry !== null) {
            gwUtil_1.gwUtil.removeClass(this.currentAutocompleteEntry, "gw-autocomplete--current-entry");
        }
        if (newEntry) {
            gwUtil_1.gwUtil.addClass(newEntry, "gw-autocomplete--current-entry");
        }
        this.currentAutocompleteEntry = newEntry;
    };
    /**
     * Called when we want to set the value of the input to the value of the currently selected entry in
     * the autocomplete dropdown. Normally we also try to set the cursor appropriately but we have to be
     * very careful, setting the cursor causes IE to focus on the field. So we don't do it if we're trying
     * to leave the field (or we'll be bounced right back in again). This is also why we deal with the mask
     * manually instead of calling valueChangedSoProcessInputMask; that function also sets the cursor.
     * @param input autocomplete input
     * @param onBlur are we leaving the autocomplete input?
     */
    GwTextValue.prototype.confirmCurrentAutocompleteEntry = function (input, onBlur) {
        if (onBlur === void 0) { onBlur = false; }
        var changed = false;
        if (this.currentAutocompleteEntry !== null) {
            var newValue = this.currentAutocompleteEntry.dataset.gwEntryValue || "";
            changed = this.setInputValue(input, newValue);
            if (!onBlur) {
                input.selectionStart = input.selectionEnd = newValue.length;
            }
        }
        this.closeAutocomplete();
        return changed;
    };
    GwTextValue.prototype.pickerClear = function (el, args) {
        gwInputs_1.gwInputs.setValueById(args.targetName, "");
    };
    /**
     * @public
     * Called when the user clicks on an entry in the autocomplete dropdown
     * @param node the clicked autocomplete node
     * @param info the event info
     */
    GwTextValue.prototype.clickAutocompleteEntry = function (entry, info) {
        var input = gwUtil_1.gwUtil.getDomNodeByName(info.name);
        if (!input) {
            throw new Error("unable to find corresponding input for autocomplete");
        }
        // The click will have taken focus away from the input so we have to manually force it back
        input.focus();
        this.currentAutocompleteEntry = entry;
        // If we actually change the value of the input, then mark the value widget as having a pending change
        // so a subsequent blur will fire a change event
        if (this.confirmCurrentAutocompleteEntry(input)) {
            var valueWidget = gwEvents_1.gwEvents.findEnclosingValueWidget(input);
            if (valueWidget !== null) {
                gwEvents_1.gwEvents.setPendingChangesOnElement(valueWidget);
            }
        }
    };
    /**
     * @public
     * Called when the user hits enter while an autocomplete input has focus
     * @param node the clicked autocomplete node
     * @param info the event info
     */
    GwTextValue.prototype.chooseCurrentAutocompleteEntry = function (input) {
        this.confirmCurrentAutocompleteEntry(input);
        if (input.hasAttribute("data-gw-post-on-enter-key")) {
            this.cancelAnyPendingAutocomplete();
            gwUtil_1.gwUtil.fireEvent(input.name + "_act");
        }
    };
    /**
     * @public
     * Called when the user mouses over an entry in the autocomplete dropdown
     * @param entry the dropdown entry
     */
    GwTextValue.prototype.enterAutocompleteEntry = function (entry) {
        this.setCurrentAutocompleteEntry(entry);
    };
    /**
     * @public
     * Called when the user's mouse exits an entry in the autocomplete dropdown
     * @param entry the dropdown entry
     */
    GwTextValue.prototype.exitAutocompleteEntry = function () {
        this.setCurrentAutocompleteEntry(null);
    };
    /**
     * @public
     * Called when the autocomplete input loses focus. If the user clicks on something then the
     * current autocomplete entry will be null, but if they hit tab it may contain a valid entry
     * and, if so, it should become the new value of the input.
     * @param entry the dropdown entry
     */
    GwTextValue.prototype.blurOnContainer = function (node) {
        var input = node.querySelector("[data-gw-autocomplete]");
        // Confirm the currently chosen entry unless the field is completely empty
        if (input && gwInputs_1.gwInputs.getValueWithMaskTrimmed(input)) {
            this.confirmCurrentAutocompleteEntry(input, true);
        }
        else {
            this.closeAutocomplete();
        }
    };
    /**
     * Closes all autocomplete windows.
     * removes the blur attribute from the container.
     * restores the focus attribute to the child.
     */
    GwTextValue.prototype.closeAutocomplete = function (event) {
        var autocompletes = gwUtil_1.gwUtil.getDomNodes(".gw-autocomplete");
        if (autocompletes) {
            if (event && event.target) {
                for (var i = 0; i < autocompletes.length; i++) {
                    if (autocompletes[i] === event.target) {
                        // If an event is passed in, if the event's target matches an autocomplete element,
                        // do not close autocmpletes; this is used to prevent closing autocomplete on scroll
                        // when the scrolling occurs on the autocomplete element
                        return;
                    }
                }
            }
        }
        this.autocompleteVisible = false;
        this.autocompletedValueCache = null;
        this.currentAutocompleteEntry = null;
        gwUtil_1.gwUtil.forEach(autocompletes, function (autocomplete) {
            var container = autocomplete.parentNode;
            var childInput = container.querySelector("[data-gw-autocomplete]");
            gwUtil_1.gwUtil.removeClass(container, "gw-autocomplete--container");
            container.removeAttribute("data-gw-blur");
            if (childInput) {
                childInput.setAttribute("data-gw-focus", "gwTextValue.autocomplete");
            }
            //IE doesn't support remove();
            container.removeChild(autocomplete);
        });
    };
    /**
     * @private
     * Should only be called by the navigation system, handles an "up" keystroke
     * when in an autocomplete input
     * @param target the dom node where "up" was pressed
     * @param cssClass the cssClass that matched the dom node
     * @param info the event method info
     * @param event the key event
     */
    GwTextValue.prototype.up = function (target, info, event) {
        if (!this.autocompleteVisible) {
            return;
        }
        if (!this.currentAutocompleteEntry) {
            this.setCurrentAutocompleteEntry(gwUtil_1.gwUtil.getDomNodeOrThrow(".gw-autocomplete").lastChild);
        }
        else if (this.currentAutocompleteEntry.previousSibling) {
            this.setCurrentAutocompleteEntry(this.currentAutocompleteEntry.previousSibling);
        }
        //Block the default, which either moves the cursor or scrolls the page
        event.preventDefault();
    };
    /**
     * @private
     * Should only be called by the navigation system, handles an "down" keystroke
     * when in an autocomplete input
     * @param target the dom node where "down" was pressed
     * @param info the method info
     * @param event the event
     */
    GwTextValue.prototype.down = function (target, info, event) {
        if (!this.autocompleteVisible) {
            return;
        }
        if (!this.currentAutocompleteEntry) {
            this.setCurrentAutocompleteEntry(gwUtil_1.gwUtil.getDomNodeOrThrow(".gw-autocomplete").firstChild);
        }
        else if (this.currentAutocompleteEntry.nextSibling) {
            this.setCurrentAutocompleteEntry(this.currentAutocompleteEntry.nextSibling);
        }
        event.preventDefault();
    };
    GwTextValue.prototype.left = function (node, info, event) {
        // NoOp
    };
    GwTextValue.prototype.right = function (node, info, event) {
        // NoOp
    };
    return GwTextValue;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwTextValue = GwTextValue;
exports.gwTextValue = new GwTextValue();


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwAutoCompleteRequest = /** @class */ (function () {
    function GwAutoCompleteRequest(textSoFar, caretPos, widgetId) {
        this.textSoFar = textSoFar;
        this.caretPos = caretPos;
        this.widgetId = widgetId;
        this.additionalArgs = {};
    }
    return GwAutoCompleteRequest;
}());
exports.GwAutoCompleteRequest = GwAutoCompleteRequest;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwForcedEvent = /** @class */ (function () {
    function GwForcedEvent(target, type, relatedTarget, currentTarget) {
        this.bubbles = false;
        this.isForcedEvent = true;
        this.cancelable = false;
        this.defaultPrevented = true;
        this.isTrusted = true;
        this.returnValue = 0;
        this.srcElement = null;
        this.timeStamp = -1;
        this.scoped = false;
        this.initEvent = null;
        this.cancelBubble = false;
        this.eventPhase = -1;
        this.AT_TARGET = -1;
        this.BUBBLING_PHASE = -1;
        this.CAPTURING_PHASE = -1;
        this.target = target;
        this.type = type;
        this.relatedTarget = relatedTarget || target;
        this.currentTarget = currentTarget || target;
    }
    GwForcedEvent.isGwForcedEvent = function (obj) {
        return obj.isForcedEvent !== undefined;
    };
    GwForcedEvent.prototype.stopPropagation = function () {
        // NOOP;
    };
    GwForcedEvent.prototype.preventDefault = function () {
        // NOOP;
    };
    GwForcedEvent.prototype.stopImmediatePropagation = function () {
        // NOOP;
    };
    GwForcedEvent.prototype.deepPath = function () {
        return [];
    };
    return GwForcedEvent;
}());
exports.GwForcedEvent = GwForcedEvent;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GwEraDetail = /** @class */ (function () {
    function GwEraDetail(era) {
        this.name = era.name;
        this.order = +era.order;
        this.delta = era.startYear - 1;
        this.start = new Date(era.startYear, era.startMonth, era.startDay);
        this.startYear = era.startYear;
        this.startMonth = era.startMonth;
        this.startDay = era.startDay;
        this.total = era.max;
    }
    return GwEraDetail;
}());
exports.GwEraDetail = GwEraDetail;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwListViewHelper_1 = __webpack_require__(233);
var gwEvents_1 = __webpack_require__(3);
var gwScroll_1 = __webpack_require__(27);
var gwPreferences_1 = __webpack_require__(62);
var gwFocus_1 = __webpack_require__(8);
var gwUtil_1 = __webpack_require__(0);
var GwDraggableSystem_1 = __webpack_require__(83);
var GwListView = /** @class */ (function (_super) {
    __extends(GwListView, _super);
    function GwListView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.PREFERENCE_TYPE = "LISTVIEW";
        _this.COLUMN_PREFERENCES = "COLUMN_PREFERENCES";
        _this.FIRST_HEADER_CELL_CLASS = "gw-first-cell";
        _this.LAST_HEADER_CELL_CLASS = "gw-last-cell";
        return _this;
    }
    GwListView.prototype.getSystemName = function () {
        return "gwListView";
    };
    GwListView.prototype.init = function (isFullPageReload) {
        this.applyPreferences();
        gwListViewHelper_1.gwListViewHelper.buildColumnsMenusForAllLVs(); //TODO: @Optimize: This is a lot of heavy lifting to run on every partial load
    };
    /**
     * Handles any commands an LV header cell might fire. Grouping, sorting, etc.
     * @param headerNode
     * @param args
     * @param event
     */
    GwListView.prototype.headerAction = function (headerNode, args, event) {
        var headerInput = $("#gw-util--headers");
        headerInput.attr("name", args.id);
        headerInput.val(args.act);
        gwEvents_1.gwEvents.methods.fireEvent(headerNode, args, event, function () {
            headerInput.attr("name", "gw-util--headers");
            headerInput.val("");
        });
    };
    /**
     * @public
     * Filters the ListView using the given "opKey", which corresponds to specific Header's
     * filter values
     * @param filterNode
     * @param args
     */
    GwListView.prototype.filter = function (filterNode, args) {
        var outer = filterNode.parentElement;
        if (!outer) {
            return;
        }
        var filterEl = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(filterNode, "gw-HeaderCellFilterValueWidget");
        if (!filterEl) {
            return;
        }
        var valueNode = gwUtil_1.gwUtil.getDomNode(".gw-opKey--input", filterEl);
        if (outer.dataset && gwUtil_1.gwUtil.hasValue(outer.dataset.gwSelected)) {
            valueNode.value = "";
        }
        else {
            valueNode.value = args.opKey;
        }
        gwUtil_1.gwUtil.fireEvent(args.id);
    };
    /**
     * A helper method for triggering the paging event
     */
    GwListView.prototype.page = function (pageNode, pageArgs) {
        var paging = $("#gw-paging");
        paging.attr("name", pageArgs.renderId);
        // This is a little hacky, but allows using an input widget to set the page value
        if (pageArgs.page === "value") {
            paging.val(pageNode.value);
        }
        else {
            paging.val(pageArgs.page);
        }
        // Scroll the screen to the top and the left if we are paging the listview
        gwScroll_1.gwScroll.setScreenScrollTo0(pageNode);
        gwUtil_1.gwUtil.fireEvent(pageArgs.renderId);
        paging.attr("name", "");
    };
    GwListView.prototype.hideColumn = function (headerNode, args) {
        this.hideColumnByHeaderId(args.id);
    };
    GwListView.prototype.resetTablePreferences = function (headerNode) {
        var listView = $(headerNode).closest("div.gw-ListViewWidget").get(0);
        gwPreferences_1.gwPreferences.resetPreferencesForId(listView.id);
    };
    /**
     * A helper method for hiding columns on the client side
     */
    GwListView.prototype.hideColumnByHeaderId = function (associatedHeaderId) {
        var enclosingTd = this.getHeaderTD(associatedHeaderId);
        if (!enclosingTd) {
            return;
        }
        var colIdx = $(enclosingTd).index();
        var $listViewElement = $(enclosingTd).closest(".gw-ListViewWidget");
        if (!$listViewElement) {
            return;
        }
        var columnToHide = $listViewElement.find("tr:not(.gw-RowGroup) td:nth-child(" + (colIdx + 1) + ")");
        if (columnToHide) {
            gwUtil_1.gwUtil.addClass(enclosingTd, "gw-isHiddenViaMenu");
            $(columnToHide).hide();
            this.applyColumnClasses($listViewElement[0]);
            this.storeHiddenColumnValueInLVPreferences($listViewElement[0].id, associatedHeaderId, true);
        }
    };
    GwListView.prototype.showColumn = function (clickedCell, args) {
        exports.gwListView.showColumnByHeaderId(args.id);
    };
    /**
     * A helper method for showing columns on the client side
     */
    GwListView.prototype.showColumnByHeaderId = function (associatedHeaderId) {
        var enclosingTd = this.getHeaderTD(associatedHeaderId);
        if (!enclosingTd) {
            return;
        }
        var hiddenColIdx = $(enclosingTd).index(); // 0 based index
        gwUtil_1.gwUtil.removeClass(enclosingTd, "gw-isHiddenViaMenu");
        var listViewElement = $(enclosingTd).closest(".gw-ListViewWidget")[0];
        if (!listViewElement) {
            return;
        }
        this.storeHiddenColumnValueInLVPreferences(listViewElement.id, associatedHeaderId);
        // nth child is 1 based idx; hiddenColIdx actually matches the column prior to the hidden col
        var columnToShow = $(listViewElement).find("tr:not(.gw-RowGroup) td:nth-child(" + (hiddenColIdx + 1) + ")");
        $(columnToShow).show();
        this.applyColumnClasses(listViewElement);
    };
    GwListView.prototype.applyPreferences = function () {
        var _this = this;
        var listViewIds = this.getListViewRenderIds();
        var columnsToHide = [];
        gwUtil_1.gwUtil.forEach(listViewIds, function (listViewId) {
            var listViewElement = document.getElementById(listViewId);
            if (listViewElement) {
                var columnPreferencesStr = gwPreferences_1.gwPreferences.getPreference(listViewId, _this.COLUMN_PREFERENCES);
                if (columnPreferencesStr) {
                    var columnPreferences_1 = JSON.parse(columnPreferencesStr);
                    Object.getOwnPropertyNames(columnPreferences_1).forEach(function (columnId) {
                        if (columnPreferences_1[columnId].hidden) {
                            columnsToHide.push(columnId);
                        }
                    });
                    // Clear hidden columns, apply ordering, then reapply hidden columns
                    if (columnPreferences_1.ordering) {
                        _this.resetHiddenColumns(listViewElement);
                        _this.applyColumnOrdering(listViewElement, columnPreferences_1.ordering);
                    }
                    // Hide columns
                    columnsToHide.forEach(function (columnId) {
                        _this.hideColumnByHeaderId(columnId);
                    });
                }
            }
        });
    };
    GwListView.prototype.storeColumnOrder = function (listViewElement) {
        var ids = this.headerColumnIds(listViewElement);
        if (ids.length > 0) {
            this.storeColumnOrderingInLVPreferences(listViewElement.id, ids);
        }
    };
    GwListView.prototype.toggleColumnVisibility = function (target, args) {
        gwUtil_1.gwUtil.toggleClass(target, "gw-checked");
        if (gwUtil_1.gwUtil.hasClass(target, "gw-checked")) {
            this.showColumnByHeaderId(args.headerId);
        }
        else {
            this.hideColumnByHeaderId(args.headerId);
        }
    };
    GwListView.prototype.toggleGroupedBy = function (target, args) {
        gwUtil_1.gwUtil.toggleClass(target, "gw-grouped");
        var header = document.getElementById(args.headerId);
        if (!header) {
            return;
        }
        if (gwUtil_1.gwUtil.hasClass(target, "gw-grouped")) {
            this.headerAction(header, { id: args.headerId, act: "GROUP_GROUP", suffix: "_act" });
        }
        else {
            this.headerAction(header, { id: args.headerId, act: "GROUP_UNGROUP", suffix: "_act" });
        }
    };
    // ----- Private helper functions ----- //
    GwListView.prototype.getHeaderTD = function (headerId) {
        var headerDiv = $("#" + headerId);
        if (!headerDiv) {
            return null;
        }
        return headerDiv.closest("td")[0];
    };
    GwListView.prototype.resetHiddenColumns = function (listViewElement) {
        var $collapsedColumns = $(listViewElement).find("td.gw-CollapsedCellWidget");
        $collapsedColumns.next().show();
        $collapsedColumns.remove();
    };
    GwListView.prototype.storeHiddenColumnValueInLVPreferences = function (listViewId, headerId, hiddenValue) {
        if (hiddenValue === void 0) { hiddenValue = false; }
        var columnPreferences = this.getColumnPreferences(listViewId);
        columnPreferences[headerId] = columnPreferences[headerId] || {};
        columnPreferences[headerId].hidden = hiddenValue;
        gwPreferences_1.gwPreferences.storePreference(listViewId, this.COLUMN_PREFERENCES, JSON.stringify(columnPreferences), this.PREFERENCE_TYPE);
    };
    GwListView.prototype.storeColumnOrderingInLVPreferences = function (listViewId, columnIdsInOrder) {
        var columnPreferences = this.getColumnPreferences(listViewId);
        columnPreferences.ordering = columnIdsInOrder;
        gwPreferences_1.gwPreferences.storePreference(listViewId, this.COLUMN_PREFERENCES, JSON.stringify(columnPreferences), this.PREFERENCE_TYPE);
    };
    GwListView.prototype.getColumnPreferences = function (listViewId) {
        var columnPreferencesStr = gwPreferences_1.gwPreferences.getPreference(listViewId, this.COLUMN_PREFERENCES);
        var columnPreferences;
        if (columnPreferencesStr) {
            columnPreferences = JSON.parse(columnPreferencesStr);
        }
        else {
            columnPreferences = {};
        }
        return columnPreferences;
    };
    GwListView.prototype.getListViewRenderIds = function () {
        var renderIds = [];
        var listViews = $(".gw-ListViewWidget");
        gwUtil_1.gwUtil.forEach(listViews, function (listViewWidget) {
            renderIds.push(listViewWidget.id);
        });
        return renderIds;
    };
    GwListView.prototype.moveColumn = function (listViewElement, sourceIndex, targetIndex) {
        var $columnToMove = $(listViewElement).find("tr:not(.gw-RowGroup):not([data-gw-ordered]) td:nth-child(" + (sourceIndex + 1) + ")");
        var $targetColumn = $(listViewElement).find("tr:not(.gw-RowGroup):not([data-gw-ordered]) td:nth-child(" + (targetIndex + 1) + ")");
        $columnToMove.each(function (idx, element) {
            $(element).insertBefore($targetColumn.get(idx));
        });
    };
    GwListView.prototype.getFirstValueWidgetInCell = function (td) {
        return td.querySelector(".gw-cell-inner .gw-ValueWidget");
    };
    GwListView.prototype.headerCells = function (listViewElement) {
        return Array.prototype.slice.call(listViewElement.querySelectorAll("[data-gw-cellindex]"));
    };
    GwListView.prototype.headerValueWidgets = function (listViewElement) {
        var _this = this;
        var headerCells = this.headerCells(listViewElement);
        var valueWidgets = [];
        gwUtil_1.gwUtil.forEach(headerCells, function (cell) {
            var valueWidget = _this.getFirstValueWidgetInCell(cell);
            if (valueWidget) {
                valueWidgets.push(valueWidget);
            }
        });
        return valueWidgets;
    };
    GwListView.prototype.headerColumnIds = function (listViewElement) {
        return this.headerValueWidgets(listViewElement).map(function (el) {
            return el.id;
        });
    };
    GwListView.prototype.headerColumnIdsInRenderOrder = function (listViewElement) {
        var _this = this;
        var cells = this.headerCells(listViewElement);
        var ids = [];
        gwUtil_1.gwUtil.forEach(cells, function (cell) {
            var valueWidget = _this.getFirstValueWidgetInCell(cell);
            if (valueWidget !== null) {
                var cellIndex = parseInt(cell.dataset.gwCellindex);
                ids[cellIndex] = valueWidget.id;
            }
        });
        return ids;
    };
    GwListView.prototype.applyColumnClasses = function (listViewElement) {
        this.refreshHeaderCellWithTargetClass(listViewElement, this.FIRST_HEADER_CELL_CLASS, "first");
        this.refreshHeaderCellWithTargetClass(listViewElement, this.LAST_HEADER_CELL_CLASS, "last");
    };
    GwListView.prototype.refreshHeaderCellWithTargetClass = function (listViewElement, targetClass, firstOrLast) {
        var prevHeaderCellWithTargetClass = $(listViewElement).find("tr:first").find("td." + targetClass);
        prevHeaderCellWithTargetClass.removeClass(targetClass);
        var newHeaderCellWithTargetClass = $(listViewElement).find("tr:first").find("td.gw-HeaderCellWidget")
            .filter(":not([class^=\"gw-impl-cell\"]):visible:" + firstOrLast);
        newHeaderCellWithTargetClass.addClass(targetClass);
    };
    GwListView.prototype.applyColumnOrdering = function (listViewElement, columnOrdering) {
        var _this = this;
        if (columnOrdering) {
            var targetIndex_1 = 0;
            var columnIdsInCellOrder_1 = this.headerColumnIdsInRenderOrder(listViewElement);
            columnOrdering.forEach(function (columnId) {
                var sourceIndex = columnIdsInCellOrder_1.indexOf(columnId);
                if (sourceIndex >= 0) {
                    // Source index can never be less than target index as everything less than target index is
                    // already ordered
                    if (sourceIndex > targetIndex_1) {
                        // Keep columnIdsInCellOrder array in sync with actual cells being moved around
                        columnIdsInCellOrder_1.splice(targetIndex_1, 0, columnIdsInCellOrder_1.splice(sourceIndex, 1)[0]);
                        _this.moveColumn(listViewElement, sourceIndex, targetIndex_1);
                    }
                    targetIndex_1++;
                }
            });
            this.applyColumnClasses(listViewElement);
            this.markColumnsAsOrdered(listViewElement);
        }
    };
    GwListView.prototype.markColumnsAsOrdered = function (listViewElement) {
        $(listViewElement).find("tr:not(.gw-RowGroup)").attr("data-gw-ordered", "true");
    };
    /**
     * @public
     * Handles an "Alt-Shift-Left" shortcut while in the context of an LV
     * @param node the node that received the shortcut
     * @param info the method info
     * @param event the event
     */
    GwListView.prototype.left = function (node, info, event) {
        var nextFocusable = null;
        var safety = 100;
        var goLeftUntilEnd = function ($currCell) {
            var $lastKnownGoodCell = $currCell;
            while ($currCell.length > 0) {
                $lastKnownGoodCell = $currCell;
                safety--;
                if (safety <= 0) {
                    break;
                }
                if (gwFocus_1.gwFocus.isFocusable($currCell[0])) {
                    nextFocusable = $currCell[0];
                    break;
                }
                $currCell = $currCell.prev("td");
            }
            if (!nextFocusable) {
                stepUpARow($lastKnownGoodCell);
            }
        };
        var stepUpARow = function ($currCell) {
            safety--;
            if (safety <= 0) {
                return;
            }
            var $prevRow = $currCell.closest("tr").prev("tr");
            if ($prevRow.length > 0) {
                goLeftUntilEnd($prevRow.children("td").last());
            }
        };
        var $startCell = $(node).closest("td");
        var $prevCell = $startCell.prev("td");
        if ($prevCell.length > 0) {
            goLeftUntilEnd($prevCell);
        }
        else {
            stepUpARow($startCell);
        }
        if (nextFocusable) {
            gwFocus_1.gwFocus.forceFocus(nextFocusable, false);
        }
        event.preventDefault();
    };
    /**
     * @public
     * Handles an "Alt-Shift-Right" shortcut while in the context of an LV
     * @param node the node that received the shortcut
     * @param info the method info
     * @param event the event
     */
    GwListView.prototype.right = function (node, info, event) {
        var nextFocusable = null;
        var safety = 100;
        var goRightUntilEnd = function ($currCell) {
            var $lastKnownGoodCell = $currCell;
            while ($currCell.length > 0) {
                $lastKnownGoodCell = $currCell;
                safety--;
                if (safety <= 0) {
                    break;
                }
                if (gwFocus_1.gwFocus.isFocusable($currCell[0])) {
                    nextFocusable = $currCell[0];
                    break;
                }
                $currCell = $currCell.next("td");
            }
            if (!nextFocusable) {
                stepDownARow($lastKnownGoodCell);
            }
        };
        var stepDownARow = function ($currCell) {
            safety--;
            if (safety <= 0) {
                return;
            }
            var $nextRow = $currCell.closest("tr").next("tr");
            if ($nextRow.length > 0) {
                goRightUntilEnd($nextRow.children("td").first());
            }
        };
        var $startCell = $(node).closest("td");
        var $nextCell = $startCell.next("td");
        if ($nextCell.length > 0) {
            goRightUntilEnd($nextCell);
        }
        else {
            stepDownARow($startCell);
        }
        if (nextFocusable) {
            gwFocus_1.gwFocus.forceFocus(nextFocusable, false);
        }
        event.preventDefault();
    };
    /**
     * @public
     * Handles an "Alt-Shift-Up" shortcut while in the context of an LV
     * @param node the node that received the shortcut
     * @param info the method info
     * @param event the event
     */
    GwListView.prototype.up = function (node, info, event) {
        var nextFocusable = null;
        var $currRow = $(node).closest("tr").prev("tr");
        var index = $(node).closest("td").index();
        var safety = 100;
        while ($currRow.length > 0) {
            safety--;
            if (safety <= 0) {
                break;
            }
            var testCell = $currRow.children()[index];
            if (gwFocus_1.gwFocus.isFocusable(testCell)) {
                nextFocusable = testCell;
                break;
            }
            $currRow = $currRow.prev("tr");
        }
        if (nextFocusable) {
            gwFocus_1.gwFocus.forceFocus(nextFocusable, false);
        }
        event.preventDefault();
    };
    /**
     * @public
     * Handles an "Alt-Shift-Down" shortcut while in the context of an LV
     * @param node the node that received the shortcut
     * @param info the method info
     * @param event the event
     */
    GwListView.prototype.down = function (node, info, event) {
        var nextFocusable = null;
        var $currRow = $(node).closest("tr").next("tr");
        var index = $(node).closest("td").index();
        var safety = 100;
        while ($currRow.length > 0) {
            safety--;
            if (safety <= 0) {
                break;
            }
            var testCell = $currRow.children()[index];
            if (gwFocus_1.gwFocus.isFocusable(testCell)) {
                nextFocusable = testCell;
                break;
            }
            $currRow = $currRow.next("tr");
        }
        if (nextFocusable) {
            gwFocus_1.gwFocus.forceFocus(nextFocusable, false);
        }
        event.preventDefault();
    };
    /**
     * Called by draggable.js
     */
    GwListView.prototype.dragStart = function (actionInner) {
        gwListViewHelper_1.gwListViewHelper.dragStart(actionInner);
    };
    /**
     * Called by draggable.js
     */
    GwListView.prototype.dragEnd = function () {
        gwListViewHelper_1.gwListViewHelper.dragEnd();
    };
    /**
     * Called by draggable.js
     */
    GwListView.prototype.dragCancel = function () {
        gwListViewHelper_1.gwListViewHelper.dragCancel();
    };
    /**
     * Called by draggable.js
     */
    GwListView.prototype.drag = function () {
        gwListViewHelper_1.gwListViewHelper.drag();
    };
    return GwListView;
}(GwDraggableSystem_1.GwDraggableSystem));
exports.GwListView = GwListView;
exports.gwListView = new GwListView();


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwDisplayKey_1 = __webpack_require__(16);
var gwTooltips_1 = __webpack_require__(56);
var gwListView_1 = __webpack_require__(232);
var GwPoint_1 = __webpack_require__(59);
var gwAnimation_1 = __webpack_require__(57);
var gwDraggable_1 = __webpack_require__(82);
var gwUtil_1 = __webpack_require__(0);
var GwListViewHelper = /** @class */ (function () {
    function GwListViewHelper() {
        // DRAGGABLE RELATED FUNCTIONALITY
        /**
         * Configurable number determine the valid drop area on either side of a cell border.
         * @type {number}
         */
        this.DROP_MARGIN = 12;
        this.SCROLL_TRIGGER_MARGIN = 12;
        this.SCROLL_AMOUNT = 12;
        /**
         * Used to calculate the offset of the drag bar from it's originally grabbed position.
         * @type {gwPoint}
         */
        this.mouseOffset = null;
        /**
         * Updated from draggable on every drag frame
         * @type gwPoint
         */
        this.mousePos = null;
        this.origContainerPos = null;
        this.dragContainerHalfWidth = null;
        this.headerRow = null;
        this.headerCellTds = null;
        this.ownerHeaderCell = null;
        this.currentDragContainer = null;
    }
    GwListViewHelper.prototype.getCurrentDragContainerOrThrow = function () {
        if (!this.currentDragContainer) {
            throw new Error("Missing currentDragContainer");
        }
        return this.currentDragContainer;
    };
    GwListViewHelper.prototype.getOwnerHeaderCellOrThrow = function () {
        if (!this.ownerHeaderCell) {
            throw new Error("Missing ownerHeaderCell");
        }
        return this.ownerHeaderCell;
    };
    GwListViewHelper.prototype.getHeaderCellTdsOrThrow = function () {
        if (!this.headerCellTds) {
            throw new Error("Missing headerCellTds");
        }
        return this.headerCellTds;
    };
    GwListViewHelper.prototype.getHeaderRowOrThrow = function () {
        if (!this.headerRow) {
            throw new Error("Missing headerRow");
        }
        return this.headerRow;
    };
    GwListViewHelper.prototype.getDragContainerHalfWidthOrThrow = function () {
        if (!this.dragContainerHalfWidth) {
            throw new Error("Missing dragContainerHalfWidth");
        }
        return this.dragContainerHalfWidth;
    };
    GwListViewHelper.prototype.getMousePosOrThrow = function () {
        if (!this.mousePos) {
            throw new Error("Missing mouse pos");
        }
        return this.mousePos;
    };
    GwListViewHelper.prototype.getMouseOffsetOrThrow = function () {
        if (!this.mouseOffset) {
            throw new Error("Missing mouse offset");
        }
        return this.mouseOffset;
    };
    GwListViewHelper.prototype.getOrigContainerPosOrThrow = function () {
        if (!this.origContainerPos) {
            throw new Error("Missing original container position");
        }
        return this.origContainerPos;
    };
    GwListViewHelper.prototype.addColumnMenuItems = function (listview, headerRow, columnsButton) {
        var _this = this;
        var subMenu = columnsButton.querySelector(".gw-subMenu");
        if (!subMenu) {
            return false;
        }
        var tds = headerRow.querySelectorAll("td");
        var menuNeeded = false;
        $(subMenu).find(".gw-client-only-item").remove();
        gwUtil_1.gwUtil.forEach(tds, function (td) {
            var headerInner = td.querySelector(".gw-header--inner");
            if (headerInner) {
                //NOTE: these first two are not being used yet, but we are going to need them when UX decides where to put filtering.
                //const isSortable = td.querySelector(".gw-sortable");
                //const isFilterable = td.querySelector(".gw-filterable");
                var isHideable = td.querySelector(".gw-hideable");
                var isGroupable = td.querySelector(".gw-groupable");
                var isDraggable = td.querySelector(".gw-draggable");
                // Menu obviously needed if hideable/groupable; but also needed if draggable so can reset positions
                if (isHideable || isGroupable || isDraggable) {
                    menuNeeded = true;
                }
                // If either is true, then we'll add a menu item for the header
                if (isHideable || isGroupable) {
                    var menuItemId = td.id + "_columns_menu";
                    var header = gwListView_1.gwListView.getFirstValueWidgetInCell(td);
                    if (!header) {
                        return;
                    }
                    var headerId = header.id;
                    var menuItem = gwUtil_1.gwUtil.createDiv(["gw-columns-menu--clientMenuItem", "gw-client-only-item"], { id: menuItemId });
                    // 1. If hideable add the hide toggle
                    if (isHideable) {
                        var isHidden = gwUtil_1.gwUtil.hasClass(td, "gw-isHiddenViaMenu");
                        var visibilityToggle = gwUtil_1.gwUtil.createDiv(["gw-toggle-column-visibility", isHidden ? "" : "gw-checked"], { "data-gw-click": "gwListView.toggleColumnVisibility headerId:" + td.id });
                        gwTooltips_1.gwTooltips.addTooltip(visibilityToggle, gwDisplayKey_1.gwDisplayKey.get("Web.Client.ListView.Column.ToggleHidden"));
                        menuItem.appendChild(visibilityToggle);
                    }
                    // 2. Copy the entire contents of the header inner into the menu, icons and labels and bears oh my
                    var clonedHeaderInner = headerInner.cloneNode(true);
                    clonedHeaderInner.removeAttribute("id");
                    clonedHeaderInner.classList.add("gw-columns-menu-item-label");
                    menuItem.appendChild(clonedHeaderInner);
                    // 3. If groupable, add the group toggle
                    if (isGroupable) {
                        var isGrouped = !!td.querySelector(".gw-isGrouped");
                        if (isGrouped) {
                            _this.modifyGroupRowLabels(td, listview);
                        }
                        var groupToggle = gwUtil_1.gwUtil.createDiv(["gw-toggle-column-grouping", isGrouped ? "gw-grouped" : ""], {
                            "data-gw-click": "gwListView.toggleGroupedBy headerId:" + headerId,
                            "data-gw-tooltip": gwDisplayKey_1.gwDisplayKey.get("Web.Client.ListView.Column.ToggleGroup")
                        });
                        gwTooltips_1.gwTooltips.addTooltip(groupToggle, gwDisplayKey_1.gwDisplayKey.get("Web.Client.ListView.Column.ToggleGroup"));
                        menuItem.appendChild(groupToggle);
                    }
                    subMenu.appendChild(menuItem);
                }
            }
        });
        return menuNeeded;
    };
    /**
     * Amends the currently grouped header cell label to the beginning of each of the group row labels.
     * @param groupedTd
     * @param listview
     */
    GwListViewHelper.prototype.modifyGroupRowLabels = function (groupedTd, listview) {
        if (!groupedTd || !listview) {
            return;
        }
        var labelEl = groupedTd.querySelector(".gw-label");
        if (!labelEl) {
            return;
        }
        var prefix = labelEl.textContent || "_";
        prefix += ":";
        gwUtil_1.gwUtil.forEach(listview.querySelectorAll(".gw-RowGroup--label"), function (groupLabelEl) {
            var existingColName = groupLabelEl.querySelector(".gw-RowGroup--label--col-name");
            if (!existingColName) {
                groupLabelEl.innerHTML = "<div class='gw-RowGroup--label--col-name'>" + prefix + "&nbsp" + "</div>" + groupLabelEl.textContent;
            }
        });
    };
    /**
     * Populates the Columns Menu with Menu Items for each valid header cell in each listview on the page.
     * @param optionalSingleLV - passing an optional LV element will cause the method to only generate
     * content for that LV.
     */
    GwListViewHelper.prototype.buildColumnsMenusForAllLVs = function (optionalSingleLV) {
        var _this = this;
        var listViews;
        if (optionalSingleLV) {
            listViews = [optionalSingleLV];
        }
        else {
            listViews = $(".gw-ListViewWidget");
        }
        gwUtil_1.gwUtil.forEach(listViews, function (listview) {
            var headerRow = listview.querySelector(".gw-RowWidget:not(.gw-isSmartHeader)");
            var uiSection = listview.querySelector(".gw-ListView--UI-section");
            var title = listview.querySelector(".gw-ListView--UI--title:not(:empty)");
            var toolbar = uiSection ? uiSection.querySelector(".gw-ToolbarWidget:not(:empty):not(.gw-placeholder)") : null;
            var paging = uiSection ? uiSection.querySelector(".gw-IteratorPagingWidget:not(:empty):not(.gw-placeholder)") : null;
            var filters = uiSection ? uiSection.querySelector(".gw-ListView--UI-filters:not(:empty)") : null;
            var columnsButton = uiSection ? uiSection.querySelector(".gw-ListView--UI--columns-menu") : null;
            var needsColumnMenu = false;
            var hasControls = false;
            if (headerRow && columnsButton) {
                needsColumnMenu = _this.addColumnMenuItems(listview, headerRow, columnsButton);
            }
            if (toolbar) {
                gwUtil_1.gwUtil.forEach(toolbar.childNodes, function (child) {
                    if (!gwUtil_1.gwUtil.hasAnyClass(child, ["gw-placeholder", "gw-ToolbarDividerWidget"])) {
                        hasControls = true;
                    }
                });
            }
            if (paging && !hasControls) {
                gwUtil_1.gwUtil.forEach(paging.childNodes, function (child) {
                    if (!gwUtil_1.gwUtil.hasClass(child, "gw-placeholder")) {
                        hasControls = true;
                    }
                });
            }
            if (filters && !hasControls) {
                gwUtil_1.gwUtil.forEach(filters.childNodes, function (child) {
                    if (!gwUtil_1.gwUtil.hasClass(child, "gw-placeholder")) {
                        hasControls = true;
                    }
                });
            }
            if (columnsButton) {
                gwUtil_1.gwUtil.conditionalAddRemoveClass(!needsColumnMenu, columnsButton, "gw-hidden");
            }
            if (uiSection) {
                gwUtil_1.gwUtil.conditionalAddRemoveClass(!needsColumnMenu && !hasControls && !title && !filters, uiSection, "gw-hidden");
                gwUtil_1.gwUtil.conditionalAddRemoveClass(columnsButton && needsColumnMenu && !hasControls && !title && !filters, uiSection, "gw-columns-menu-only");
            }
        });
    };
    /**
     * Calls getIndexForAndHighlightPossibleDrop
     * Moves the original column to the left of the targetColumn, unless the target column is the last in the row,
     * in which case it inserts the original column to the right of it.
     */
    GwListViewHelper.prototype.possiblyPlaceColumn = function () {
        var el = this.currentDragContainer;
        var targetIndex = this.getIndexForAndHighlightPossibleDrop();
        if (targetIndex === null) {
            return;
        }
        var headerCellTds = this.getHeaderCellTdsOrThrow();
        var originalIndex = targetIndex;
        for (var i = 0; i < headerCellTds.length; i++) {
            if (headerCellTds[i] === this.getOwnerHeaderCellOrThrow()) {
                originalIndex = i;
                break;
            }
        }
        //normalize indexes for 1 based element array
        originalIndex++;
        targetIndex++;
        // PLACE COLUMN
        var listview = gwUtil_1.gwUtil.getSelfOrFirstParentWithClassOrThrow(el, "gw-ListViewWidget");
        var columnToMove = $(listview).find("tr:not(.gw-RowGroup) td:nth-child(" + originalIndex + ")");
        if (targetIndex - 1 === headerCellTds.length) {
            targetIndex--;
            var targetColumn_1 = $(listview).find("tr:not(.gw-RowGroup) td:nth-child(" + targetIndex + ")");
            $(columnToMove).each(function (idx, element) {
                var $el = $(element);
                $el.insertAfter($(targetColumn_1).get(idx));
                gwAnimation_1.gwAnimation.addAnimation($el[0], "highlight-swap");
            });
        }
        else {
            if (originalIndex === targetIndex || (originalIndex < targetIndex && originalIndex + 1 === targetIndex)) {
                return;
            }
            var targetColumn_2 = $(listview).find("tr:not(.gw-RowGroup) td:nth-child(" + targetIndex + ")");
            $(columnToMove).each(function (idx, element) {
                var $el = $(element);
                $el.insertBefore($(targetColumn_2).get(idx));
                gwAnimation_1.gwAnimation.addAnimation($el[0], "highlight-swap");
            });
        }
        this.buildColumnsMenusForAllLVs(listview);
        gwListView_1.gwListView.applyColumnClasses(listview);
        gwListView_1.gwListView.markColumnsAsOrdered(listview);
        gwListView_1.gwListView.storeColumnOrder(listview);
    };
    /**
     * Returns the first element in the hierarchy with a scroll width greater than its client width
     * and with it's computed overflow x being equal to auto or scroll.
     * Stops at the screen widget.
     * @param el
     * @returns {element or null if none found}
     */
    GwListViewHelper.prototype.getScrollParentOrNull = function (el) {
        if (!el) {
            return null;
        }
        if (el.tagName.toLowerCase() === "div") {
            if (el.scrollWidth > el.clientWidth) {
                var compStyle = window.getComputedStyle(el);
                if (compStyle.overflowX === "auto" || compStyle.overflowX === "scroll") {
                    return el;
                }
            }
            // Limit of top level scroll parent to the four major panels
            if (gwUtil_1.gwUtil.hasAnyClass(el, ["gw-center-panel", "gw-west-panel", "gw-south-panel", "gw-north-panel"])) {
                return null;
            }
        }
        return this.getScrollParentOrNull(el.parentElement);
    };
    /**
     * Updates the header drag slider to be aligned with the mouse, while capping its position
     * to the row element, and attempting to scroll parent elements if the dragged element is near
     * either horizontal edge.
     */
    GwListViewHelper.prototype.moveSliderToMouse = function () {
        var el = this.getCurrentDragContainerOrThrow();
        var mousePos = this.getMousePosOrThrow();
        var mouseOffset = this.getMouseOffsetOrThrow();
        var headerRow = this.getHeaderRowOrThrow();
        var dragContainerHalfWidth = this.getDragContainerHalfWidthOrThrow();
        var origContainerPos = this.getOrigContainerPosOrThrow();
        var originalX = (mousePos.x + mouseOffset.x);
        var headerRowBounds = headerRow.getBoundingClientRect();
        // Restrict how far the drag container will go.  Positions are
        // relative to the left side of the dragContainer
        var minXposition = headerRowBounds.left - dragContainerHalfWidth;
        var maxXposition = headerRowBounds.right - dragContainerHalfWidth;
        var updatedXPosition = originalX;
        if (originalX < minXposition) {
            updatedXPosition = minXposition;
        }
        else if (originalX > maxXposition) {
            updatedXPosition = maxXposition;
        }
        el.style.top = origContainerPos.y + "px";
        el.style.left = updatedXPosition + "px";
        this.scrollListView(el);
    };
    GwListViewHelper.prototype.scrollListView = function (dragContainer) {
        var scrollParent = this.getScrollParentOrNull(this.getOwnerHeaderCellOrThrow());
        if (scrollParent) {
            var dragContainerBounds = dragContainer.getBoundingClientRect();
            var scrollParentBounds = scrollParent.getBoundingClientRect();
            if (dragContainerBounds.right >= scrollParentBounds.left + scrollParent.clientWidth - this.SCROLL_TRIGGER_MARGIN) {
                scrollParent.scrollLeft += this.SCROLL_AMOUNT;
            }
            else if (dragContainerBounds.left <= (scrollParentBounds.left + this.SCROLL_TRIGGER_MARGIN)) {
                scrollParent.scrollLeft -= this.SCROLL_AMOUNT;
            }
        }
    };
    /**
     * Caches off the headerRow and headerCellTds array.
     */
    GwListViewHelper.prototype.processHeaderRow = function () {
        this.headerRow = $(this.getOwnerHeaderCellOrThrow()).closest("tr")[0];
        this.headerCellTds = this.getHeaderRowOrThrow().querySelectorAll("td");
    };
    /**
     * Highlights both the dragged header, and valid left and right headers if the dragged header can be legally dropped.
     * Also returns the index of the valid drop position.
     * Returns null if the slider is not in a valid position to be dropped.
     * @returns {int or null}
     */
    GwListViewHelper.prototype.getIndexForAndHighlightPossibleDrop = function () {
        var el = this.getCurrentDragContainerOrThrow();
        var headerCellTds = this.getHeaderCellTdsOrThrow();
        var centerDragContainer = el.getBoundingClientRect().left + this.getDragContainerHalfWidthOrThrow();
        var currentHeaderInfo = null;
        var ownerHeaderCell = this.getOwnerHeaderCellOrThrow();
        gwUtil_1.gwUtil.removeClass(el, "gw-possibleDrop");
        for (var i = 0; i < headerCellTds.length; i++) {
            var currentHeaderCell = headerCellTds[i];
            // Skip over it if the header cell being checked is:
            // 1) hidden
            // 2) the same as the cell that's moving
            if (gwUtil_1.gwUtil.hasClass(currentHeaderCell, "gw-hidden") ||
                currentHeaderCell === ownerHeaderCell) {
                continue;
            }
            currentHeaderInfo = {
                td: currentHeaderCell,
                bounds: currentHeaderCell.getBoundingClientRect()
            };
            gwUtil_1.gwUtil.removeClass(currentHeaderCell, ["gw-tdDropHighlightRightCell", "gw-tdDropHighlightLeftCell"]);
            if (centerDragContainer >= currentHeaderInfo.bounds.left && centerDragContainer <= currentHeaderInfo.bounds.left + this.DROP_MARGIN) {
                // Don't highlight if the first column is not draggable or
                // it's the immediate boundary to the left of the cell begin moved
                if ((i === 0 && !this.headerCellDraggable(currentHeaderCell)) || (i > 0 && ownerHeaderCell === headerCellTds[i - 1])) {
                    return null;
                }
                gwUtil_1.gwUtil.addClass(currentHeaderCell, "gw-tdDropHighlightRightCell");
                gwUtil_1.gwUtil.addClass(el, "gw-possibleDrop");
                if (i > 0 && currentHeaderCell.previousSibling) {
                    gwUtil_1.gwUtil.addClass(currentHeaderCell.previousSibling, "gw-tdDropHighlightLeftCell");
                }
                return i;
            }
            if (centerDragContainer <= currentHeaderInfo.bounds.right && centerDragContainer >= currentHeaderInfo.bounds.right - this.DROP_MARGIN) {
                // Don't highlight if it's the immediate boundary to the right of the cell being moved
                if (i < headerCellTds.length && ownerHeaderCell === headerCellTds[i + 1]) {
                    return null;
                }
                gwUtil_1.gwUtil.addClass(currentHeaderCell, "gw-tdDropHighlightLeftCell");
                gwUtil_1.gwUtil.addClass(el, "gw-possibleDrop");
                if (i < headerCellTds.length && currentHeaderCell.nextSibling) {
                    gwUtil_1.gwUtil.addClass(currentHeaderCell.nextSibling, "gw-tdDropHighlightRightCell");
                }
                return i + 1;
            }
        }
        //Slider is not in highlight range of anything
        return null;
    };
    /**
     * Returns true if the header cell is marked as being draggable
     * @param headerCell header cell being checked for drag-ability
     * @returns {boolean} returns true if the header cell is marked to be draggable else returns false
     */
    GwListViewHelper.prototype.headerCellDraggable = function (headerCell) {
        return !!headerCell.querySelector(".gw-draggable");
    };
    GwListViewHelper.prototype.resetAllDragChanges = function () {
        gwUtil_1.gwUtil.forEach(this.headerCellTds, function (td) {
            gwUtil_1.gwUtil.removeClass(td, ["gw-tdDropHighlightRightCell", "gw-tdDropHighlightLeftCell"]);
        });
        var el = this.currentDragContainer;
        if (el) {
            gwUtil_1.gwUtil.removeClass(el, "gw-sliding");
            el.style.height = null;
            el.style.width = null;
            el.style.left = null;
            el.style.top = null;
        }
        if (this.ownerHeaderCell) {
            var headerInner = this.ownerHeaderCell.querySelector(".gw-header--inner");
            if (headerInner) {
                gwUtil_1.gwUtil.removeClass(headerInner, "gw-sliding");
            }
        }
        if (this.currentDragContainer) {
            gwUtil_1.gwUtil.removeClass(this.currentDragContainer, "gw-sliding");
        }
        if (this.ownerHeaderCell) {
            gwUtil_1.gwUtil.removeClass(this.ownerHeaderCell, "gw-sliding");
        }
        this.mouseOffset = null;
        this.mousePos = null;
        this.ownerHeaderCell = null;
        this.currentDragContainer = null;
        this.dragContainerHalfWidth = null;
    };
    GwListViewHelper.prototype.dragStart = function (actionInner) {
        var dragId = actionInner.getAttribute("data-gw-drag-id");
        if (!dragId) {
            return;
        }
        this.currentDragContainer = document.getElementById(dragId);
        if (!this.currentDragContainer) {
            return;
        }
        gwDraggable_1.gwDraggable.enableDragHover(); //Needed so that draggable.js calls "drag" on an interval, even when the mouse isn't moving
        this.mousePos = gwDraggable_1.gwDraggable.getCurrentMousePos();
        this.origContainerPos = GwPoint_1.GwPoint.getElTopLeftVector(actionInner);
        this.mouseOffset = this.origContainerPos.minus(this.mousePos);
        this.ownerHeaderCell = gwUtil_1.gwUtil.getSelfOrFirstParentWithClass(actionInner, "gw-HeaderCellWidget");
        this.processHeaderRow();
        var currentDragContainer = this.getCurrentDragContainerOrThrow();
        var ownerHeaderCell = this.getOwnerHeaderCellOrThrow();
        gwUtil_1.gwUtil.addClass(currentDragContainer, "gw-sliding");
        gwUtil_1.gwUtil.addClass(ownerHeaderCell, "gw-sliding");
        var sizerForDrag = ownerHeaderCell;
        currentDragContainer.style.height = sizerForDrag.offsetHeight + "px";
        currentDragContainer.style.width = sizerForDrag.offsetWidth + "px";
        this.dragContainerHalfWidth = sizerForDrag.offsetWidth / 2;
        var headerInner = ownerHeaderCell.querySelector(".gw-header--inner");
        if (headerInner) {
            gwUtil_1.gwUtil.addClass(headerInner, "gw-sliding");
        }
        this.moveSliderToMouse();
    };
    GwListViewHelper.prototype.dragEnd = function () {
        if (!this.currentDragContainer) {
            return;
        }
        this.possiblyPlaceColumn();
        this.resetAllDragChanges();
    };
    GwListViewHelper.prototype.dragCancel = function () {
        if (!this.currentDragContainer) {
            return;
        }
        this.resetAllDragChanges();
    };
    GwListViewHelper.prototype.drag = function () {
        if (!this.currentDragContainer) {
            return;
        }
        this.mousePos = gwDraggable_1.gwDraggable.getCurrentMousePos();
        this.moveSliderToMouse();
        this.getIndexForAndHighlightPossibleDrop();
    };
    return GwListViewHelper;
}());
exports.GwListViewHelper = GwListViewHelper;
exports.gwListViewHelper = new GwListViewHelper();


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwFlagGroup = /** @class */ (function () {
    function GwFlagGroup(iteratorId) {
        var _this = this;
        this.headerCheckBox = null;
        this.operations = {
            one: function (button, flagName) {
                return this.countTargetedCheckedCheckBoxesWithFlag(button, flagName) === 1
                    && this.targetedCheckedCheckBoxes(button).length === 1;
            },
            two: function (button, flagName) {
                return this.countTargetedCheckedCheckBoxesWithFlag(button, flagName) === 2
                    && this.targetedCheckedCheckBoxes(button).length === 2;
            },
            any: function (button, flagName) {
                return this.countTargetedCheckedCheckBoxesWithFlag(button, flagName) > 0;
            },
            no: function (button, flagName) {
                return this.countTargetedCheckedCheckBoxesWithFlag(button, flagName) === 0;
            },
            all: function (button, flagName) {
                var checkedWithFlag = this.countTargetedCheckedCheckBoxesWithFlag(button, flagName);
                return checkedWithFlag > 0 && checkedWithFlag === this.targetedCheckedCheckBoxes(button).length;
            },
            exists: function (button, flagName) {
                var _this = this;
                return this.targetedCheckBoxes(button)
                    .filter(function (checkBox) {
                    return _this.checkBoxHasFlag(checkBox, flagName);
                }).length > 0;
            }
        };
        this.checkBoxes = [];
        this.buttons = [];
        if (iteratorId === undefined) {
            throw new Error("checkbox flag group missing an iterator id");
        }
        $("[data-gw-flags-scope='" + iteratorId + "']").each(function (index, element) {
            if (element.dataset.gwFlagsConditions !== undefined) {
                _this.buttons.push(element);
            }
            else if (element.dataset.gwFlagsForEntry !== undefined) {
                _this.checkBoxes.push(element);
            }
            else {
                _this.headerCheckBox = element;
            }
        });
    }
    GwFlagGroup.prototype.updateButtonsAvailability = function () {
        var _this = this;
        this.buttons.forEach(function (button) { return _this.updateButtonAvailability(button); });
    };
    GwFlagGroup.prototype.updateButtonAvailability = function (button) {
        var _this = this;
        var conditions = button.dataset.gwFlagsConditions.split(",");
        var disabled = false;
        conditions.forEach(function (condition) {
            if (!_this.evaluateCondition(button, condition.trim())) {
                disabled = true;
            }
        });
        // Changed disabled on button (for mouseover) plus the inner and expand divs
        gwUtil_1.gwUtil.conditionalAddRemoveClass(disabled, button, "gw-disabled");
        gwUtil_1.gwUtil.forEach($(button).find("> .gw-action--inner, > .gw-action--expand-button"), function (clickable) {
            gwUtil_1.gwUtil.conditionalAddRemoveClass(disabled, clickable, "gw-disabled");
        });
    };
    GwFlagGroup.prototype.evaluateCondition = function (button, condition) {
        var parts = condition.split(" ").map(function (part) {
            return part.trim();
        });
        if (parts.length !== 2) {
            return true;
        }
        var method = parts[0];
        if (typeof this.operations[method] !== "function") {
            throw new Error("received unknown method for Flag Group: " + method);
        }
        return this.operations[method].call(this, button, parts[1]); //TODO: not in love with having to call this. Could move the methods onto the instance to be cleaner
    };
    GwFlagGroup.prototype.countTargetedCheckedCheckBoxesWithFlag = function (button, flagName) {
        var _this = this;
        return this.targetedCheckedCheckBoxes(button).reduce(function (acc, checkBox) {
            var found = flagName === "*" || _this.checkBoxHasFlag(checkBox, flagName);
            return found ? acc + 1 : acc;
        }, 0);
    };
    GwFlagGroup.prototype.checkBoxHasFlag = function (checkBox, flagName) {
        return checkBox.dataset.gwFlagsForEntry.split(",").indexOf(flagName) >= 0;
    };
    GwFlagGroup.prototype.targetedCheckedCheckBoxes = function (button) {
        return this.targetedCheckBoxes(button).filter(function (c) {
            return c.checked;
        });
    };
    GwFlagGroup.prototype.targetedCheckBoxes = function (button) {
        var _this = this;
        return this.checkBoxes.filter(function (c) {
            return _this.targetListStartsWith(c.dataset.gwFlagsTarget, button.dataset.gwFlagsTarget);
        });
    };
    GwFlagGroup.prototype.targetListStartsWith = function (targetList, targetSubList) {
        return targetList.indexOf(targetSubList) === 0
            && (targetSubList.length === targetList.length || targetList[targetSubList.length] === ",");
    };
    return GwFlagGroup;
}());
exports.GwFlagGroup = GwFlagGroup;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-import-side-effect */
__export(__webpack_require__(134));
__export(__webpack_require__(231));
__export(__webpack_require__(529));
__export(__webpack_require__(41));
__export(__webpack_require__(55));
__export(__webpack_require__(40));
__export(__webpack_require__(84));
__export(__webpack_require__(129));
__export(__webpack_require__(219));
__export(__webpack_require__(530));
__export(__webpack_require__(531));
__export(__webpack_require__(224));
__export(__webpack_require__(532));
__export(__webpack_require__(533));
__export(__webpack_require__(534));
__export(__webpack_require__(131));
__export(__webpack_require__(535));
__export(__webpack_require__(225));
__export(__webpack_require__(229));
__export(__webpack_require__(222));
__export(__webpack_require__(536));
__export(__webpack_require__(537));
__export(__webpack_require__(130));
__export(__webpack_require__(221));
__export(__webpack_require__(228));
__export(__webpack_require__(232));
__export(__webpack_require__(233));
__export(__webpack_require__(127));
__export(__webpack_require__(59));
__export(__webpack_require__(61));
__export(__webpack_require__(230));
__export(__webpack_require__(85));
__export(__webpack_require__(3));
__export(__webpack_require__(23));
__export(__webpack_require__(60));
__export(__webpack_require__(217));
__export(__webpack_require__(10));
__export(__webpack_require__(57));
__export(__webpack_require__(538));
__export(__webpack_require__(80));
__export(__webpack_require__(133));
__export(__webpack_require__(16));
__export(__webpack_require__(82));
__export(__webpack_require__(8));
__export(__webpack_require__(25));
__export(__webpack_require__(81));
__export(__webpack_require__(539));
__export(__webpack_require__(58));
__export(__webpack_require__(26));
__export(__webpack_require__(540));
__export(__webpack_require__(86));
__export(__webpack_require__(218));
__export(__webpack_require__(128));
__export(__webpack_require__(28));
__export(__webpack_require__(62));
__export(__webpack_require__(35));
__export(__webpack_require__(27));
__export(__webpack_require__(24));
__export(__webpack_require__(541));
__export(__webpack_require__(56));
__export(__webpack_require__(542));
__export(__webpack_require__(132));
__export(__webpack_require__(234));
__export(__webpack_require__(226));
__export(__webpack_require__(227));
__export(__webpack_require__(543));
__export(__webpack_require__(5));
__export(__webpack_require__(220));
__export(__webpack_require__(54));
__export(__webpack_require__(223));
__export(__webpack_require__(83));
__export(__webpack_require__(4));
__export(__webpack_require__(11));
__export(__webpack_require__(2));
__export(__webpack_require__(544));
__export(__webpack_require__(15));
__export(__webpack_require__(0));
__export(__webpack_require__(29));
__export(__webpack_require__(20));


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__build_package__ = __webpack_require__(238);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return __WEBPACK_IMPORTED_MODULE_0__build_package__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_array__ = __webpack_require__(9);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "max", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "median", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "min", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "range", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return __WEBPACK_IMPORTED_MODULE_1_d3_array__["E"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_axis__ = __webpack_require__(255);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return __WEBPACK_IMPORTED_MODULE_2_d3_axis__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return __WEBPACK_IMPORTED_MODULE_2_d3_axis__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return __WEBPACK_IMPORTED_MODULE_2_d3_axis__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return __WEBPACK_IMPORTED_MODULE_2_d3_axis__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_brush__ = __webpack_require__(259);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "brush", function() { return __WEBPACK_IMPORTED_MODULE_3_d3_brush__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "brushX", function() { return __WEBPACK_IMPORTED_MODULE_3_d3_brush__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "brushY", function() { return __WEBPACK_IMPORTED_MODULE_3_d3_brush__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "brushSelection", function() { return __WEBPACK_IMPORTED_MODULE_3_d3_brush__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_chord__ = __webpack_require__(346);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "chord", function() { return __WEBPACK_IMPORTED_MODULE_4_d3_chord__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ribbon", function() { return __WEBPACK_IMPORTED_MODULE_4_d3_chord__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_d3_collection__ = __webpack_require__(44);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "set", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "map", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "values", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return __WEBPACK_IMPORTED_MODULE_5_d3_collection__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_d3_color__ = __webpack_require__(17);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "color", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return __WEBPACK_IMPORTED_MODULE_6_d3_color__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_d3_dispatch__ = __webpack_require__(30);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return __WEBPACK_IMPORTED_MODULE_7_d3_dispatch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_d3_drag__ = __webpack_require__(88);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return __WEBPACK_IMPORTED_MODULE_8_d3_drag__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return __WEBPACK_IMPORTED_MODULE_8_d3_drag__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return __WEBPACK_IMPORTED_MODULE_8_d3_drag__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_d3_dsv__ = __webpack_require__(102);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return __WEBPACK_IMPORTED_MODULE_9_d3_dsv__["g"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_d3_ease__ = __webpack_require__(165);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["E"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["G"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["F"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["H"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["I"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["K"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["J"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return __WEBPACK_IMPORTED_MODULE_10_d3_ease__["s"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_d3_force__ = __webpack_require__(359);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceCenter", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceCollide", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceLink", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceManyBody", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceRadial", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceSimulation", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceX", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "forceY", function() { return __WEBPACK_IMPORTED_MODULE_11_d3_force__["h"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_d3_format__ = __webpack_require__(107);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "format", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return __WEBPACK_IMPORTED_MODULE_12_d3_format__["h"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_d3_geo__ = __webpack_require__(389);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["E"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["L"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["M"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["N"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["F"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["G"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["H"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["I"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["J"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["K"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["P"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["Q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["T"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["U"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["O"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["R"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return __WEBPACK_IMPORTED_MODULE_13_d3_geo__["S"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__ = __webpack_require__(417);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "cluster", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "hierarchy", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pack", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "packSiblings", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "packEnclose", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stratify", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tree", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemap", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapBinary", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapDice", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapSlice", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapSliceDice", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapSquarify", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "treemapResquarify", function() { return __WEBPACK_IMPORTED_MODULE_14_d3_hierarchy__["l"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__ = __webpack_require__(13);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return __WEBPACK_IMPORTED_MODULE_15_d3_interpolate__["w"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_d3_path__ = __webpack_require__(31);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "path", function() { return __WEBPACK_IMPORTED_MODULE_16_d3_path__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_d3_polygon__ = __webpack_require__(439);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "polygonArea", function() { return __WEBPACK_IMPORTED_MODULE_17_d3_polygon__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "polygonCentroid", function() { return __WEBPACK_IMPORTED_MODULE_17_d3_polygon__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "polygonHull", function() { return __WEBPACK_IMPORTED_MODULE_17_d3_polygon__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "polygonContains", function() { return __WEBPACK_IMPORTED_MODULE_17_d3_polygon__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "polygonLength", function() { return __WEBPACK_IMPORTED_MODULE_17_d3_polygon__["e"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_d3_quadtree__ = __webpack_require__(105);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "quadtree", function() { return __WEBPACK_IMPORTED_MODULE_18_d3_quadtree__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_d3_queue__ = __webpack_require__(446);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "queue", function() { return __WEBPACK_IMPORTED_MODULE_19_d3_queue__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_d3_random__ = __webpack_require__(449);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomLogNormal", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomBates", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomIrwinHall", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "randomExponential", function() { return __WEBPACK_IMPORTED_MODULE_20_d3_random__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_d3_request__ = __webpack_require__(454);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "request", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "html", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "json", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "text", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return __WEBPACK_IMPORTED_MODULE_21_d3_request__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_d3_scale__ = __webpack_require__(461);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20c", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return __WEBPACK_IMPORTED_MODULE_22_d3_scale__["s"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_d3_selection__ = __webpack_require__(6);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "create", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "local", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "select", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "style", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "window", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "event", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return __WEBPACK_IMPORTED_MODULE_23_d3_selection__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_d3_shape__ = __webpack_require__(494);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "arc", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "area", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "line", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "areaRadial", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "radialArea", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "radialLine", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pointRadial", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbol", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["P"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["X"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["Q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolCross", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["R"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["S"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["T"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolStar", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["U"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["V"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "symbolWye", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["W"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveBasis", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveBundle", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveLinear", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveNatural", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["E"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["G"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["F"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["H"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["I"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["J"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["K"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["L"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["M"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["N"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return __WEBPACK_IMPORTED_MODULE_24_d3_shape__["O"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_d3_time__ = __webpack_require__(75);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["L"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["M"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["r"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["s"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSecond", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["V"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["W"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeHours", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeDays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["B"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["C"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSunday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["t"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSundays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["u"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMonday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMondays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["x"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["A"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeThursday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["v"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["w"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeFriday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeFridays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["p"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["n"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeMonths", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["o"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["D"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeYears", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["E"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMinute", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["N"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["O"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcHour", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["J"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["K"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcDay", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["F"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["G"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcWeek", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_5"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_6"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["X"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["Y"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["P"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["Q"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_1"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_2"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_3"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_4"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["Z"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_0"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["H"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["I"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["T"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["U"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMonth", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["R"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["S"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcYear", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_7"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return __WEBPACK_IMPORTED_MODULE_25_d3_time__["_8"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_d3_time_format__ = __webpack_require__(119);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeFormatDefaultLocale", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeFormatLocale", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "isoFormat", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "isoParse", function() { return __WEBPACK_IMPORTED_MODULE_26_d3_time_format__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_d3_timer__ = __webpack_require__(66);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "now", function() { return __WEBPACK_IMPORTED_MODULE_27_d3_timer__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return __WEBPACK_IMPORTED_MODULE_27_d3_timer__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return __WEBPACK_IMPORTED_MODULE_27_d3_timer__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return __WEBPACK_IMPORTED_MODULE_27_d3_timer__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return __WEBPACK_IMPORTED_MODULE_27_d3_timer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_d3_transition__ = __webpack_require__(99);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return __WEBPACK_IMPORTED_MODULE_28_d3_transition__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "active", function() { return __WEBPACK_IMPORTED_MODULE_28_d3_transition__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return __WEBPACK_IMPORTED_MODULE_28_d3_transition__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_d3_voronoi__ = __webpack_require__(519);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "voronoi", function() { return __WEBPACK_IMPORTED_MODULE_29_d3_voronoi__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_d3_zoom__ = __webpack_require__(524);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return __WEBPACK_IMPORTED_MODULE_30_d3_zoom__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return __WEBPACK_IMPORTED_MODULE_30_d3_zoom__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return __WEBPACK_IMPORTED_MODULE_30_d3_zoom__["b"]; });

































/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export name */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return version; });
/* unused harmony export description */
/* unused harmony export keywords */
/* unused harmony export homepage */
/* unused harmony export license */
/* unused harmony export author */
/* unused harmony export main */
/* unused harmony export unpkg */
/* unused harmony export jsdelivr */
/* unused harmony export module */
/* unused harmony export repository */
/* unused harmony export scripts */
/* unused harmony export devDependencies */
/* unused harmony export dependencies */
var name = "d3";
var version = "4.13.0";
var description = "Data-Driven Documents";
var keywords = ["dom","visualization","svg","animation","canvas"];
var homepage = "https://d3js.org";
var license = "BSD-3-Clause";
var author = {"name":"Mike Bostock","url":"https://bost.ocks.org/mike"};
var main = "build/d3.node.js";
var unpkg = "build/d3.min.js";
var jsdelivr = "build/d3.min.js";
var module = "index";
var repository = {"type":"git","url":"https://github.com/d3/d3.git"};
var scripts = {"pretest":"rimraf build && mkdir build && json2module package.json > build/package.js && node rollup.node","test":"tape 'test/**/*-test.js'","prepublishOnly":"npm run test && rollup -c --banner \"$(preamble)\" && uglifyjs -b beautify=false,preamble=\"'$(preamble)'\" build/d3.js -c negate_iife=false -m -o build/d3.min.js","postpublish":"git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/build/d3.js d3.v4.js && cp ../d3/build/d3.min.js d3.v4.min.js && git add d3.v4.js d3.v4.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/build/d3.js ../d3/build/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j build/d3.zip -- LICENSE README.md API.md CHANGES.md build/d3.js build/d3.min.js"};
var devDependencies = {"json2module":"0.0","package-preamble":"0.1","rimraf":"2","rollup":"0.53","rollup-plugin-ascii":"0.0","rollup-plugin-node-resolve":"3","tape":"4","uglify-js":"3.2"};
var dependencies = {"d3-array":"1.2.1","d3-axis":"1.0.8","d3-brush":"1.0.4","d3-chord":"1.0.4","d3-collection":"1.0.4","d3-color":"1.0.3","d3-dispatch":"1.0.3","d3-drag":"1.2.1","d3-dsv":"1.0.8","d3-ease":"1.0.3","d3-force":"1.1.0","d3-format":"1.2.2","d3-geo":"1.9.1","d3-hierarchy":"1.1.5","d3-interpolate":"1.1.6","d3-path":"1.0.5","d3-polygon":"1.0.3","d3-quadtree":"1.0.3","d3-queue":"3.0.7","d3-random":"1.1.0","d3-request":"1.0.6","d3-scale":"1.0.7","d3-selection":"1.3.0","d3-shape":"1.2.0","d3-time":"1.0.8","d3-time-format":"2.1.1","d3-timer":"1.0.7","d3-transition":"1.1.1","d3-voronoi":"1.1.2","d3-zoom":"1.7.1"};


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pairs__ = __webpack_require__(137);


/* harmony default export */ __webpack_exports__["a"] = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = __WEBPACK_IMPORTED_MODULE_0__pairs__["b" /* pair */];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bisect__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extent__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__identity__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__range__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ticks__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__threshold_sturges__ = __webpack_require__(144);









/* harmony default export */ __webpack_exports__["a"] = (function() {
  var value = __WEBPACK_IMPORTED_MODULE_4__identity__["a" /* default */],
      domain = __WEBPACK_IMPORTED_MODULE_3__extent__["a" /* default */],
      threshold = __WEBPACK_IMPORTED_MODULE_7__threshold_sturges__["a" /* default */];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(__WEBPACK_IMPORTED_MODULE_6__ticks__["c" /* tickStep */])(x0, x1, tz);
      tz = Object(__WEBPACK_IMPORTED_MODULE_5__range__["a" /* default */])(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(__WEBPACK_IMPORTED_MODULE_1__bisect__["c" /* default */])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* slice */].call(_)) : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(_), histogram) : threshold;
  };

  return histogram;
});


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ascending__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__quantile__ = __webpack_require__(87);





/* harmony default export */ __webpack_exports__["a"] = (function(values, min, max) {
  values = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* map */].call(values, __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */]).sort(__WEBPACK_IMPORTED_MODULE_1__ascending__["a" /* default */]);
  return Math.ceil((max - min) / (2 * (Object(__WEBPACK_IMPORTED_MODULE_3__quantile__["a" /* default */])(values, 0.75) - Object(__WEBPACK_IMPORTED_MODULE_3__quantile__["a" /* default */])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__deviation__ = __webpack_require__(138);


/* harmony default export */ __webpack_exports__["a"] = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(__WEBPACK_IMPORTED_MODULE_0__deviation__["a" /* default */])(values) * Math.pow(values.length, -1 / 3)));
});


/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(42);


/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});


/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__number__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__quantile__ = __webpack_require__(87);




/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_1__number__["a" /* default */])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(__WEBPACK_IMPORTED_MODULE_1__number__["a" /* default */])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(__WEBPACK_IMPORTED_MODULE_2__quantile__["a" /* default */])(numbers.sort(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */]), 0.5);
});


/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});


/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});


/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(36);


/* harmony default export */ __webpack_exports__["a"] = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = __WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});


/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});


/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transpose__ = __webpack_require__(146);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__transpose__["a" /* default */])(arguments);
});


/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_axis__ = __webpack_require__(256);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_axis__["b"]; });



/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = axisTop;
/* harmony export (immutable) */ __webpack_exports__["c"] = axisRight;
/* harmony export (immutable) */ __webpack_exports__["a"] = axisBottom;
/* harmony export (immutable) */ __webpack_exports__["b"] = axisLeft;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__identity__ = __webpack_require__(258);



var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_brush__ = __webpack_require__(260);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_brush__["a"]; });



/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = brushSelection;
/* harmony export (immutable) */ __webpack_exports__["b"] = brushX;
/* harmony export (immutable) */ __webpack_exports__["c"] = brushY;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_drag__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_transition__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constant__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__event__ = __webpack_require__(344);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__noevent__ = __webpack_require__(345);









var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush(X);
}

function brushY() {
  return brush(Y);
}

/* harmony default export */ __webpack_exports__["d"] = (function() {
  return brush(XY);
});

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = Object(__WEBPACK_IMPORTED_MODULE_2_d3_interpolate__["a" /* interpolate */])(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["b" /* interrupt */])(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["d" /* customEvent */])(new __WEBPACK_IMPORTED_MODULE_6__event__["a" /* default */](brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].touches) { if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].changedTouches.length < __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].touches.length) return Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].target.__data__.type,
        mode = (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].shiftKey,
        lockX,
        lockY,
        point0 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["b" /* dragDisable */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view);
    }

    Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["b" /* nopropagation */])();
    Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["b" /* interrupt */])(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["b" /* nopropagation */])();
      if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].touches) {
        if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["c" /* dragEnable */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
    }

    function keyupped() {
      switch (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      Object(__WEBPACK_IMPORTED_MODULE_7__noevent__["a" /* default */])();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodrag__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__noevent__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constant__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__event__ = __webpack_require__(298);







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].x, y: __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), __WEBPACK_IMPORTED_MODULE_1_d3_selection__["h" /* mouse */], this, arguments);
    if (!gesture) return;
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["k" /* select */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(__WEBPACK_IMPORTED_MODULE_2__nodrag__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].view);
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
    mousemoving = false;
    mousedownx = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].clientX;
    mousedowny = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
    if (!mousemoving) {
      var dx = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].clientX - mousedownx, dy = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["k" /* select */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].view).on("mousemove.drag mouseup.drag", null);
    Object(__WEBPACK_IMPORTED_MODULE_2__nodrag__["b" /* yesdrag */])(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].view, mousemoving);
    Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, __WEBPACK_IMPORTED_MODULE_1_d3_selection__["q" /* touch */], this, arguments)) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["a" /* default */])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = __WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__noevent__["b" /* nopropagation */])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["d" /* customEvent */])(new __WEBPACK_IMPORTED_MODULE_5__event__["a" /* default */](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((__WEBPACK_IMPORTED_MODULE_1_d3_selection__["e" /* event */].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["d" /* customEvent */])(new __WEBPACK_IMPORTED_MODULE_5__event__["a" /* default */](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_4__constant__["a" /* default */])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__select__ = __webpack_require__(147);



/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__select__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name).call(document.documentElement));
});


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(91);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectorAll__ = __webpack_require__(148);



/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_1__selectorAll__["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, parents);
});


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matcher__ = __webpack_require__(149);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_1__matcher__["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](subgroups, this._parents);
});


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__enter__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(268);




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a" /* EnterNode */](parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__["a" /* EnterNode */](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(12);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Selection */](this._exit || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__["a" /* default */]), this._parents);
});


/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);


/* harmony default export */ __webpack_exports__["a"] = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](merges, this._parents);
});


/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(12);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Selection */](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});


/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return !this.node();
});


/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(89);


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(raise);
});


/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(lower);
});


/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(63);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(91);



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__["a" /* default */])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(__WEBPACK_IMPORTED_MODULE_1__selector__["a" /* default */])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.each(remove);
});


/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ __webpack_exports__["a"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(92);


function dispatchEvent(node, type, params) {
  var window = Object(__WEBPACK_IMPORTED_MODULE_0__window__["a" /* default */])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = local;
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(64);



/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  var event = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, event);
});


/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(12);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement])
      : new __WEBPACK_IMPORTED_MODULE_0__selection_index__["a" /* Selection */]([selector == null ? [] : selector], __WEBPACK_IMPORTED_MODULE_0__selection_index__["c" /* root */]);
});


/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(64);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touch);
    }
  }

  return null;
});


/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(64);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches) {
  if (touches == null) touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__["a" /* default */])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(__WEBPACK_IMPORTED_MODULE_1__point__["a" /* default */])(node, touches[i]);
  }

  return points;
});


/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DragEvent;
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = lab;
/* unused harmony export Lab */
/* harmony export (immutable) */ __webpack_exports__["b"] = hcl;
/* unused harmony export Hcl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(155);




var Kn = 18,
    Xn = 0.950470, // D65 standard referent
    Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * __WEBPACK_IMPORTED_MODULE_2__math__["a" /* deg2rad */];
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__["h" /* rgbConvert */])(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Lab, lab, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */](
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * __WEBPACK_IMPORTED_MODULE_2__math__["b" /* rad2deg */];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Hcl, hcl, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cubehelix;
/* unused harmony export Cubehelix */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(155);




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__["h" /* rgbConvert */])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * __WEBPACK_IMPORTED_MODULE_2__math__["b" /* rad2deg */] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(__WEBPACK_IMPORTED_MODULE_0__define__["a" /* default */])(Cubehelix, cubehelix, Object(__WEBPACK_IMPORTED_MODULE_0__define__["b" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* Color */], {
  brighter: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__["c" /* brighter */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* brighter */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__["d" /* darker */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__["d" /* darker */], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * __WEBPACK_IMPORTED_MODULE_2__math__["a" /* deg2rad */],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new __WEBPACK_IMPORTED_MODULE_1__color__["b" /* Rgb */](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
});


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return interpolateTransformSvg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(303);



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(__WEBPACK_IMPORTED_MODULE_0__number__["a" /* default */])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["a" /* parseCss */], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__["b" /* parseSvg */], ", ", ")", ")");


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCss;
/* harmony export (immutable) */ __webpack_exports__["b"] = parseSvg;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decompose__ = __webpack_require__(304);


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* default */])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose__["b" /* identity */];
  value = value.matrix;
  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__["a" /* default */])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["a"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ __webpack_exports__["a"] = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hslLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(43);



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["d" /* hsl */])(end)).h),
        s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (hsl(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = lab;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(43);



function lab(start, end) {
  var l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* lab */])(start)).l, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["e" /* lab */])(end)).l),
      a = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.a, end.a),
      b = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.b, end.b),
      opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hclLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(43);



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* hcl */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["c" /* hcl */])(end)).h),
        c = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.c, end.c),
        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["a"] = (hcl(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cubehelixLong; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(43);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(end)).h),
          s = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.s, end.s),
          l = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.l, end.l),
          opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["b"] = (cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["c" /* hue */]));
var cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__["a" /* default */]);


/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__interrupt__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transition__ = __webpack_require__(315);




__WEBPACK_IMPORTED_MODULE_0_d3_selection__["m" /* selection */].prototype.interrupt = __WEBPACK_IMPORTED_MODULE_1__interrupt__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0_d3_selection__["m" /* selection */].prototype.transition = __WEBPACK_IMPORTED_MODULE_2__transition__["a" /* default */];


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interrupt__ = __webpack_require__(163);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  return this.each(function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__interrupt__["a" /* default */])(this, name);
  });
});


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(100);


/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__["a" /* Timer */];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(100);


/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {
  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__["a" /* Timer */], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(__WEBPACK_IMPORTED_MODULE_0__timer__["b" /* now */])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_ease__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_timer__ = __webpack_require__(66);





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: __WEBPACK_IMPORTED_MODULE_2_d3_ease__["o" /* easeCubicInOut */]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["b" /* now */])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var id,
      timing;

  if (name instanceof __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */]) {
    id = name._id, name = name._name;
  } else {
    id = Object(__WEBPACK_IMPORTED_MODULE_0__transition_index__["c" /* newId */])(), (timing = defaultTiming).time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__["b" /* now */])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(__WEBPACK_IMPORTED_MODULE_1__transition_schedule__["e" /* default */])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */](groups, this._parents, name, id);
});


/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(164);





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["i" /* namespace */])(name), i = fullname === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["u" /* interpolateTransformSvg */] : __WEBPACK_IMPORTED_MODULE_3__interpolate__["a" /* default */];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__["b" /* tweenValue */])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
});


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);


function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["i" /* namespace */])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(14);


function delayFunction(id, value) {
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).delay;
});


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(14);


function durationFunction(id, value) {
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).duration;
});


/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(14);


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).ease;
});


/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(21);



/* harmony default export */ __webpack_exports__["a"] = (function(match) {
  if (typeof match !== "function") match = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["g" /* matcher */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, this._parents, this._name, this._id);
});


/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(21);


/* harmony default export */ __webpack_exports__["a"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Transition */](merges, this._parents, this._name, this._id);
});


/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(14);


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? __WEBPACK_IMPORTED_MODULE_0__schedule__["g" /* init */] : __WEBPACK_IMPORTED_MODULE_0__schedule__["h" /* set */];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(__WEBPACK_IMPORTED_MODULE_0__schedule__["f" /* get */])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(14);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["n" /* selector */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["e" /* default */])(subgroup[i], name, id, i, subgroup, Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["f" /* get */])(node, id));
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, this._parents, name, id);
});


/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(14);




/* harmony default export */ __webpack_exports__["a"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__["o" /* selectorAll */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["f" /* get */])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(__WEBPACK_IMPORTED_MODULE_2__schedule__["e" /* default */])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_1__index__["a" /* Transition */](subgroups, parents, name, id);
});


/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);


var Selection = __WEBPACK_IMPORTED_MODULE_0_d3_selection__["m" /* selection */].prototype.constructor;

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(164);





function styleRemove(name, interpolate) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["p" /* style */])(this, name),
        value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["p" /* style */])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["p" /* style */])(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["p" /* style */])(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__["p" /* style */])(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__["t" /* interpolateTransformCss */] : __WEBPACK_IMPORTED_MODULE_3__interpolate__["a" /* default */];
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__["b" /* tweenValue */])(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
});


/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tween__ = __webpack_require__(67);


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(__WEBPACK_IMPORTED_MODULE_0__tween__["b" /* tweenValue */])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__schedule__ = __webpack_require__(14);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(__WEBPACK_IMPORTED_MODULE_0__index__["c" /* newId */])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(__WEBPACK_IMPORTED_MODULE_1__schedule__["f" /* get */])(node, id0);
        Object(__WEBPACK_IMPORTED_MODULE_1__schedule__["e" /* default */])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* Transition */](groups, this._parents, name, id1);
});


/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = linear;
function linear(t) {
  return +t;
}


/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quadIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = quadOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = quadInOut;
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cubicIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = cubicOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = cubicInOut;
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sinIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = sinOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = sinInOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = expIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = expOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = expInOut;
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}


/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = circleIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = circleOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = circleInOut;
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bounceIn;
/* harmony export (immutable) */ __webpack_exports__["c"] = bounceOut;
/* harmony export (immutable) */ __webpack_exports__["b"] = bounceInOut;
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(14);



var root = [null];

/* harmony default export */ __webpack_exports__["a"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > __WEBPACK_IMPORTED_MODULE_1__transition_schedule__["c" /* SCHEDULED */] && schedule.name === name) {
        return new __WEBPACK_IMPORTED_MODULE_0__transition_index__["a" /* Transition */]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
});


/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
});


/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_chord__ = __webpack_require__(347);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_chord__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_ribbon__ = __webpack_require__(348);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_ribbon__["a"]; });




/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(166);



function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = Object(__WEBPACK_IMPORTED_MODULE_1__math__["c" /* max */])(0, __WEBPACK_IMPORTED_MODULE_1__math__["e" /* tau */] - padAngle * n) / k;
    dx = k ? padAngle : __WEBPACK_IMPORTED_MODULE_1__math__["e" /* tau */] / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = Object(__WEBPACK_IMPORTED_MODULE_1__math__["c" /* max */])(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
});


/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_path__ = __webpack_require__(31);





function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - __WEBPACK_IMPORTED_MODULE_2__math__["b" /* halfPi */],
        sa1 = endAngle.apply(this, argv) - __WEBPACK_IMPORTED_MODULE_2__math__["b" /* halfPi */],
        sx0 = sr * Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* cos */])(sa0),
        sy0 = sr * Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* sin */])(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - __WEBPACK_IMPORTED_MODULE_2__math__["b" /* halfPi */],
        ta1 = endAngle.apply(this, argv) - __WEBPACK_IMPORTED_MODULE_2__math__["b" /* halfPi */];

    if (!context) context = buffer = Object(__WEBPACK_IMPORTED_MODULE_3_d3_path__["a" /* path */])();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* cos */])(ta0), tr * Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* sin */])(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
});


/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {}

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (path);


/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__map__ = __webpack_require__(101);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(__WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */])();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__map__ = __webpack_require__(101);


function Set() {}

var proto = __WEBPACK_IMPORTED_MODULE_0__map__["a" /* default */].prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[__WEBPACK_IMPORTED_MODULE_0__map__["b" /* prefix */] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ __webpack_exports__["a"] = (set);


/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});


/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});


/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return csvFormatRows; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(103);


var csv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;


/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return tsvFormatRows; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dsv__ = __webpack_require__(103);


var tsv = Object(__WEBPACK_IMPORTED_MODULE_0__dsv__["a" /* default */])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;


/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_center__ = __webpack_require__(360);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_center__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_collide__ = __webpack_require__(361);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_collide__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_link__ = __webpack_require__(375);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__src_link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_manyBody__ = __webpack_require__(376);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_3__src_manyBody__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_radial__ = __webpack_require__(377);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_4__src_radial__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_simulation__ = __webpack_require__(167);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_5__src_simulation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_x__ = __webpack_require__(378);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_6__src_x__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_y__ = __webpack_require__(379);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_7__src_y__["a"]; });










/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});


/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__jiggle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_quadtree__ = __webpack_require__(105);




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ __webpack_exports__["a"] = (function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = Object(__WEBPACK_IMPORTED_MODULE_2_d3_quadtree__["a" /* quadtree */])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += x * x;
            if (y === 0) y = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : radius;
  };

  return force;
});


/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quadtree;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__add__ = __webpack_require__(363);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cover__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__data__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extent__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__find__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__remove__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__root__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__size__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__visit__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__visitAfter__ = __webpack_require__(372);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__x__ = __webpack_require__(373);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__y__ = __webpack_require__(374);













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? __WEBPACK_IMPORTED_MODULE_10__x__["b" /* defaultX */] : x, y == null ? __WEBPACK_IMPORTED_MODULE_11__y__["b" /* defaultY */] : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = __WEBPACK_IMPORTED_MODULE_0__add__["b" /* default */];
treeProto.addAll = __WEBPACK_IMPORTED_MODULE_0__add__["a" /* addAll */];
treeProto.cover = __WEBPACK_IMPORTED_MODULE_1__cover__["a" /* default */];
treeProto.data = __WEBPACK_IMPORTED_MODULE_2__data__["a" /* default */];
treeProto.extent = __WEBPACK_IMPORTED_MODULE_3__extent__["a" /* default */];
treeProto.find = __WEBPACK_IMPORTED_MODULE_4__find__["a" /* default */];
treeProto.remove = __WEBPACK_IMPORTED_MODULE_5__remove__["a" /* default */];
treeProto.removeAll = __WEBPACK_IMPORTED_MODULE_5__remove__["b" /* removeAll */];
treeProto.root = __WEBPACK_IMPORTED_MODULE_6__root__["a" /* default */];
treeProto.size = __WEBPACK_IMPORTED_MODULE_7__size__["a" /* default */];
treeProto.visit = __WEBPACK_IMPORTED_MODULE_8__visit__["a" /* default */];
treeProto.visitAfter = __WEBPACK_IMPORTED_MODULE_9__visitAfter__["a" /* default */];
treeProto.x = __WEBPACK_IMPORTED_MODULE_10__x__["a" /* default */];
treeProto.y = __WEBPACK_IMPORTED_MODULE_11__y__["a" /* default */];


/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = addAll;
/* harmony default export */ __webpack_exports__["b"] = (function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
});

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
});


/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
});


/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
});


/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quad__ = __webpack_require__(106);


/* harmony default export */ __webpack_exports__["a"] = (function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node[3], xm, ym, x2, y2),
        new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node[2], x1, ym, xm, y2),
        new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node[1], xm, y1, x2, ym),
        new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
});


/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = removeAll;
/* harmony default export */ __webpack_exports__["a"] = (function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
});

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this._root;
});


/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
});


/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quad__ = __webpack_require__(106);


/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, x0, y0, xm, ym));
    }
  }
  return this;
});


/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__quad__ = __webpack_require__(106);


/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new __WEBPACK_IMPORTED_MODULE_0__quad__["a" /* default */](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
});


/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = defaultX;
function defaultX(d) {
  return d[0];
}

/* harmony default export */ __webpack_exports__["a"] = (function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
});


/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = defaultY;
function defaultY(d) {
  return d[1];
}

/* harmony default export */ __webpack_exports__["a"] = (function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
});


/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__jiggle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_collection__ = __webpack_require__(44);




function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

/* harmony default export */ __webpack_exports__["a"] = (function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])();
        y = target.y + target.vy - source.y - source.vy || Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = Object(__WEBPACK_IMPORTED_MODULE_2_d3_collection__["c" /* map */])(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initializeDistance(), force) : distance;
  };

  return force;
});


/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__jiggle__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_quadtree__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__simulation__ = __webpack_require__(167);





/* harmony default export */ __webpack_exports__["a"] = (function() {
  var nodes,
      node,
      alpha,
      strength = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = Object(__WEBPACK_IMPORTED_MODULE_2_d3_quadtree__["a" /* quadtree */])(nodes, __WEBPACK_IMPORTED_MODULE_3__simulation__["b" /* x */], __WEBPACK_IMPORTED_MODULE_3__simulation__["c" /* y */]).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += x * x;
        if (y === 0) y = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += x * x;
      if (y === 0) y = Object(__WEBPACK_IMPORTED_MODULE_1__jiggle__["a" /* default */])(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
});


/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);


/* harmony default export */ __webpack_exports__["a"] = (function(radius, x, y) {
  var nodes,
      strength = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});


/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  var strength = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : x;
  };

  return force;
});


/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(37);


/* harmony default export */ __webpack_exports__["a"] = (function(y) {
  var strength = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), initialize(), force) : y;
  };

  return force;
});


/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return formatPrefix; });
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(168);


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
});


/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(108);


/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(68);


/* harmony default export */ __webpack_exports__["a"] = (function(step) {
  return Math.max(0, -Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(68);


/* harmony default export */ __webpack_exports__["a"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3 - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(68);


/* harmony default export */ __webpack_exports__["a"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(max) - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(step)) + 1;
});


/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_area__ = __webpack_require__(172);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__src_area__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_bounds__ = __webpack_require__(390);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_1__src_bounds__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_centroid__ = __webpack_require__(391);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_2__src_centroid__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_circle__ = __webpack_require__(173);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_3__src_circle__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_clip_antimeridian__ = __webpack_require__(175);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_4__src_clip_antimeridian__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_clip_circle__ = __webpack_require__(181);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_5__src_clip_circle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_clip_extent__ = __webpack_require__(393);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_6__src_clip_extent__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_clip_rectangle__ = __webpack_require__(70);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_7__src_clip_rectangle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_contains__ = __webpack_require__(395);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_8__src_contains__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_distance__ = __webpack_require__(182);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_9__src_distance__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_graticule__ = __webpack_require__(396);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_10__src_graticule__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_10__src_graticule__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_interpolate__ = __webpack_require__(397);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_11__src_interpolate__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_length__ = __webpack_require__(183);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_12__src_length__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_path_index__ = __webpack_require__(398);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_13__src_path_index__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_projection_albers__ = __webpack_require__(185);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_14__src_projection_albers__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_projection_albersUsa__ = __webpack_require__(406);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_15__src_projection_albersUsa__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_projection_azimuthalEqualArea__ = __webpack_require__(407);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_16__src_projection_azimuthalEqualArea__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_16__src_projection_azimuthalEqualArea__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_projection_azimuthalEquidistant__ = __webpack_require__(408);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_17__src_projection_azimuthalEquidistant__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_17__src_projection_azimuthalEquidistant__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_projection_conicConformal__ = __webpack_require__(409);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_18__src_projection_conicConformal__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_18__src_projection_conicConformal__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__src_projection_conicEqualArea__ = __webpack_require__(110);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_19__src_projection_conicEqualArea__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_19__src_projection_conicEqualArea__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__src_projection_conicEquidistant__ = __webpack_require__(410);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_20__src_projection_conicEquidistant__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_20__src_projection_conicEquidistant__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__src_projection_equirectangular__ = __webpack_require__(186);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_21__src_projection_equirectangular__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_21__src_projection_equirectangular__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__src_projection_gnomonic__ = __webpack_require__(411);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_22__src_projection_gnomonic__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_22__src_projection_gnomonic__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__src_projection_identity__ = __webpack_require__(412);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_23__src_projection_identity__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__src_projection_index__ = __webpack_require__(18);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return __WEBPACK_IMPORTED_MODULE_24__src_projection_index__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return __WEBPACK_IMPORTED_MODULE_24__src_projection_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__src_projection_mercator__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_25__src_projection_mercator__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_25__src_projection_mercator__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__src_projection_naturalEarth1__ = __webpack_require__(413);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_26__src_projection_naturalEarth1__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_26__src_projection_naturalEarth1__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__src_projection_orthographic__ = __webpack_require__(414);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_27__src_projection_orthographic__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_27__src_projection_orthographic__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__src_projection_stereographic__ = __webpack_require__(415);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return __WEBPACK_IMPORTED_MODULE_28__src_projection_stereographic__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return __WEBPACK_IMPORTED_MODULE_28__src_projection_stereographic__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__src_projection_transverseMercator__ = __webpack_require__(416);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return __WEBPACK_IMPORTED_MODULE_29__src_projection_transverseMercator__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return __WEBPACK_IMPORTED_MODULE_29__src_projection_transverseMercator__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__src_rotation__ = __webpack_require__(69);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return __WEBPACK_IMPORTED_MODULE_30__src_rotation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__src_stream__ = __webpack_require__(32);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return __WEBPACK_IMPORTED_MODULE_31__src_stream__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__src_transform__ = __webpack_require__(71);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return __WEBPACK_IMPORTED_MODULE_32__src_transform__["a"]; });






 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).




























/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__area__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cartesian__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__stream__ = __webpack_require__(32);






var lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00, phi00, // first point
    p0, // previous 3D point
    deltaSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    __WEBPACK_IMPORTED_MODULE_1__area__["b" /* areaStream */].polygonStart();
  },
  polygonEnd: function() {
    __WEBPACK_IMPORTED_MODULE_1__area__["b" /* areaStream */].polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (__WEBPACK_IMPORTED_MODULE_1__area__["a" /* areaRingSum */] < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > __WEBPACK_IMPORTED_MODULE_3__math__["i" /* epsilon */]) phi1 = 90;
    else if (deltaSum < -__WEBPACK_IMPORTED_MODULE_3__math__["i" /* epsilon */]) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = Object(__WEBPACK_IMPORTED_MODULE_2__cartesian__["a" /* cartesian */])([lambda * __WEBPACK_IMPORTED_MODULE_3__math__["r" /* radians */], phi * __WEBPACK_IMPORTED_MODULE_3__math__["r" /* radians */]]);
  if (p0) {
    var normal = Object(__WEBPACK_IMPORTED_MODULE_2__cartesian__["c" /* cartesianCross */])(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = Object(__WEBPACK_IMPORTED_MODULE_2__cartesian__["c" /* cartesianCross */])(equatorial, normal);
    Object(__WEBPACK_IMPORTED_MODULE_2__cartesian__["e" /* cartesianNormalizeInPlace */])(inflection);
    inflection = Object(__WEBPACK_IMPORTED_MODULE_2__cartesian__["g" /* spherical */])(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * __WEBPACK_IMPORTED_MODULE_3__math__["h" /* degrees */] * sign,
        phii,
        antimeridian = Object(__WEBPACK_IMPORTED_MODULE_3__math__["a" /* abs */])(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * __WEBPACK_IMPORTED_MODULE_3__math__["h" /* degrees */];
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * __WEBPACK_IMPORTED_MODULE_3__math__["h" /* degrees */];
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(Object(__WEBPACK_IMPORTED_MODULE_3__math__["a" /* abs */])(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }
  __WEBPACK_IMPORTED_MODULE_1__area__["b" /* areaStream */].point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  __WEBPACK_IMPORTED_MODULE_1__area__["b" /* areaStream */].lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  __WEBPACK_IMPORTED_MODULE_1__area__["b" /* areaStream */].lineEnd();
  if (Object(__WEBPACK_IMPORTED_MODULE_3__math__["a" /* abs */])(deltaSum) > __WEBPACK_IMPORTED_MODULE_3__math__["i" /* epsilon */]) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ __webpack_exports__["a"] = (function(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  Object(__WEBPACK_IMPORTED_MODULE_4__stream__["a" /* default */])(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0, phi0], [lambda1, phi1]];
});


/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__stream__ = __webpack_require__(32);




var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: __WEBPACK_IMPORTED_MODULE_1__noop__["a" /* default */],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */];
  var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi);
  centroidPointCartesian(cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda), cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda), Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */];
  var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi);
  x0 = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda);
  y0 = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda);
  z0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */];
  var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi),
      x = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda),
      y = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda),
      z = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi),
      w = Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */];
  centroidStream.point = centroidRingPoint;
  var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi);
  x0 = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda);
  y0 = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda);
  z0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */], phi *= __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */];
  var cosPhi = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi),
      x = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(lambda),
      y = cosPhi * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(lambda),
      z = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(cx * cx + cy * cy + cz * cz),
      w = Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ __webpack_exports__["a"] = (function(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  Object(__WEBPACK_IMPORTED_MODULE_2__stream__["a" /* default */])(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < __WEBPACK_IMPORTED_MODULE_0__math__["j" /* epsilon2 */]) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < __WEBPACK_IMPORTED_MODULE_0__math__["j" /* epsilon2 */]) return [NaN, NaN];
  }

  return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(y, x) * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */], Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(z / Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(m)) * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */]];
});


/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rectangle__ = __webpack_require__(70);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = Object(__WEBPACK_IMPORTED_MODULE_0__rectangle__["a" /* default */])(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
});


/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
});


/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygonContains__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__distance__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(1);




var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__distance__["a" /* default */])(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = Object(__WEBPACK_IMPORTED_MODULE_1__distance__["a" /* default */])(coordinates[0], coordinates[1]),
      ao = Object(__WEBPACK_IMPORTED_MODULE_1__distance__["a" /* default */])(coordinates[0], point),
      ob = Object(__WEBPACK_IMPORTED_MODULE_1__distance__["a" /* default */])(point, coordinates[1]);
  return ao + ob <= ab + __WEBPACK_IMPORTED_MODULE_2__math__["i" /* epsilon */];
}

function containsPolygon(coordinates, point) {
  return !!Object(__WEBPACK_IMPORTED_MODULE_0__polygonContains__["a" /* default */])(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */], point[1] * __WEBPACK_IMPORTED_MODULE_2__math__["r" /* radians */]];
}

/* harmony default export */ __webpack_exports__["a"] = (function(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
});


/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = graticule;
/* harmony export (immutable) */ __webpack_exports__["b"] = graticule10;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);



function graticuleX(y0, y1, dy) {
  var y = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(y0, y1 - __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */], dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(x0, x1 - __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */], dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["f" /* ceil */])(X0 / DX) * DX, X1, DX).map(X)
        .concat(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["f" /* ceil */])(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["f" /* ceil */])(x0 / dx) * dx, x1, dx).filter(function(x) { return Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(x % DX) > __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]; }).map(x))
        .concat(Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["f" /* ceil */])(y0 / dy) * dy, y1, dy).filter(function(y) { return Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(y % DY) > __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]], [180, 90 - __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]]])
      .extentMinor([[-180, -80 - __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]], [180, 80 + __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */]]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var x0 = a[0] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */],
      y0 = a[1] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */],
      x1 = b[0] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */],
      y1 = b[1] * __WEBPACK_IMPORTED_MODULE_0__math__["r" /* radians */],
      cy0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y0),
      sy0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y0),
      cy1 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y1),
      sy1 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y1),
      kx0 = cy0 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x0),
      ky0 = cy0 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x0),
      kx1 = cy1 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x1),
      ky1 = cy1 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x1),
      d = 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["m" /* haversin */])(y1 - y0) + cy0 * cy1 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["m" /* haversin */])(x1 - x0))),
      k = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(d);

  var interpolate = d ? function(t) {
    var B = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(t *= d) / k,
        A = Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(y, x) * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */],
      Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(z, Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(x * x + y * y)) * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */]
    ];
  } : function() {
    return [x0 * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */], y0 * __WEBPACK_IMPORTED_MODULE_0__math__["h" /* degrees */]];
  };

  interpolate.distance = d;

  return interpolate;
});


/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stream__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__area__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bounds__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__centroid__ = __webpack_require__(400);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__context__ = __webpack_require__(401);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__measure__ = __webpack_require__(402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__string__ = __webpack_require__(403);









/* harmony default export */ __webpack_exports__["a"] = (function(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      Object(__WEBPACK_IMPORTED_MODULE_1__stream__["a" /* default */])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    Object(__WEBPACK_IMPORTED_MODULE_1__stream__["a" /* default */])(object, projectionStream(__WEBPACK_IMPORTED_MODULE_2__area__["a" /* default */]));
    return __WEBPACK_IMPORTED_MODULE_2__area__["a" /* default */].result();
  };

  path.measure = function(object) {
    Object(__WEBPACK_IMPORTED_MODULE_1__stream__["a" /* default */])(object, projectionStream(__WEBPACK_IMPORTED_MODULE_6__measure__["a" /* default */]));
    return __WEBPACK_IMPORTED_MODULE_6__measure__["a" /* default */].result();
  };

  path.bounds = function(object) {
    Object(__WEBPACK_IMPORTED_MODULE_1__stream__["a" /* default */])(object, projectionStream(__WEBPACK_IMPORTED_MODULE_3__bounds__["a" /* default */]));
    return __WEBPACK_IMPORTED_MODULE_3__bounds__["a" /* default */].result();
  };

  path.centroid = function(object) {
    Object(__WEBPACK_IMPORTED_MODULE_1__stream__["a" /* default */])(object, projectionStream(__WEBPACK_IMPORTED_MODULE_4__centroid__["a" /* default */]));
    return __WEBPACK_IMPORTED_MODULE_4__centroid__["a" /* default */].result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, __WEBPACK_IMPORTED_MODULE_0__identity__["a" /* default */]) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new __WEBPACK_IMPORTED_MODULE_7__string__["a" /* default */]) : new __WEBPACK_IMPORTED_MODULE_5__context__["a" /* default */](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
});


/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noop__ = __webpack_require__(22);




var areaSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    areaRingSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineStart: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineEnd: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */];
    areaSum.add(Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["a"] = (areaStream);


/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["a"] = (centroidStream);


/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PathContext;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop__ = __webpack_require__(22);



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, __WEBPACK_IMPORTED_MODULE_0__math__["w" /* tau */]);
        break;
      }
    }
  },
  result: __WEBPACK_IMPORTED_MODULE_1__noop__["a" /* default */]
};


/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adder__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__noop__ = __webpack_require__(22);




var lengthSum = Object(__WEBPACK_IMPORTED_MODULE_0__adder__["a" /* default */])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = __WEBPACK_IMPORTED_MODULE_2__noop__["a" /* default */];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add(Object(__WEBPACK_IMPORTED_MODULE_1__math__["u" /* sqrt */])(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ __webpack_exports__["a"] = (lengthStream);


/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PathString;
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cartesian__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transform__ = __webpack_require__(71);




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = Object(__WEBPACK_IMPORTED_MODULE_1__math__["g" /* cos */])(30 * __WEBPACK_IMPORTED_MODULE_1__math__["r" /* radians */]); // cos(minimum angular distance)

/* harmony default export */ __webpack_exports__["a"] = (function(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__transform__["b" /* transformer */])({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = Object(__WEBPACK_IMPORTED_MODULE_1__math__["u" /* sqrt */])(a * a + b * b + c * c),
          phi2 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["c" /* asin */])(c /= m),
          lambda2 = Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(c) - 1) < __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */] || Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(lambda0 - lambda1) < __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */] ? (lambda0 + lambda1) / 2 : Object(__WEBPACK_IMPORTED_MODULE_1__math__["e" /* atan2 */])(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = Object(__WEBPACK_IMPORTED_MODULE_0__cartesian__["a" /* cartesian */])([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cylindricalEqualAreaRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(y * cosPhi0)];
  };

  return forward;
}


/***/ }),
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__albers__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__conicEqualArea__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__fit__ = __webpack_require__(112);





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var cache,
      cacheStream,
      lower48 = Object(__WEBPACK_IMPORTED_MODULE_1__albers__["a" /* default */])(), lower48Point,
      alaska = Object(__WEBPACK_IMPORTED_MODULE_2__conicEqualArea__["b" /* default */])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = Object(__WEBPACK_IMPORTED_MODULE_2__conicEqualArea__["b" /* default */])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */], y + 0.120 * k + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]], [x - 0.214 * k - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */], y + 0.234 * k - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */], y + 0.166 * k + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]], [x - 0.115 * k - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */], y + 0.234 * k - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["a" /* fitExtent */])(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["c" /* fitSize */])(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["d" /* fitWidth */])(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["b" /* fitHeight */])(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
});


/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return azimuthalEqualAreaRaw; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__azimuthal__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




var azimuthalEqualAreaRaw = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["b" /* azimuthalRaw */])(function(cxcy) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["a" /* azimuthalInvert */])(function(z) {
  return 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */])(z / 2);
});

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
});


/***/ }),
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return azimuthalEquidistantRaw; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__azimuthal__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




var azimuthalEquidistantRaw = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["b" /* azimuthalRaw */])(function(c) {
  return (c = Object(__WEBPACK_IMPORTED_MODULE_0__math__["b" /* acos */])(c)) && c / Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(c);
});

azimuthalEquidistantRaw.invert = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["a" /* azimuthalInvert */])(function(z) {
  return z;
});

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
});


/***/ }),
/* 409 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = conicConformalRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__conic__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mercator__ = __webpack_require__(113);




function tany(y) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__math__["v" /* tan */])((__WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y0),
      n = y0 === y1 ? Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y0) : Object(__WEBPACK_IMPORTED_MODULE_0__math__["n" /* log */])(cy0 / Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y1)) / Object(__WEBPACK_IMPORTED_MODULE_0__math__["n" /* log */])(tany(y1) / tany(y0)),
      f = cy0 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["p" /* pow */])(tany(y0), n) / n;

  if (!n) return __WEBPACK_IMPORTED_MODULE_2__mercator__["c" /* mercatorRaw */];

  function project(x, y) {
    if (f > 0) { if (y < -__WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]) y = -__WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]; }
    else { if (y > __WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]) y = __WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] - __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]; }
    var r = f / Object(__WEBPACK_IMPORTED_MODULE_0__math__["p" /* pow */])(tany(y), n);
    return [r * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(n * x), f - r * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = Object(__WEBPACK_IMPORTED_MODULE_0__math__["s" /* sign */])(n) * Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(x * x + fy * fy);
    return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(x, Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(fy)) / n * Object(__WEBPACK_IMPORTED_MODULE_0__math__["s" /* sign */])(fy), 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["d" /* atan */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["p" /* pow */])(f / r, 1 / n)) - __WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */]];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_1__conic__["a" /* conicProjection */])(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
});


/***/ }),
/* 410 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = conicEquidistantRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__conic__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__equirectangular__ = __webpack_require__(186);




function conicEquidistantRaw(y0, y1) {
  var cy0 = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y0),
      n = y0 === y1 ? Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y0) : (cy0 - Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(n) < __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]) return __WEBPACK_IMPORTED_MODULE_2__equirectangular__["b" /* equirectangularRaw */];

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(nx), g - gy * Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["e" /* atan2 */])(x, Object(__WEBPACK_IMPORTED_MODULE_0__math__["a" /* abs */])(gy)) / n * Object(__WEBPACK_IMPORTED_MODULE_0__math__["s" /* sign */])(gy), g - Object(__WEBPACK_IMPORTED_MODULE_0__math__["s" /* sign */])(n) * Object(__WEBPACK_IMPORTED_MODULE_0__math__["u" /* sqrt */])(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["b"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_1__conic__["a" /* conicProjection */])(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
});


/***/ }),
/* 411 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = gnomonicRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__azimuthal__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




function gnomonicRaw(x, y) {
  var cy = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y), k = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x) * cy;
  return [cy * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x) / k, Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y) / k];
}

gnomonicRaw.invert = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["a" /* azimuthalInvert */])(__WEBPACK_IMPORTED_MODULE_0__math__["d" /* atan */]);

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
});


/***/ }),
/* 412 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__clip_rectangle__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__identity__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transform__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__fit__ = __webpack_require__(112);





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */] : Object(__WEBPACK_IMPORTED_MODULE_2__transform__["b" /* transformer */])({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */], // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */],
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */]) : Object(__WEBPACK_IMPORTED_MODULE_0__clip_rectangle__["a" /* default */])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["a" /* fitExtent */])(projection, extent, object);
    },
    fitSize: function(size, object) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["c" /* fitSize */])(projection, size, object);
    },
    fitWidth: function(width, object) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["d" /* fitWidth */])(projection, width, object);
    },
    fitHeight: function(height, object) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__fit__["b" /* fitHeight */])(projection, height, object);
    }
  };
});


/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = naturalEarth1Raw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math__ = __webpack_require__(1);



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (Object(__WEBPACK_IMPORTED_MODULE_1__math__["a" /* abs */])(delta) > __WEBPACK_IMPORTED_MODULE_1__math__["i" /* epsilon */] && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */])(naturalEarth1Raw)
      .scale(175.295);
});


/***/ }),
/* 414 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = orthographicRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__azimuthal__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




function orthographicRaw(x, y) {
  return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y) * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x), Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y)];
}

orthographicRaw.invert = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["a" /* azimuthalInvert */])(__WEBPACK_IMPORTED_MODULE_0__math__["c" /* asin */]);

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + __WEBPACK_IMPORTED_MODULE_0__math__["i" /* epsilon */]);
});


/***/ }),
/* 415 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = stereographicRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__azimuthal__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(18);




function stereographicRaw(x, y) {
  var cy = Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(y), k = 1 + Object(__WEBPACK_IMPORTED_MODULE_0__math__["g" /* cos */])(x) * cy;
  return [cy * Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(x) / k, Object(__WEBPACK_IMPORTED_MODULE_0__math__["t" /* sin */])(y) / k];
}

stereographicRaw.invert = Object(__WEBPACK_IMPORTED_MODULE_1__azimuthal__["a" /* azimuthalInvert */])(function(z) {
  return 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["d" /* atan */])(z);
});

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_2__index__["a" /* default */])(stereographicRaw)
      .scale(250)
      .clipAngle(142);
});


/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = transverseMercatorRaw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mercator__ = __webpack_require__(113);



function transverseMercatorRaw(lambda, phi) {
  return [Object(__WEBPACK_IMPORTED_MODULE_0__math__["n" /* log */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["v" /* tan */])((__WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */] + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * Object(__WEBPACK_IMPORTED_MODULE_0__math__["d" /* atan */])(Object(__WEBPACK_IMPORTED_MODULE_0__math__["k" /* exp */])(x)) - __WEBPACK_IMPORTED_MODULE_0__math__["l" /* halfPi */]];
};

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var m = Object(__WEBPACK_IMPORTED_MODULE_1__mercator__["b" /* mercatorProjection */])(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
});


/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_cluster__ = __webpack_require__(418);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_cluster__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_hierarchy_index__ = __webpack_require__(114);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_hierarchy_index__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_pack_index__ = __webpack_require__(430);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__src_pack_index__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_pack_siblings__ = __webpack_require__(187);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_3__src_pack_siblings__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_pack_enclose__ = __webpack_require__(188);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_4__src_pack_enclose__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_partition__ = __webpack_require__(432);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_5__src_partition__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_stratify__ = __webpack_require__(433);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_6__src_stratify__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_tree__ = __webpack_require__(434);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_7__src_tree__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_treemap_index__ = __webpack_require__(435);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_8__src_treemap_index__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_treemap_binary__ = __webpack_require__(436);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_9__src_treemap_binary__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_treemap_dice__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_10__src_treemap_dice__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_treemap_slice__ = __webpack_require__(72);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_11__src_treemap_slice__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_treemap_sliceDice__ = __webpack_require__(437);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_12__src_treemap_sliceDice__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_treemap_squarify__ = __webpack_require__(116);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_13__src_treemap_squarify__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_treemap_resquarify__ = __webpack_require__(438);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_14__src_treemap_resquarify__["a"]; });

















/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
});


/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  return this.eachAfter(count);
});


/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
});


/***/ }),
/* 421 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
});


/***/ }),
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
});


/***/ }),
/* 423 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
});


/***/ }),
/* 424 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
});


/***/ }),
/* 425 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
});

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}


/***/ }),
/* 426 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
});


/***/ }),
/* 427 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
});


/***/ }),
/* 428 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
});


/***/ }),
/* 429 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
});


/***/ }),
/* 430 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__siblings__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__accessors__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(189);




function defaultRadius(d) {
  return Math.sqrt(d.value);
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = __WEBPACK_IMPORTED_MODULE_2__constant__["a" /* constantZero */];

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* constantZero */], 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = Object(__WEBPACK_IMPORTED_MODULE_1__accessors__["a" /* optional */])(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["b" /* default */])(+x), pack) : padding;
  };

  return pack;
});

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = Object(__WEBPACK_IMPORTED_MODULE_0__siblings__["b" /* packEnclose */])(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}


/***/ }),
/* 431 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return slice; });
/* harmony export (immutable) */ __webpack_exports__["a"] = shuffle;
var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}


/***/ }),
/* 432 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__treemap_round__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__treemap_dice__ = __webpack_require__(47);



/* harmony default export */ __webpack_exports__["a"] = (function() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(__WEBPACK_IMPORTED_MODULE_0__treemap_round__["a" /* default */]);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        Object(__WEBPACK_IMPORTED_MODULE_1__treemap_dice__["a" /* default */])(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
});


/***/ }),
/* 433 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__accessors__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hierarchy_index__ = __webpack_require__(114);



var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new __WEBPACK_IMPORTED_MODULE_1__hierarchy_index__["a" /* Node */](d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(__WEBPACK_IMPORTED_MODULE_1__hierarchy_index__["b" /* computeHeight */]);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = Object(__WEBPACK_IMPORTED_MODULE_0__accessors__["b" /* required */])(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = Object(__WEBPACK_IMPORTED_MODULE_0__accessors__["b" /* required */])(x), stratify) : parentId;
  };

  return stratify;
});


/***/ }),
/* 434 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hierarchy_index__ = __webpack_require__(114);


function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__hierarchy_index__["a" /* Node */].prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ __webpack_exports__["a"] = (function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
});


/***/ }),
/* 435 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__round__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__squarify__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__accessors__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constant__ = __webpack_require__(189);





/* harmony default export */ __webpack_exports__["a"] = (function() {
  var tile = __WEBPACK_IMPORTED_MODULE_1__squarify__["a" /* default */],
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = __WEBPACK_IMPORTED_MODULE_3__constant__["a" /* constantZero */],
      paddingTop = __WEBPACK_IMPORTED_MODULE_3__constant__["a" /* constantZero */],
      paddingRight = __WEBPACK_IMPORTED_MODULE_3__constant__["a" /* constantZero */],
      paddingBottom = __WEBPACK_IMPORTED_MODULE_3__constant__["a" /* constantZero */],
      paddingLeft = __WEBPACK_IMPORTED_MODULE_3__constant__["a" /* constantZero */];

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(__WEBPACK_IMPORTED_MODULE_0__round__["a" /* default */]);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = Object(__WEBPACK_IMPORTED_MODULE_2__accessors__["b" /* required */])(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["b" /* default */])(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["b" /* default */])(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["b" /* default */])(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["b" /* default */])(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : Object(__WEBPACK_IMPORTED_MODULE_3__constant__["b" /* default */])(+x), treemap) : paddingLeft;
  };

  return treemap;
});


/***/ }),
/* 436 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
});


/***/ }),
/* 437 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dice__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slice__ = __webpack_require__(72);



/* harmony default export */ __webpack_exports__["a"] = (function(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? __WEBPACK_IMPORTED_MODULE_1__slice__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_0__dice__["a" /* default */])(parent, x0, y0, x1, y1);
});


/***/ }),
/* 438 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dice__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slice__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__squarify__ = __webpack_require__(116);




/* harmony default export */ __webpack_exports__["a"] = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) Object(__WEBPACK_IMPORTED_MODULE_0__dice__["a" /* default */])(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else Object(__WEBPACK_IMPORTED_MODULE_1__slice__["a" /* default */])(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = Object(__WEBPACK_IMPORTED_MODULE_2__squarify__["c" /* squarifyRatio */])(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(__WEBPACK_IMPORTED_MODULE_2__squarify__["b" /* phi */]));


/***/ }),
/* 439 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_area__ = __webpack_require__(440);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_area__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_centroid__ = __webpack_require__(441);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_centroid__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_hull__ = __webpack_require__(442);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__src_hull__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_contains__ = __webpack_require__(444);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_3__src_contains__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_length__ = __webpack_require__(445);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_4__src_length__["a"]; });







/***/ }),
/* 440 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
});


/***/ }),
/* 441 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
});


/***/ }),
/* 442 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cross__ = __webpack_require__(443);


function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && Object(__WEBPACK_IMPORTED_MODULE_0__cross__["a" /* default */])(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

/* harmony default export */ __webpack_exports__["a"] = (function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
});


/***/ }),
/* 443 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
/* harmony default export */ __webpack_exports__["a"] = (function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
});


/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
});


/***/ }),
/* 445 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
});


/***/ }),
/* 446 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_queue__ = __webpack_require__(447);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_queue__["a"]; });



/***/ }),
/* 447 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = queue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(448);


var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try { start(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}


/***/ }),
/* 448 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return slice; });
var slice = [].slice;


/***/ }),
/* 449 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_uniform__ = __webpack_require__(450);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_0__src_uniform__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_normal__ = __webpack_require__(191);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__src_normal__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_logNormal__ = __webpack_require__(451);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__src_logNormal__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_bates__ = __webpack_require__(452);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__src_bates__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_irwinHall__ = __webpack_require__(192);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_4__src_irwinHall__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_exponential__ = __webpack_require__(453);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exponential__["a"]; });








/***/ }),
/* 450 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);


/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 451 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__normal__ = __webpack_require__(191);



/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = __WEBPACK_IMPORTED_MODULE_1__normal__["a" /* default */].source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 452 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__irwinHall__ = __webpack_require__(192);



/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = __WEBPACK_IMPORTED_MODULE_1__irwinHall__["a" /* default */].source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 453 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultSource__ = __webpack_require__(39);


/* harmony default export */ __webpack_exports__["a"] = ((function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(__WEBPACK_IMPORTED_MODULE_0__defaultSource__["a" /* default */]));


/***/ }),
/* 454 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_request__ = __webpack_require__(117);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__src_request__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_html__ = __webpack_require__(455);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_html__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_json__ = __webpack_require__(456);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__src_json__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_text__ = __webpack_require__(457);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_3__src_text__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_xml__ = __webpack_require__(458);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_4__src_xml__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_csv__ = __webpack_require__(459);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_5__src_csv__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_tsv__ = __webpack_require__(460);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_6__src_tsv__["a"]; });









/***/ }),
/* 455 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(73);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
}));


/***/ }),
/* 456 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(73);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
}));


/***/ }),
/* 457 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(73);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("text/plain", function(xhr) {
  return xhr.responseText;
}));


/***/ }),
/* 458 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(73);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__type__["a" /* default */])("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
}));


/***/ }),
/* 459 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dsv__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dsv__ = __webpack_require__(193);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1__dsv__["a" /* default */])("text/csv", __WEBPACK_IMPORTED_MODULE_0_d3_dsv__["c" /* csvParse */]));


/***/ }),
/* 460 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dsv__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dsv__ = __webpack_require__(193);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1__dsv__["a" /* default */])("text/tab-separated-values", __WEBPACK_IMPORTED_MODULE_0_d3_dsv__["h" /* tsvParse */]));


/***/ }),
/* 461 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_band__ = __webpack_require__(462);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_0__src_band__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_0__src_band__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_identity__ = __webpack_require__(463);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_1__src_identity__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_linear__ = __webpack_require__(48);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_2__src_linear__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_log__ = __webpack_require__(465);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_3__src_log__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_ordinal__ = __webpack_require__(194);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_4__src_ordinal__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_4__src_ordinal__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_pow__ = __webpack_require__(466);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_5__src_pow__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_5__src_pow__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_quantile__ = __webpack_require__(467);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_6__src_quantile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_quantize__ = __webpack_require__(468);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_7__src_quantize__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_threshold__ = __webpack_require__(469);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_8__src_threshold__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_time__ = __webpack_require__(197);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_9__src_time__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_utcTime__ = __webpack_require__(485);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcTime__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_category10__ = __webpack_require__(486);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_11__src_category10__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_category20b__ = __webpack_require__(487);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_12__src_category20b__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_category20c__ = __webpack_require__(488);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_13__src_category20c__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_category20__ = __webpack_require__(489);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_14__src_category20__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(490);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_rainbow__ = __webpack_require__(491);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_16__src_rainbow__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_viridis__ = __webpack_require__(492);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_17__src_viridis__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_sequential__ = __webpack_require__(493);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_18__src_sequential__["a"]; });







































/***/ }),
/* 462 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = band;
/* harmony export (immutable) */ __webpack_exports__["b"] = point;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ordinal__ = __webpack_require__(194);



function band() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_1__ordinal__["a" /* default */])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["s" /* range */])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}


/***/ }),
/* 463 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = identity;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linear__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(195);




function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_0__array__["a" /* map */].call(_, __WEBPACK_IMPORTED_MODULE_2__number__["a" /* default */]), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_1__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 464 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_format__ = __webpack_require__(107);



/* harmony default export */ __webpack_exports__["a"] = (function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["A" /* tickStep */])(start, stop, count == null ? 10 : count),
      precision;
  specifier = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["e" /* formatSpecifier */])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["g" /* precisionPrefix */])(step, value))) specifier.precision = precision;
      return Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["d" /* formatPrefix */])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["h" /* precisionRound */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["f" /* precisionFixed */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["a" /* format */])(specifier);
});


/***/ }),
/* 465 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = log;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_format__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__nice__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__continuous__ = __webpack_require__(74);






function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = Object(__WEBPACK_IMPORTED_MODULE_4__continuous__["b" /* default */])(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["B" /* ticks */])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(__WEBPACK_IMPORTED_MODULE_1_d3_format__["a" /* format */])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(Object(__WEBPACK_IMPORTED_MODULE_3__nice__["a" /* default */])(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_4__continuous__["a" /* copy */])(scale, log().base(base));
  };

  return scale;
}


/***/ }),
/* 466 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = pow;
/* harmony export (immutable) */ __webpack_exports__["b"] = sqrt;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linear__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__continuous__ = __webpack_require__(74);




function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["b" /* default */])(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__continuous__["a" /* copy */])(scale, pow().exponent(exponent));
  };

  return Object(__WEBPACK_IMPORTED_MODULE_1__linear__["b" /* linearish */])(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}


/***/ }),
/* 467 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quantile;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(33);



function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["r" /* quantile */])(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["b" /* bisect */])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(__WEBPACK_IMPORTED_MODULE_0_d3_array__["a" /* ascending */]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),
/* 468 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = quantize;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__linear__ = __webpack_require__(48);




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["b" /* bisect */])(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_2__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 469 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = threshold;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_array__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(33);



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[Object(__WEBPACK_IMPORTED_MODULE_0_d3_array__["b" /* bisect */])(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* slice */].call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),
/* 470 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return milliseconds; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);


var millisecond = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["a"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),
/* 471 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return seconds; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var second = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationSecond */];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["a"] = (second);
var seconds = second.range;


/***/ }),
/* 472 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return minutes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var minute = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (minute);
var minutes = minute.range;


/***/ }),
/* 473 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hours; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var hour = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  var offset = date.getTimezoneOffset() * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */] % __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
  if (offset < 0) offset += __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
  date.setTime(Math.floor((+date - offset) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */] + offset);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["a"] = (hour);
var hours = hour.range;


/***/ }),
/* 474 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return days; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var day = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationDay */];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["b"] = (day);
var days = day.range;


/***/ }),
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return monday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return tuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return wednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return thursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return friday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return saturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return sundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return mondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return tuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return wednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return thursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return saturdays; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



function weekday(i) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationWeek */];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),
/* 476 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return months; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);


var month = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (month);
var months = month.range;


/***/ }),
/* 477 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return years; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);


var year = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (year);
var years = year.range;


/***/ }),
/* 478 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcMinutes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var utcMinute = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationMinute */];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),
/* 479 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcHours; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var utcHour = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationHour */];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["a"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),
/* 480 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcDays; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



var utcDay = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationDay */];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),
/* 481 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return utcMonday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return utcTuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return utcWednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return utcThursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utcFriday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return utcSaturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return utcSundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return utcMondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return utcTuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return utcWednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return utcThursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcFridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return utcSaturdays; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(19);



function utcWeekday(i) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationWeek */];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),
/* 482 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcMonths; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);


var utcMonth = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),
/* 483 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcYears; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(7);


var utcYear = Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),
/* 484 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isoFormat__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__defaultLocale__ = __webpack_require__(120);



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : Object(__WEBPACK_IMPORTED_MODULE_1__defaultLocale__["e" /* utcParse */])(__WEBPACK_IMPORTED_MODULE_0__isoFormat__["b" /* isoSpecifier */]);

/* harmony default export */ __webpack_exports__["a"] = (parseIso);


/***/ }),
/* 485 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__time__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_time_format__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_time__ = __webpack_require__(75);




/* harmony default export */ __webpack_exports__["a"] = (function() {
  return Object(__WEBPACK_IMPORTED_MODULE_0__time__["a" /* calendar */])(__WEBPACK_IMPORTED_MODULE_2_d3_time__["_7" /* utcYear */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["R" /* utcMonth */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["_5" /* utcWeek */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["F" /* utcDay */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["J" /* utcHour */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["N" /* utcMinute */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["V" /* utcSecond */], __WEBPACK_IMPORTED_MODULE_2_d3_time__["L" /* utcMillisecond */], __WEBPACK_IMPORTED_MODULE_1_d3_time_format__["g" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});


/***/ }),
/* 486 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(49);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),
/* 487 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(49);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));


/***/ }),
/* 488 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(49);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));


/***/ }),
/* 489 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(49);


/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));


/***/ }),
/* 490 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);



/* harmony default export */ __webpack_exports__["a"] = (Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["f" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(300, 0.5, 0.0), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(-240, 0.5, 1.0)));


/***/ }),
/* 491 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cool; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(13);



var warm = Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["f" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(-100, 0.75, 0.35), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(80, 1.50, 0.8));

var cool = Object(__WEBPACK_IMPORTED_MODULE_1_d3_interpolate__["f" /* interpolateCubehelixLong */])(Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(260, 0.75, 0.35), Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])(80, 1.50, 0.8));

var rainbow = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__["b" /* cubehelix */])();

/* harmony default export */ __webpack_exports__["b"] = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
});


/***/ }),
/* 492 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return plasma; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__(49);


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(Object(__WEBPACK_IMPORTED_MODULE_0__colors__["a" /* default */])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));


/***/ }),
/* 493 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sequential;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__linear__ = __webpack_require__(48);


function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return Object(__WEBPACK_IMPORTED_MODULE_0__linear__["b" /* linearish */])(scale);
}


/***/ }),
/* 494 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_arc__ = __webpack_require__(495);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_arc__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_area__ = __webpack_require__(200);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_area__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_line__ = __webpack_require__(121);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_2__src_line__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_pie__ = __webpack_require__(496);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_3__src_pie__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_areaRadial__ = __webpack_require__(499);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_4__src_areaRadial__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_4__src_areaRadial__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_lineRadial__ = __webpack_require__(202);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_5__src_lineRadial__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_5__src_lineRadial__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_pointRadial__ = __webpack_require__(203);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_6__src_pointRadial__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_link_index__ = __webpack_require__(500);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_7__src_link_index__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_7__src_link_index__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_7__src_link_index__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_symbol__ = __webpack_require__(501);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return __WEBPACK_IMPORTED_MODULE_8__src_symbol__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return __WEBPACK_IMPORTED_MODULE_8__src_symbol__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_symbol_circle__ = __webpack_require__(205);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return __WEBPACK_IMPORTED_MODULE_9__src_symbol_circle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_symbol_cross__ = __webpack_require__(206);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return __WEBPACK_IMPORTED_MODULE_10__src_symbol_cross__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_symbol_diamond__ = __webpack_require__(207);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return __WEBPACK_IMPORTED_MODULE_11__src_symbol_diamond__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_symbol_square__ = __webpack_require__(209);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return __WEBPACK_IMPORTED_MODULE_12__src_symbol_square__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_symbol_star__ = __webpack_require__(208);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return __WEBPACK_IMPORTED_MODULE_13__src_symbol_star__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_symbol_triangle__ = __webpack_require__(210);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return __WEBPACK_IMPORTED_MODULE_14__src_symbol_triangle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_symbol_wye__ = __webpack_require__(211);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return __WEBPACK_IMPORTED_MODULE_15__src_symbol_wye__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_curve_basisClosed__ = __webpack_require__(502);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_16__src_curve_basisClosed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_curve_basisOpen__ = __webpack_require__(503);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_17__src_curve_basisOpen__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_curve_basis__ = __webpack_require__(78);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_18__src_curve_basis__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__src_curve_bundle__ = __webpack_require__(504);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_19__src_curve_bundle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__src_curve_cardinalClosed__ = __webpack_require__(212);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_20__src_curve_cardinalClosed__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__src_curve_cardinalOpen__ = __webpack_require__(213);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_21__src_curve_cardinalOpen__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__src_curve_cardinal__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_22__src_curve_cardinal__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__src_curve_catmullRomClosed__ = __webpack_require__(505);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_23__src_curve_catmullRomClosed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__src_curve_catmullRomOpen__ = __webpack_require__(506);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_24__src_curve_catmullRomOpen__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__src_curve_catmullRom__ = __webpack_require__(123);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_25__src_curve_catmullRom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__src_curve_linearClosed__ = __webpack_require__(507);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_26__src_curve_linearClosed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__src_curve_linear__ = __webpack_require__(76);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_27__src_curve_linear__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__src_curve_monotone__ = __webpack_require__(508);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_28__src_curve_monotone__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_28__src_curve_monotone__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__src_curve_natural__ = __webpack_require__(509);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_29__src_curve_natural__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__src_curve_step__ = __webpack_require__(510);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_30__src_curve_step__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_30__src_curve_step__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_30__src_curve_step__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__src_stack__ = __webpack_require__(511);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_31__src_stack__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__src_offset_expand__ = __webpack_require__(512);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_32__src_offset_expand__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__src_offset_diverging__ = __webpack_require__(513);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_33__src_offset_diverging__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__src_offset_none__ = __webpack_require__(51);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_34__src_offset_none__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__src_offset_silhouette__ = __webpack_require__(514);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_35__src_offset_silhouette__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__src_offset_wiggle__ = __webpack_require__(515);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_36__src_offset_wiggle__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__src_order_ascending__ = __webpack_require__(124);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_37__src_order_ascending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__src_order_descending__ = __webpack_require__(516);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_38__src_order_descending__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__src_order_insideOut__ = __webpack_require__(517);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return __WEBPACK_IMPORTED_MODULE_39__src_order_insideOut__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__src_order_none__ = __webpack_require__(52);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return __WEBPACK_IMPORTED_MODULE_40__src_order_none__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__src_order_reverse__ = __webpack_require__(518);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return __WEBPACK_IMPORTED_MODULE_41__src_order_reverse__["a"]; });




 // Note: radialArea is deprecated!
 // Note: radialLine is deprecated!









































/***/ }),
/* 495 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_path__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(50);




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(Object(__WEBPACK_IMPORTED_MODULE_2__math__["h" /* max */])(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - __WEBPACK_IMPORTED_MODULE_2__math__["g" /* halfPi */],
        a1 = endAngle.apply(this, arguments) - __WEBPACK_IMPORTED_MODULE_2__math__["g" /* halfPi */],
        da = Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* abs */])(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = Object(__WEBPACK_IMPORTED_MODULE_0_d3_path__["a" /* path */])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */])) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > __WEBPACK_IMPORTED_MODULE_2__math__["m" /* tau */] - __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
      context.moveTo(r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a0), r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
        context.moveTo(r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a1), r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) && (padRadius ? +padRadius.apply(this, arguments) : Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(r0 * r0 + r1 * r1)),
          rc = Object(__WEBPACK_IMPORTED_MODULE_2__math__["i" /* min */])(Object(__WEBPACK_IMPORTED_MODULE_2__math__["a" /* abs */])(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
        var p0 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["c" /* asin */])(rp / r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(ap)),
            p1 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["c" /* asin */])(rp / r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(ap));
        if ((da0 -= p0 * 2) > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a01),
          y01 = r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a01),
          x10 = r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a10),
          y10 = r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a10);

      // Apply rounded corners?
      if (rc > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
        var x11 = r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a11),
            y11 = r1 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a11),
            x00 = r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a00),
            y00 = r0 * Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < __WEBPACK_IMPORTED_MODULE_2__math__["j" /* pi */]) {
          var oc = da0 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */] ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(Object(__WEBPACK_IMPORTED_MODULE_2__math__["b" /* acos */])((ax * bx + ay * by) / (Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(ax * ax + ay * ay) * Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(bx * bx + by * by))) / 2),
              lc = Object(__WEBPACK_IMPORTED_MODULE_2__math__["l" /* sqrt */])(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["i" /* min */])(rc, (r0 - lc) / (kc - 1));
          rc1 = Object(__WEBPACK_IMPORTED_MODULE_2__math__["i" /* min */])(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */])) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y01, t0.x01), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y01, t0.x01), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.cy + t0.y11, t0.cx + t0.x11), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y11, t1.x11), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) || !(da0 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */])) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > __WEBPACK_IMPORTED_MODULE_2__math__["f" /* epsilon */]) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y01, t0.x01), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y01, t0.x01), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t0.cy + t0.y11, t0.cx + t0.x11), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y11, t1.x11), Object(__WEBPACK_IMPORTED_MODULE_2__math__["d" /* atan2 */])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - __WEBPACK_IMPORTED_MODULE_2__math__["j" /* pi */] / 2;
    return [Object(__WEBPACK_IMPORTED_MODULE_2__math__["e" /* cos */])(a) * r, Object(__WEBPACK_IMPORTED_MODULE_2__math__["k" /* sin */])(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});


/***/ }),
/* 496 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__descending__ = __webpack_require__(497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__identity__ = __webpack_require__(498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math__ = __webpack_require__(50);





/* harmony default export */ __webpack_exports__["a"] = (function() {
  var value = __WEBPACK_IMPORTED_MODULE_2__identity__["a" /* default */],
      sortValues = __WEBPACK_IMPORTED_MODULE_1__descending__["a" /* default */],
      sort = null,
      startAngle = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(0),
      endAngle = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_3__math__["m" /* tau */]),
      padAngle = Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(__WEBPACK_IMPORTED_MODULE_3__math__["m" /* tau */], Math.max(-__WEBPACK_IMPORTED_MODULE_3__math__["m" /* tau */], endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), pie) : padAngle;
  };

  return pie;
});


/***/ }),
/* 497 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),
/* 498 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(d) {
  return d;
});


/***/ }),
/* 499 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__curve_radial__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__area__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lineRadial__ = __webpack_require__(202);




/* harmony default export */ __webpack_exports__["a"] = (function() {
  var a = Object(__WEBPACK_IMPORTED_MODULE_1__area__["a" /* default */])().curve(__WEBPACK_IMPORTED_MODULE_0__curve_radial__["a" /* curveRadialLinear */]),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return Object(__WEBPACK_IMPORTED_MODULE_2__lineRadial__["b" /* lineRadial */])(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return Object(__WEBPACK_IMPORTED_MODULE_2__lineRadial__["b" /* lineRadial */])(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return Object(__WEBPACK_IMPORTED_MODULE_2__lineRadial__["b" /* lineRadial */])(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return Object(__WEBPACK_IMPORTED_MODULE_2__lineRadial__["b" /* lineRadial */])(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(Object(__WEBPACK_IMPORTED_MODULE_0__curve_radial__["b" /* default */])(_)) : c()._curve;
  };

  return a;
});


/***/ }),
/* 500 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = linkHorizontal;
/* harmony export (immutable) */ __webpack_exports__["c"] = linkVertical;
/* harmony export (immutable) */ __webpack_exports__["b"] = linkRadial;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_path__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__point__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pointRadial__ = __webpack_require__(203);






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = __WEBPACK_IMPORTED_MODULE_3__point__["a" /* x */],
      y = __WEBPACK_IMPORTED_MODULE_3__point__["b" /* y */],
      context = null;

  function link() {
    var buffer, argv = __WEBPACK_IMPORTED_MODULE_1__array__["a" /* slice */].call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = Object(__WEBPACK_IMPORTED_MODULE_0_d3_path__["a" /* path */])();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_2__constant__["a" /* default */])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = Object(__WEBPACK_IMPORTED_MODULE_4__pointRadial__["a" /* default */])(x0, y0),
      p1 = Object(__WEBPACK_IMPORTED_MODULE_4__pointRadial__["a" /* default */])(x0, y0 = (y0 + y1) / 2),
      p2 = Object(__WEBPACK_IMPORTED_MODULE_4__pointRadial__["a" /* default */])(x1, y0),
      p3 = Object(__WEBPACK_IMPORTED_MODULE_4__pointRadial__["a" /* default */])(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),
/* 501 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return symbols; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_path__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__symbol_circle__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__symbol_cross__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__symbol_diamond__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__symbol_star__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__symbol_square__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__symbol_triangle__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__symbol_wye__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__constant__ = __webpack_require__(34);










var symbols = [
  __WEBPACK_IMPORTED_MODULE_1__symbol_circle__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_2__symbol_cross__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_3__symbol_diamond__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_5__symbol_square__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_4__symbol_star__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_6__symbol_triangle__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_7__symbol_wye__["a" /* default */]
];

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var type = Object(__WEBPACK_IMPORTED_MODULE_8__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__symbol_circle__["a" /* default */]),
      size = Object(__WEBPACK_IMPORTED_MODULE_8__constant__["a" /* default */])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = Object(__WEBPACK_IMPORTED_MODULE_0_d3_path__["a" /* path */])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_8__constant__["a" /* default */])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_8__constant__["a" /* default */])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
});


/***/ }),
/* 502 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noop__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(78);



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  areaEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: Object(__WEBPACK_IMPORTED_MODULE_1__basis__["c" /* point */])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new BasisClosed(context);
});


/***/ }),
/* 503 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(78);


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: Object(__WEBPACK_IMPORTED_MODULE_0__basis__["c" /* point */])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new BasisOpen(context);
});


/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(78);


function Bundle(context, beta) {
  this._basis = new __WEBPACK_IMPORTED_MODULE_0__basis__["a" /* Basis */](context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ __webpack_exports__["a"] = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new __WEBPACK_IMPORTED_MODULE_0__basis__["a" /* Basis */](context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),
/* 505 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cardinalClosed__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__catmullRom__ = __webpack_require__(123);




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: __WEBPACK_IMPORTED_MODULE_1__noop__["a" /* default */],
  areaEnd: __WEBPACK_IMPORTED_MODULE_1__noop__["a" /* default */],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(__WEBPACK_IMPORTED_MODULE_2__catmullRom__["b" /* point */])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new __WEBPACK_IMPORTED_MODULE_0__cardinalClosed__["a" /* CardinalClosed */](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),
/* 506 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cardinalOpen__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__catmullRom__ = __webpack_require__(123);



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(__WEBPACK_IMPORTED_MODULE_1__catmullRom__["b" /* point */])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new __WEBPACK_IMPORTED_MODULE_0__cardinalOpen__["a" /* CardinalOpen */](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),
/* 507 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__noop__ = __webpack_require__(77);


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  areaEnd: __WEBPACK_IMPORTED_MODULE_0__noop__["a" /* default */],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new LinearClosed(context);
});


/***/ }),
/* 508 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = monotoneX;
/* harmony export (immutable) */ __webpack_exports__["b"] = monotoneY;
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new Natural(context);
});


/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = stepBefore;
/* harmony export (immutable) */ __webpack_exports__["b"] = stepAfter;
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),
/* 511 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constant__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__offset_none__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__order_none__ = __webpack_require__(52);





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var keys = Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])([]),
      order = __WEBPACK_IMPORTED_MODULE_3__order_none__["a" /* default */],
      offset = __WEBPACK_IMPORTED_MODULE_2__offset_none__["a" /* default */],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? __WEBPACK_IMPORTED_MODULE_3__order_none__["a" /* default */] : typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_1__constant__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__array__["a" /* slice */].call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? __WEBPACK_IMPORTED_MODULE_2__offset_none__["a" /* default */] : _, stack) : offset;
  };

  return stack;
});


/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series, order);
});


/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
});


/***/ }),
/* 514 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series, order);
});


/***/ }),
/* 515 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(51);


/* harmony default export */ __webpack_exports__["a"] = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series, order);
});


/***/ }),
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ascending__ = __webpack_require__(124);


/* harmony default export */ __webpack_exports__["a"] = (function(series) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__ascending__["a" /* default */])(series).reverse();
});


/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ascending__ = __webpack_require__(124);



/* harmony default export */ __webpack_exports__["a"] = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(__WEBPACK_IMPORTED_MODULE_1__ascending__["b" /* sum */]),
      order = Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});


/***/ }),
/* 518 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__none__ = __webpack_require__(52);


/* harmony default export */ __webpack_exports__["a"] = (function(series) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__none__["a" /* default */])(series).reverse();
});


/***/ }),
/* 519 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_voronoi__ = __webpack_require__(520);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_voronoi__["a"]; });



/***/ }),
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(521);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Diagram__ = __webpack_require__(53);




/* harmony default export */ __webpack_exports__["a"] = (function() {
  var x = __WEBPACK_IMPORTED_MODULE_1__point__["a" /* x */],
      y = __WEBPACK_IMPORTED_MODULE_1__point__["b" /* y */],
      extent = null;

  function voronoi(data) {
    return new __WEBPACK_IMPORTED_MODULE_2__Diagram__["d" /* default */](data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / __WEBPACK_IMPORTED_MODULE_2__Diagram__["f" /* epsilon */]) * __WEBPACK_IMPORTED_MODULE_2__Diagram__["f" /* epsilon */], Math.round(y(d, i, data) / __WEBPACK_IMPORTED_MODULE_2__Diagram__["f" /* epsilon */]) * __WEBPACK_IMPORTED_MODULE_2__Diagram__["f" /* epsilon */]];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
});


/***/ }),
/* 521 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 522 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = x;
/* harmony export (immutable) */ __webpack_exports__["b"] = y;
function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}


/***/ }),
/* 523 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = removeBeach;
/* harmony export (immutable) */ __webpack_exports__["a"] = addBeach;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RedBlackTree__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cell__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Circle__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Edge__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Diagram__ = __webpack_require__(53);






var beachPool = [];

function Beach() {
  Object(__WEBPACK_IMPORTED_MODULE_0__RedBlackTree__["a" /* RedBlackNode */])(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(beach);
  __WEBPACK_IMPORTED_MODULE_4__Diagram__["a" /* beaches */].remove(beach);
  beachPool.push(beach);
  Object(__WEBPACK_IMPORTED_MODULE_0__RedBlackTree__["a" /* RedBlackNode */])(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]
      && Math.abs(y - lArc.circle.cy) < __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]
      && Math.abs(y - rArc.circle.cy) < __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["d" /* setEdgeEnd */])(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["c" /* createEdge */])(lArc.site, rArc.site, null, vertex);

  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(lArc);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = __WEBPACK_IMPORTED_MODULE_4__Diagram__["a" /* beaches */]._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > __WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -__WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -__WEBPACK_IMPORTED_MODULE_4__Diagram__["f" /* epsilon */]) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  Object(__WEBPACK_IMPORTED_MODULE_1__Cell__["c" /* createCell */])(site);
  var newArc = createBeach(site);
  __WEBPACK_IMPORTED_MODULE_4__Diagram__["a" /* beaches */].insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(lArc);
    rArc = createBeach(lArc.site);
    __WEBPACK_IMPORTED_MODULE_4__Diagram__["a" /* beaches */].insert(newArc, rArc);
    newArc.edge = rArc.edge = Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["c" /* createEdge */])(lArc.site, newArc.site);
    Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(lArc);
    Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["c" /* createEdge */])(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(lArc);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["b" /* detachCircle */])(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["d" /* setEdgeEnd */])(rArc.edge, lSite, rSite, vertex);
  newArc.edge = Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["c" /* createEdge */])(lSite, site, null, vertex);
  rArc.edge = Object(__WEBPACK_IMPORTED_MODULE_3__Edge__["c" /* createEdge */])(site, rSite, null, vertex);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(lArc);
  Object(__WEBPACK_IMPORTED_MODULE_2__Circle__["a" /* attachCircle */])(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}


/***/ }),
/* 524 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_zoom__ = __webpack_require__(525);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_zoom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_transform__ = __webpack_require__(216);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transform__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transform__["c"]; });




/***/ }),
/* 525 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_drag__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_selection__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_d3_transition__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constant__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__event__ = __webpack_require__(527);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__transform__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__noevent__ = __webpack_require__(528);










// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].button;
}

function defaultExtent() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || __WEBPACK_IMPORTED_MODULE_7__transform__["c" /* identity */];
}

function defaultWheelDelta() {
  return -__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].deltaY * (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = __WEBPACK_IMPORTED_MODULE_2_d3_interpolate__["v" /* interpolateZoom */],
      gestures = [],
      listeners = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__["a" /* dispatch */])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(__WEBPACK_IMPORTED_MODULE_7__transform__["c" /* identity */].translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new __WEBPACK_IMPORTED_MODULE_7__transform__["a" /* Transform */](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["d" /* customEvent */])(new __WEBPACK_IMPORTED_MODULE_6__event__["a" /* default */](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["b" /* interrupt */])(this);
      g.start();
    }

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(this),
        x0 = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].clientX,
        y0 = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].clientY;

    Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["b" /* dragDisable */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view);
    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["b" /* interrupt */])(this);
    g.start();

    function mousemoved() {
      Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
      if (!g.moved) {
        var dx = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].clientX - x0, dy = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(__WEBPACK_IMPORTED_MODULE_1_d3_drag__["c" /* dragEnable */])(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].view, g.moved);
      Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["h" /* mouse */])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (__WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    if (duration > 0) Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(this).transition().duration(duration).call(schedule, t1, p0);
    else Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].changedTouches,
        started,
        n = touches.length, i, t, p;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["q" /* touch */])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["k" /* select */])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(__WEBPACK_IMPORTED_MODULE_4_d3_transition__["b" /* interrupt */])(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].changedTouches,
        n = touches.length, i, t, p, l;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["a" /* default */])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(__WEBPACK_IMPORTED_MODULE_3_d3_selection__["q" /* touch */])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = __WEBPACK_IMPORTED_MODULE_3_d3_selection__["e" /* event */].changedTouches,
        n = touches.length, i, t;

    Object(__WEBPACK_IMPORTED_MODULE_8__noevent__["b" /* nopropagation */])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(__WEBPACK_IMPORTED_MODULE_5__constant__["a" /* default */])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});


/***/ }),
/* 526 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 527 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomEvent;
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}


/***/ }),
/* 528 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = nopropagation;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(6);


function nopropagation() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].preventDefault();
  __WEBPACK_IMPORTED_MODULE_0_d3_selection__["e" /* event */].stopImmediatePropagation();
});


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwDatePickerHelper_1 = __webpack_require__(41);
var gwJic_1 = __webpack_require__(40);
var gwPrefPanel_1 = __webpack_require__(28);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwDatePicker = /** @class */ (function (_super) {
    __extends(GwDatePicker, _super);
    function GwDatePicker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwDatePicker.prototype.getSystemName = function () {
        return "gwDatePicker";
    };
    GwDatePicker.prototype.prev = function () {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        gwDatePickerHelper_1.gwDatePickerHelper._adjustDate(inst, -(gwDatePickerHelper_1.gwDatePickerHelper._get("stepMonths")), "M");
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    GwDatePicker.prototype.next = function () {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        gwDatePickerHelper_1.gwDatePickerHelper._adjustDate(inst, +gwDatePickerHelper_1.gwDatePickerHelper._get("stepMonths"), "M");
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    GwDatePicker.prototype.hide = function () {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
        gwDatePickerHelper_1.gwDatePickerHelper._hideDatePicker();
    };
    GwDatePicker.prototype.today = function () {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        if (gwPrefPanel_1.gwPrefPanel.getPrefValueById("todayClosesDatePicker")) {
            gwDatePickerHelper_1.gwDatePickerHelper._selectToday(inst);
        }
        else {
            gwDatePickerHelper_1.gwDatePickerHelper._gotoToday(inst);
            gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
        }
    };
    GwDatePicker.prototype.current = function () {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        gwDatePickerHelper_1.gwDatePickerHelper._gotoCurrent(inst);
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    GwDatePicker.prototype.selectDay = function (el) {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        gwDatePickerHelper_1.gwDatePickerHelper._selectDay(inst, +el.getAttribute("data-month"), +el.getAttribute("data-year"), +el.getAttribute("data-day"));
    };
    GwDatePicker.prototype.selectMonth = function (el) {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        if (inst.isJIC) {
            gwJic_1.gwJic.eraMonthOrYearChangedPossiblyRestrictDates();
        }
        gwDatePickerHelper_1.gwDatePickerHelper._selectMonthYear(inst, el, "M");
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    GwDatePicker.prototype.selectYear = function (el) {
        var inst = gwDatePickerHelper_1.gwDatePickerHelper.getCurrDateInfoOrThrow();
        if (inst.isJIC) {
            gwJic_1.gwJic.eraMonthOrYearChangedPossiblyRestrictDates();
        }
        gwDatePickerHelper_1.gwDatePickerHelper._selectMonthYear(inst, el, "Y");
        gwDatePickerHelper_1.gwDatePickerHelper._putFocusBackOnInput(inst);
    };
    return GwDatePicker;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwDatePicker = GwDatePicker;
exports.gwDatePicker = new GwDatePicker();


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwInputs_1 = __webpack_require__(5);
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var GwInputGroup = /** @class */ (function (_super) {
    __extends(GwInputGroup, _super);
    function GwInputGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwInputGroup.prototype.getSystemName = function () {
        return "gwInputGroup";
    };
    GwInputGroup.prototype.toggle = function (widget, args) {
        var checkboxId = args.checkboxId;
        var expanded = gwInputs_1.gwInputs.getValueAsBoolean(widget.querySelector("input"));
        if (expanded) {
            if (widget.hasAttribute("data-gw-client-toggle")) {
                this.expandGroup(checkboxId);
            }
            else {
                gwUtil_1.gwUtil.refresh();
            }
        }
        else {
            this.collapseGroup(checkboxId);
            widget.setAttribute("data-gw-client-toggle", "true");
        }
    };
    GwInputGroup.prototype.expandGroup = function (checkboxId) {
        this.toggleGroup(checkboxId, true);
    };
    GwInputGroup.prototype.collapseGroup = function (checkboxId) {
        this.toggleGroup(checkboxId, false);
    };
    GwInputGroup.prototype.toggleGroup = function (checkboxId, expand) {
        if (expand === void 0) { expand = false; }
        var groupId = checkboxId.replace("-_checkbox", "");
        gwUtil_1.gwUtil.conditionalAddRemoveClass(!expand, "#" + groupId, ".gw-InputGroup--collapsed");
    };
    return GwInputGroup;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwInputGroup = GwInputGroup;
exports.gwInputGroup = new GwInputGroup();


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwInitializableSystem_1 = __webpack_require__(4);
var gwUtil_1 = __webpack_require__(0);
var GwLoginPage = /** @class */ (function (_super) {
    __extends(GwLoginPage, _super);
    function GwLoginPage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwLoginPage.prototype.getSystemName = function () {
        return "gwLoginPage";
    };
    GwLoginPage.prototype.addMissingAttributesToLoginPage = function (centerPanel) {
        var usernameInput = gwUtil_1.gwUtil.getDomNodeByAttr("name", "Login-LoginScreen-LoginDV-username", centerPanel);
        if (!usernameInput) {
            throw new Error("Unable to locate user name input field on login page");
        }
        gwUtil_1.gwUtil.addClass(usernameInput, "gw-noTrack");
    };
    GwLoginPage.prototype.init = function () {
        var screenNameNodes = gwUtil_1.gwUtil.getDomNodes(".gw-location-name");
        for (var i = 0; i < screenNameNodes.length; i++) {
            var screenNameNode = screenNameNodes[i];
            var nodeData = screenNameNode.dataset;
            if (nodeData && nodeData.gwLocationName && nodeData.gwLocationName === "Login") {
                this.addMissingAttributesToLoginPage(screenNameNode.parentElement);
            }
        }
    };
    return GwLoginPage;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwLoginPage = GwLoginPage;
exports.gwLoginPage = new GwLoginPage();


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwFileRequest_1 = __webpack_require__(127);
var GwNoteBody = /** @class */ (function (_super) {
    __extends(GwNoteBody, _super);
    function GwNoteBody() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwNoteBody.prototype.getSystemName = function () {
        return "gwNoteBody";
    };
    GwNoteBody.prototype.downloadDocument = function (triggerNode, args) {
        new GwFileRequest_1.GwFileRequest(false).downloadDirectly({
            widgetId: args.id,
            docId: args.docId,
            contentDisposition: "inline"
        });
    };
    return GwNoteBody;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwNoteBody = GwNoteBody;
exports.gwNoteBody = new GwNoteBody();


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var GwPaging = /** @class */ (function (_super) {
    __extends(GwPaging, _super);
    function GwPaging() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwPaging.prototype.getSystemName = function () {
        return "gwPaging";
    };
    GwPaging.prototype.page = function (pagingButtonNode, pageArgs) {
        gwUtil_1.gwUtil.setEventParam(pageArgs.id, pageArgs.page);
        gwUtil_1.gwUtil.fireEvent(pageArgs.id);
    };
    GwPaging.prototype.parent = function (pagingButtonNode, pageArgs) {
        gwUtil_1.gwUtil.setEventParam(pageArgs.id, "parent");
        gwUtil_1.gwUtil.fireEvent(pageArgs.id);
    };
    GwPaging.prototype.child = function (pagingButtonNode, pageArgs) {
        gwUtil_1.gwUtil.setEventParam(pageArgs.id, "child");
        gwUtil_1.gwUtil.fireEvent(pageArgs.id);
    };
    return GwPaging;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwPaging = GwPaging;
exports.gwPaging = new GwPaging();


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwEvents_1 = __webpack_require__(3);
var GwInitializableSystem_1 = __webpack_require__(4);
var gwUtil_1 = __webpack_require__(0);
var gwAjax_1 = __webpack_require__(15);
var GwProgressValue = /** @class */ (function (_super) {
    __extends(GwProgressValue, _super);
    function GwProgressValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.currentPollTargets = {};
        _this._interval = -1;
        /**
         * Hard coded interval at which the client checks to see if there are any targets for polling the server
         * @type {number}
         */
        _this.pollInterval = 2000;
        return _this;
    }
    GwProgressValue.prototype.getSystemName = function () {
        return "gwProgressValue";
    };
    /**
     * Searches for progress bars that need to update
     */
    GwProgressValue.prototype.init = function () {
        var _this = this;
        var progressValueWidgets = $(".gw-ProgressValueWidget").not(".gw-disabled");
        if (progressValueWidgets) {
            gwUtil_1.gwUtil.forEach(progressValueWidgets, this.checkProgress.bind(this));
            this.startInterval();
        }
        else {
            // Reset the current set of poll targets as there are no accessible progress
            // value widgets on the current page
            gwUtil_1.gwUtil.forEach(this.currentPollTargets, function (pollTarget) {
                _this.resetProgressInfo(pollTarget.id);
            });
            window.clearInterval(this._interval);
        }
    };
    /**
     * Checks to see if there are any targets for which to poll the server for progress updates.
     * Double checks the list of polling targets and resets polling information if it finds the targets
     * are no longer available on the current page.
     */
    GwProgressValue.prototype.pollProgressWidgets = function () {
        var _this = this;
        var pollTargetKeys = Object.keys(this.currentPollTargets);
        var foundTargets = false;
        gwUtil_1.gwUtil.forEach(pollTargetKeys, function (targetKey) {
            var targetElems = $("#" + targetKey + ".gw-ProgressValueWidget").not(".gw-disabled");
            if (targetElems.length > 0) {
                // Found at least one viable target
                foundTargets = true;
            }
            else {
                _this.resetProgressInfo(targetKey);
            }
        });
        if (foundTargets) {
            this.requestProgressInputUpdates({ ids: pollTargetKeys });
        }
        else {
            window.clearInterval(this._interval);
        }
    };
    GwProgressValue.prototype.requestProgressInputUpdates = function (updateTargets) {
        var requestParams = {};
        requestParams["__progressinput"] = JSON.stringify(updateTargets);
        gwAjax_1.gwAjax.ajaxRequest(requestParams, this.updateProgressInputs.bind(this));
    };
    GwProgressValue.prototype.updateProgressInputs = function (updateReqResponse) {
        // Parse ids and progress percents from response
        var progressInputUpdates = updateReqResponse.results;
        if (progressInputUpdates) {
            progressInputUpdates.forEach(this.setProgressWidgetProgress.bind(this));
        }
        else {
            gwUtil_1.gwUtil.devlog("Did not receive any results from requestProgressInputUpdates");
        }
    };
    GwProgressValue.prototype.setProgressWidgetProgress = function (update) {
        var id = update.id;
        var el = $("#" + id + ".gw-ProgressValueWidget").not(".gw-disabled")[0];
        if (!el) {
            this.resetProgressInfo(id);
            return null;
        }
        var progressPercent = update.percentDone;
        progressPercent = parseInt(progressPercent);
        progressPercent = Math.min(progressPercent, 100);
        el.setAttribute("data-gw-percent", "" + progressPercent);
        this.updateProgressBar(el, progressPercent);
        this.updateStatus(el, update.status);
        this.checkProgress(el);
        return el;
    };
    GwProgressValue.prototype.updateProgressBar = function (el, progressPercent) {
        var bar = el.querySelector(".gw-progress--bar");
        if (bar) {
            bar.style.width = progressPercent + "%";
            gwUtil_1.gwUtil.conditionalAddRemoveClass(progressPercent === 0, bar, "gw-progress--bar-empty");
            gwUtil_1.gwUtil.conditionalAddRemoveClass(progressPercent === 100, bar, "gw-progress--bar-full");
        }
        var val = el.querySelector(".gw-progress--bar-label");
        if (val) {
            val.innerHTML = progressPercent + "%";
            gwUtil_1.gwUtil.conditionalAddRemoveClass(progressPercent < 30, val, "gw-progress--shifted-label");
        }
    };
    GwProgressValue.prototype.updateStatus = function (el, status) {
        if (!gwUtil_1.gwUtil.hasValue(status)) {
            return;
        }
        var statusEl = el.querySelector(".gw-progress--status-label");
        if (statusEl) {
            statusEl.innerHTML = status;
        }
    };
    /**
     * Check in polling targets to see if a disabledEvents call has been triggered for the corresponding progress input.
     * Used to prevent calling disabledEvents multiple times for a progress input that is configured with an action on
     * completion.  Also used during cleanup of orphaned progress input polling requests.
     * @param targetKey
     * @returns {boolean}
     */
    GwProgressValue.prototype.disabledEventsTriggered = function (targetKey) {
        var info = this.currentPollTargets[targetKey] || {};
        return !!info.disabledEvents;
    };
    /**
     * Clean up progress input state for a given progress input target.
     * @param targetKey
     */
    GwProgressValue.prototype.resetProgressInfo = function (targetKey) {
        // eventDisabled was called for target but the target is no longer on the page.
        // Need to send an enable event otherwise the lock counter will never get decremented.
        if (this.disabledEventsTriggered(targetKey)) {
            gwEvents_1.gwEvents.enableEvents();
        }
        // Remove any poll targets not on the current screen - e.g. the user has navigated away
        delete this.currentPollTargets[targetKey];
    };
    GwProgressValue.prototype.parseInfo = function (progressValueWidget) {
        var info = {};
        info.id = progressValueWidget.id;
        info.percent = $(progressValueWidget).attr("data-gw-percent");
        info.action = $(progressValueWidget).attr("data-gw-action");
        return info;
    };
    /**
     * Checks the status for a given progress input on the current page.  If the progress input is configured
     * with an action on completion, triggers the event when the progress input is complete.
     * @param pvw ProgressInput element.
     */
    GwProgressValue.prototype.checkProgress = function (pvw) {
        var info = this.parseInfo(pvw);
        var done = info.percent >= 100;
        if (done) {
            if (info.action) {
                // If action configured for the targeted progress input, fire the action now that progress is done.
                gwUtil_1.gwUtil.fireEvent(info.action);
                if (this.disabledEventsTriggered(info.id)) {
                    // Send an enableEvents call if disabledEvents had been triggered
                    // (probably only happens if the progress bar comes in completed...)
                    gwEvents_1.gwEvents.enableEvents();
                }
            }
            else {
                if (this.currentPollTargets[info.id]) {
                    gwUtil_1.gwUtil.refresh();
                }
            }
            delete this.currentPollTargets[info.id];
        }
        else {
            this.currentPollTargets[info.id] = this.currentPollTargets[info.id] || info;
            if (info.action) {
                // Progress inputs with actions disable events until progress is done.
                // If we haven't already, disableEvents.
                if (!this.disabledEventsTriggered(pvw.id)) {
                    this.currentPollTargets[pvw.id].disabledEvents = true;
                    gwEvents_1.gwEvents.disableEvents();
                }
            }
        }
    };
    GwProgressValue.prototype.startInterval = function () {
        window.clearInterval(this._interval);
        this._interval = window.setInterval(this.pollProgressWidgets.bind(this), this.pollInterval);
    };
    return GwProgressValue;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwProgressValue = GwProgressValue;
exports.gwProgressValue = new GwProgressValue();


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwEvents_1 = __webpack_require__(3);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwTreeView = /** @class */ (function (_super) {
    __extends(GwTreeView, _super);
    function GwTreeView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwTreeView.prototype.getSystemName = function () {
        return "gwTreeView";
    };
    /**
     * Handles commands for TreeViews - Expanding, Collapsing, Selecting
     */
    GwTreeView.prototype.treeViewAction = function (treeViewNode, args) {
        var treeViewInput = $("#gw-util--treeview");
        treeViewInput.attr("name", args.id);
        treeViewInput.val(args.act + ";" + args.nodeId);
        gwEvents_1.gwEvents.methods.fireEvent(treeViewNode, args, undefined, function () {
            // Reset treeview form field
            treeViewInput.attr("name", "gw-util--treeview");
            treeViewInput.val("");
        });
    };
    return GwTreeView;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwTreeView = GwTreeView;
exports.gwTreeView = new GwTreeView();


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwFocus_1 = __webpack_require__(8);
var GwPrivacy = /** @class */ (function (_super) {
    __extends(GwPrivacy, _super);
    function GwPrivacy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hiddenClass = "gw-hidden";
        return _this;
    }
    GwPrivacy.prototype.getSystemName = function () {
        return "gwPrivacy";
    };
    GwPrivacy.prototype.clearEncrypted = function (triggerNode, args) {
        var widgetNode = gwUtil_1.gwUtil.getDomNode("#" + args.id);
        if (!widgetNode) {
            return;
        }
        var widgetElement = $(widgetNode);
        var menuElement = widgetElement.find(".gw-PrivacyValueWidget--dropMenu");
        menuElement.addClass(this.hiddenClass);
        var inputElement = widgetElement.find(".gw-PrivacyValueWidget--valueField");
        inputElement.removeAttr("disabled");
        inputElement.val("");
        gwFocus_1.gwFocus.forceFocus(inputElement[0], false);
    };
    return GwPrivacy;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwPrivacy = GwPrivacy;
exports.gwPrivacy = new GwPrivacy();


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwUtil_1 = __webpack_require__(0);
var gwEvents_1 = __webpack_require__(3);
var gwConfirm_1 = __webpack_require__(133);
/**
 * Radio button groups are usually created by RadioButtonCells. RadioButtonCell is a special control that is used
 * to put a group of radio buttons in different cells of a list view - they can be placed on different rows or even
 * in different columns. The cells are grouped by the radioButtonGroup attribute - a unique name used for all the
 * radio buttons in the group, so that selecting one of the buttons automatically deselects all the others.
 *
 * Unfortunately the straightforward implementation - using an actual input of type="radio" for the radio buttons -
 * breaks keyboard navigation, because when you navigate to a set of radio buttons the browser will force focus to
 * the currently selected button. This feels really weird when the buttons are scattered across an entire LV. So we
 * actually represent a "radio button group" as a group of check box inputs, all with the same name. This gives us
 * predictable keyboard navigation but means we have to do extra event processing to get radio like behavior - for
 * example we have to clear all the other "radio buttons" when a particular member of the group is selected. We also
 * use styling magic to make the actual check boxes invisible, then add divs that are styled to look like radio
 * buttons so the UI looks right.
 *
 * Radio button groups are used in one other place other than RadioButtonCell - the radio buttons on Choice widgets.
 * These are used to select a particular set of inputs - each choice has a radio button and a set of inputs, clicking
 * on the radio button makes the set of inputs active. These choice radio buttons use the same grouping mechanism, and
 * are always post on change so they make a server round trip every time one of the radio buttons is selected.
 */
var GwRadioButtonGroup = /** @class */ (function (_super) {
    __extends(GwRadioButtonGroup, _super);
    function GwRadioButtonGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwRadioButtonGroup.prototype.getSystemName = function () {
        return "gwRadioButtonGroup";
    };
    /**
     * Called when a button in the group is clicked. Updates the hidden check box input and artificially fires a change
     * event to trigger the usual change handling (e.g. confirmation).
     * @param radioButtonDiv the div immediately preceding the "radio button" (hidden check box); this is the div that
     *   is styled to look like a radio button
     */
    GwRadioButtonGroup.prototype.radioButtonSelect = function (radioButtonDiv) {
        if (gwUtil_1.gwUtil.hasClass(radioButtonDiv, "gw-disabled")) {
            return;
        }
        // Check if it's already checked.  If so, just kick out - i.e. no-op
        if (gwUtil_1.gwUtil.hasClass(radioButtonDiv, "gw-checked")) {
            return;
        }
        var radioButtonInput = gwUtil_1.gwUtil.getDomNodeByName(radioButtonDiv.dataset.gwGroup, radioButtonDiv.parentElement);
        if (radioButtonInput.disabled) {
            return;
        }
        radioButtonInput.checked = true;
        gwEvents_1.gwEvents.forceGlobalEvent(radioButtonInput, "change");
    };
    /**
     * Called once a change has been confirmed; updates all the "radio buttons" (actually check boxes) in the
     * group and calls the server if the button is post on change.
     * @param radioButtonWidget the outer div of the value widget enclosing the "radio button" (check box)
     */
    GwRadioButtonGroup.prototype.updateRadioGroup = function (radioButtonWidget, args) {
        var originatingRadioDiv = gwUtil_1.gwUtil.getDomNodeOrThrow("#" + radioButtonWidget.id + "_radio");
        var groupName = originatingRadioDiv.getAttribute("data-gw-group");
        if (!groupName) {
            return;
        }
        var radioButtonsInGroup = gwUtil_1.gwUtil.getDomNodesByAttr("data-gw-group", groupName);
        var confirmSpecified = this.isConfirmSpecified(radioButtonWidget);
        if (radioButtonsInGroup.length > 0) {
            gwUtil_1.gwUtil.forEach(radioButtonsInGroup, function (radioButtonDiv) {
                var radioButtonInput = gwUtil_1.gwUtil.getDomNodeByName(groupName, radioButtonDiv.parentElement);
                if (!radioButtonInput) {
                    return;
                }
                if (radioButtonDiv === originatingRadioDiv) {
                    gwUtil_1.gwUtil.addClass(radioButtonDiv, "gw-checked");
                    // The value was changed in radioButtonSelect.  However, the class was not added then as a
                    // confirmation cancel will not know to remove it.  If we've made it updateRadioGroup, we know
                    // the value has passed confirmation and the value has already been set; add the class here.
                }
                else {
                    gwUtil_1.gwUtil.removeClass(radioButtonDiv, "gw-checked");
                    radioButtonInput.checked = false;
                    if (confirmSpecified) {
                        // The logical radio button that triggered the change will alreadty have had it's confirmation value
                        // saved.  Need to explicitly save the value for the other inputs in the group (if confirm is
                        // actually specified)
                        gwConfirm_1.gwConfirm.saveConfirmedValue(radioButtonInput);
                    }
                }
            });
        }
        if (args && args.onChangeMethod) {
            gwEvents_1.gwEvents.handleOnChangeMethod(args.onChangeMethod, radioButtonWidget, { id: radioButtonWidget.id });
        }
    };
    GwRadioButtonGroup.prototype.isConfirmSpecified = function (radioButtonWidget) {
        return !!gwUtil_1.gwUtil.getSelfOrFirstParentWithAttr(radioButtonWidget, "data-gw-confirm");
    };
    return GwRadioButtonGroup;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwRadioButtonGroup = GwRadioButtonGroup;
exports.gwRadioButtonGroup = new GwRadioButtonGroup();


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gwInputs_1 = __webpack_require__(5);
var gwAjax_1 = __webpack_require__(15);
var GwApi = /** @class */ (function () {
    function GwApi() {
        /**
         * The following methods are typically invoked by content within an PCF TemplatePanel, which
         * automatically converts a PCF element reference to its client side id for the JavaScript call.
         * For example,
         *
         *   <TemplatePanel>
         *     <TemplatePanelContents>
         *       <ReferencedWidget widget="colorCode"/>
         *       <![CDATA[
         *         <script>
         *           selectColor(color) {
           *             gw.api.Util.setValue('${colorCode}', color);
           *           }
         *         </script>
         *       ...
         *       ]]>
         *     </TemplatePanelContents>
         *   </TemplatePanel>
         */
        // tslint:disable-next-line
        this.Util = {
            /**
             * Return the value of a detail view input element
             * @param {String} id full id of the input element
             * @returns {String|Array} the client side value of the input element
             */
            getValue: function (id) { return gwInputs_1.gwInputs.getValueById(id); },
            /**
             * Return the values of multiple detail view input elements
             * @param {Array} ids array of full ids of the input element
             * @returns {Array} array of the client side values of the input elements
             */
            getValues: function (ids) { return gwInputs_1.gwInputs.getValuesByIds(ids); },
            /**
             * Set the value of a detail view input element
             * @param {String} id full id of the input element
             * @param {String|Array} value new client side value of the input element
             */
            setValue: function (id, value) { return gwInputs_1.gwInputs.setValueById(id, value); },
            /**
             * Set the value of multiple detail view input elements
             * @param {Object} valuesById map of new input values, keyed by the full id of the corresponding input
             */
            setValues: function (valuesById) { return gwInputs_1.gwInputs.setValuesByIds(valuesById); }
        };
    }
    /**
     * Add an error handler that will be called if there is an error when the client makes an AJAX call to
     * the server (the majority of UI interactions cause AJAX calls). The error handler will be given three
     * arguments: the XMLHttpRequest object, an error type string and an optional HTTP error string.
     *
     * The handler should return true if it has handled the error, in which case any further error handling
     * is aborted. If it returns any other result, or throws an exception, normal error handling will continue.
     *
     * The request object can be used to examine the status code and response data. It is actually a jQuery
     * jqXHR, see the jQuery documentation for details.
     *
     * The error type string will be one of null, "timeout", "error", "abort", "parsererror" or
     * "unexpected_response". These are mainly the standard jQuery strings but "unexpected_response" is
     * Guidewire specific. It is used if the request succeeded but returned content that does not look
     * like a normal Guidewire response. This can happen, for example, if a customer uses a proxy layer
     * between the client and server, and that layer sometimes sends its own response. Note that in the
     * case of a redirect the browser will automatically redirect the AJAX request, so any redirection
     * will have already happened by the time the error handler is called.
     *
     * The HTTP error string, if present, will be the error string returned by the server when it returned
     * a non 2xx response code.
     *
     * Adding the same handler multiple times has no effect, the handler will only be added once
     *
     * @param errorHandler a that takes a request, error type and optional HTTP error string and
     *   returns a boolean
     *
     * @return the handler; may be useful when adding an anonymous
     */
    GwApi.prototype.addServerErrorHandler = function (errorHandler) {
        return gwAjax_1.gwAjax.addServerErrorHandler(errorHandler);
    };
    /**
     * Remove a previously added server error handler. The argument should be a handler previously
     * given as an argument to addServerErrorHandler. If the handler is not a, or is a
     * that was never added or has already been removed, then this method has no effect.
     */
    GwApi.prototype.removeServerErrorHandler = function (errorHandler) {
        gwAjax_1.gwAjax.removeServerErrorHandler(errorHandler);
    };
    /**
     * For use by a template panel, to call the panel's server side action handler with the given JSON
     * object as its argument. This will cause a full UI refresh.
     */
    GwApi.prototype.submitTemplateAction = function (templatePanelId, json) {
        gwUtil_1.gwUtil.setEventParam("templateJson", JSON.stringify(json));
        gwUtil_1.gwUtil.fireEvent(templatePanelId + "_templateAction");
    };
    /**
     * For use by a template panel, to call the panel's server side update handler with the given JSON
     * object as its argument. This will not block or refresh the UI, and the success
     * will be called with the result of the update handler. The optional error handler will be called
     * if the call to the server fails for any reason. The error handler should be used to do any template
     * specific clean up, but does not need to display any message; the normal server error handler will
     * be called once it returns.
     */
    GwApi.prototype.updateTemplate = function (templatePanelId, json, success, error) {
        var parameters = {
            __templatePanelId: templatePanelId,
            templateJson: JSON.stringify(json)
        };
        gwAjax_1.gwAjax.ajaxRequest(parameters, success, error);
    };
    return GwApi;
}());
exports.GwApi = GwApi;
exports.gwApi = new GwApi();
(window.gw).api = exports.gwApi;


/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwInternalTools = /** @class */ (function (_super) {
    __extends(GwInternalTools, _super);
    function GwInternalTools() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwInternalTools.prototype.getSystemName = function () {
        return "gwInternalTools";
    };
    GwInternalTools.prototype.showPcfStructure = function () {
        window.open(window.location.href + "?handlerName=locinfo", "locinfo");
    };
    GwInternalTools.prototype.showFullPcfStructure = function () {
        window.open(window.location.href + "?handlerName=fulllocinfo", "fulllocinfo");
    };
    GwInternalTools.prototype.reloadPCF = function () {
        gwUtil_1.gwUtil.fireEvent("_reloadPCF_");
    };
    /* TODO These two should go away once we support shortcuts from the server. They are registered in TabBar.pcf */
    GwInternalTools.prototype.goToInternalTools = function () {
        gwUtil_1.gwUtil.fireEvent("TabBar-InternalToolsHiddenLink_act");
    };
    GwInternalTools.prototype.goToProfiler = function () {
        gwUtil_1.gwUtil.fireEvent("TabBar-ProfilerHiddenLink_act");
    };
    GwInternalTools.prototype.editCurrentPageInStudio = function () {
        $.get(window.location.href + "?handlerName=editpcf");
    };
    return GwInternalTools;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwInternalTools = GwInternalTools;
exports.gwInternalTools = new GwInternalTools();


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwMenus_1 = __webpack_require__(26);
var gwTooltips_1 = __webpack_require__(56);
var GwRegisteredSystem_1 = __webpack_require__(2);
var GwMouse = /** @class */ (function (_super) {
    __extends(GwMouse, _super);
    function GwMouse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwMouse.prototype.getSystemName = function () {
        return "gwMouse";
    };
    /**
     * The method called by events.js for all systems that need to share the mouseenter event listener.
     * Any system needling to listen to mouseenter needs to add a complex transform in event.js, then register itself here.
     * @param node
     * @param args
     * @param e
     */
    GwMouse.prototype.enter = function (node, args, e) {
        gwMenus_1.gwMenus.openSubMenuMouseEnter(node);
        gwTooltips_1.gwTooltips.show(node, args, e);
    };
    return GwMouse;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwMouse = GwMouse;
exports.gwMouse = new GwMouse();


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file contains test utilities to help with automated testing of the client side of Pebbles e.g. via Selenium
 */
var gwEvents_1 = __webpack_require__(3);
var gwUtil_1 = __webpack_require__(0);
var plApp_1 = __webpack_require__(29);
var GwRegisteredSystem_1 = __webpack_require__(2);
var gwAjax_1 = __webpack_require__(15);
var GwTest = /** @class */ (function (_super) {
    __extends(GwTest, _super);
    function GwTest() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.readyCounter = undefined;
        _this.timeoutReadyCounter = 0;
        _this.animationFrameReadyCounter = 0;
        _this.logOptions = ["showDevLogs", "showEventLogs", "showEventTrace"];
        _this.eventFieldsToBeLogged = [
            "type",
            "key", "keyCode",
            "target", "relatedTarget",
            "shiftKey", "ctrlKey", "altKey", "metaKey", "repeat"
        ];
        _this.originalConsoleLogFunction = null;
        _this.savedLogOutput = "";
        return _this;
    }
    GwTest.prototype.getSystemName = function () {
        return "gwTest";
    };
    /**
     * Used for making sure the UI has settled from any previous action when testing the UI. Callers should first
     * call this method, which will return a non negative and non zero count value. Then they should call isUiReady
     * repeatedly with the count returned by this method as its argument, until it returns true
     * @returns {number}
     */
    GwTest.prototype.prepareForUiReady = function () {
        var _this = this;
        if (this.readyCounter === undefined) {
            this.readyCounter = 0;
        }
        var newCount = ++this.readyCounter;
        setTimeout(function () {
            _this.timeoutReadyCounter = newCount;
        }, 0);
        requestAnimationFrame(function () {
            _this.animationFrameReadyCounter = newCount;
        });
        return newCount;
    };
    /**
     * Used for making sure the UI has settled from any previous action when testing the UI. Callers should first
     * call this prepareForUiReady, which will return a non negative and non zero count value. Then they should call
     * this method repeatedly with the count returned by prepareForUiReady as its argument, until it returns true
     * @returns {boolean}
     */
    GwTest.prototype.isUiReady = function (count) {
        // The "undefined" case can happen if there has been a full page reload since prepareForUiReady was called
        return (this.readyCounter === undefined || (this.timeoutReadyCounter >= count && this.animationFrameReadyCounter >= count))
            && gwEvents_1.gwEvents.areEventsEnabled() && !gwAjax_1.gwAjax.hasPendingAjaxRequests();
    };
    GwTest.prototype.elementToString = function (el) {
        var result = "<" + el.tagName.toLowerCase();
        for (var i = 0; i < el.attributes.length; i++) {
            var attribute = el.attributes[i];
            if (attribute.specified) {
                if (attribute.value !== undefined) {
                    result += " " + attribute.name + "=\"" + attribute.value + "\"";
                }
                else {
                    result += " " + attribute.name;
                }
            }
        }
        result += ">";
        return result;
    };
    GwTest.prototype.eventToString = function (event) {
        var _this = this;
        var result = "Event: ";
        gwUtil_1.gwUtil.forEach(this.eventFieldsToBeLogged, function (field) {
            if (event[field] !== undefined) {
                result += " " + field + "=" + _this.formatLogArgument(event[field]);
            }
        });
        return result;
    };
    GwTest.prototype.formatLogArgument = function (arg) {
        if (arg instanceof HTMLElement) {
            // Custom handling for HTML elements, transform to tag format
            return this.elementToString(arg);
        }
        else if (arg === document) {
            return arg.toString();
        }
        else if (arg.type && arg.target) {
            // Events don't stringify as JSON so use a custom approach
            return this.eventToString(arg);
        }
        else if (arg instanceof Object) {
            return JSON.stringify(arg);
        }
        else {
            return "" + arg;
        }
    };
    GwTest.prototype.appendToSavedLog = function () {
        var _this = this;
        gwUtil_1.gwUtil.forEach(arguments, function (arg, key, coll, i) {
            if (i === 0) {
                _this.savedLogOutput += arg;
            }
            else {
                _this.savedLogOutput += ", " + _this.formatLogArgument(arg);
            }
        });
        this.savedLogOutput += "\n";
    };
    /**
     * Call to start recording logs to a string that can be returned by a later call to stopRecordingLogs. The
     * argument to this function is an object containing boolean fields corresponding to the application logging
     * to be turned on while logs are being recorded.
     *
     * If logs are already being recorded then calling this function will change what is being logged, according
     * to the logsToEnable argument, but will not affect what's already been recorded.
     *
     * @param logsToEnable object specifying which logging to turn on: showDevLogs, showEventLogs, showEventTrace
     */
    GwTest.prototype.startRecordingLogs = function (logsToEnable) {
        gwUtil_1.gwUtil.forEach(this.logOptions, function (option) { return plApp_1.gwApp[option] = Boolean(logsToEnable[option]); });
        if (!this.originalConsoleLogFunction) {
            this.originalConsoleLogFunction = console.log;
            window.console.log = this.appendToSavedLog.bind(this);
        }
    };
    /**
     * Call to stop recording logs and turn off any application logging turned on by startRecording logs. If logs
     * are not being recorded then calling this function still turns off any application logging but will just return
     * the empty string.
     * @returns {string} string containing all the log messages generated since startRecordingLogs was called
     */
    GwTest.prototype.stopRecordingLogs = function () {
        var result = this.savedLogOutput;
        gwUtil_1.gwUtil.forEach(this.logOptions, function (option) { return plApp_1.gwApp[option] = false; });
        if (this.originalConsoleLogFunction) {
            window.console.log = this.originalConsoleLogFunction;
            this.originalConsoleLogFunction = null;
            this.savedLogOutput = "";
        }
        return result;
    };
    return GwTest;
}(GwRegisteredSystem_1.GwRegisteredSystem));
exports.GwTest = GwTest;
exports.gwTest = new GwTest();


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gwUtil_1 = __webpack_require__(0);
var gw_1 = __webpack_require__(10);
var GwInitializableSystem_1 = __webpack_require__(4);
var plApp_1 = __webpack_require__(29);
/**
 * Websocket System
 * Any other client system, defined by its lowercase property name on the gw global object, meaning gw.currency, gw.ProgressValue etc
 * can implement a method named onWebSocket on its own object, ie: gw.currency.onWebSocket
 * and that method will be called with the data.info from the server message if the data.system name matches.
 * ie: data = {system: currency, info: blah}, so: gw.currency.websocket(data.info);
 * @type {{}}
 */
var GwWebsocket = /** @class */ (function (_super) {
    __extends(GwWebsocket, _super);
    function GwWebsocket() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sendQueue = [];
        _this.errorCount = 0;
        _this.systemNameReg = /^(WS_)|(_)/g;
        _this.socket = null;
        return _this;
    }
    GwWebsocket.prototype.getSystemName = function () {
        return "gwWebsocket";
    };
    GwWebsocket.prototype.init = function (isFullPageReload) {
        this.askServerForSocket();
    };
    GwWebsocket.prototype.getSocket = function () {
        if (this.socket === null) {
            throw new Error("asked for unavailable web socket");
        }
        return this.socket;
    };
    /**
     * @private
     * Builds the URL to make the socket upgrade request.
     * If there's an existing socket, then tests what state it's in before deciding what to do.
     */
    GwWebsocket.prototype.askServerForSocket = function () {
        if (!plApp_1.gwApp.enableWebsocket) {
            return;
        }
        if (gwUtil_1.gwUtil.onLoginPage()) {
            return;
        }
        if (this.getSocket().readyState <= 1) {
            return;
        }
        if (this.getSocket().readyState === 2) {
            this.asyncAskForSocketAndCountErrors();
            return;
        }
        var url = "ws://";
        var protocol = window.location.protocol;
        if (protocol === "https:" || protocol === "wss:") {
            url = "wss://";
        }
        url += window.location.hostname;
        if (window.location.port) {
            url += (":" + window.location.port);
        }
        if (window.location.pathname) {
            //TODO: I think this will need to become configurable
            var pathChunks = window.location.pathname.split("/");
            url += ("/" + pathChunks[1]);
        }
        url += "/websocket";
        this.socket = new WebSocket(url);
        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onmessage = this.onMessageFromServer.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        this.socket.onerror = this.onError.bind(this);
    };
    GwWebsocket.prototype.asyncAskForSocketAndCountErrors = function () {
        if (this.errorCount++ < 3) {
            setTimeout(this.askServerForSocket.bind(this), 1000);
        }
        else {
            this.errorCount = 0;
        }
    };
    GwWebsocket.prototype.clearQueue = function () {
        var _this = this;
        if (this.sendQueue.length > 0) {
            gwUtil_1.gwUtil.forEach(this.sendQueue, function (jsonData) {
                _this.getSocket().send(jsonData);
            });
        }
        this.sendQueue = [];
    };
    GwWebsocket.prototype.onOpen = function () {
        gwUtil_1.gwUtil.devlog("Socket Open");
        this.clearQueue();
    };
    GwWebsocket.prototype.onClose = function () {
        gwUtil_1.gwUtil.devlog("Socket Closed. This is normal if you are not logged in.");
        this.asyncAskForSocketAndCountErrors();
    };
    GwWebsocket.prototype.onError = function () {
        gwUtil_1.gwUtil.devlog("Socket Error");
    };
    /**
     * @private
     * parses the event data into system<String> and info<Object(Map)>
     *     then calls gw[system].onWebSocket(info)
     * @param event
     */
    GwWebsocket.prototype.onMessageFromServer = function (event) {
        var data = JSON.parse(event.data);
        var system = data.system;
        if (!system) {
            gwUtil_1.gwUtil.devlog("data object for error: ", data);
            throw new Error("No system string found on above data object.");
        }
        if (!data.info) {
            gwUtil_1.gwUtil.devlog("data object for error: ", data);
            throw new Error("No info object found on above data object.");
        }
        var info = JSON.parse(data.info);
        system = system.replace(this.systemNameReg, "").toLowerCase();
        if (system === "test" || system === "echo") {
            gwUtil_1.gwUtil.devlog("Websocket Log Message: ", info);
            return;
        }
        var systemObj = gw_1.gw.sockets[system];
        if (!gwUtil_1.gwUtil.hasValue(systemObj)) {
            throw new Error("ERROR: no system object in memory at property: " + system);
        }
        systemObj.onWebSocket(info);
    };
    GwWebsocket.prototype.encodeSystemAndInfoForTransport = function (system, info) {
        var data = {
            system: system,
            info: info
        };
        return JSON.stringify(data);
    };
    /**
     * infoMap is required to be an object (hashmap). This allows the server to generically process the info
     * and get it to the correct system far more easily.
     * @param system
     * @param infoMap
     */
    GwWebsocket.prototype.sendInfoToServer = function (system, infoMap) {
        if (!this.socket) {
            return;
        }
        var jsonData = this.encodeSystemAndInfoForTransport(system, infoMap);
        if (this.socket.readyState !== 1) {
            this.sendQueue.push(jsonData);
        }
        else {
            this.clearQueue();
            this.socket.send(jsonData);
        }
    };
    // =========== TEST AND DEV METHODS
    GwWebsocket.prototype.echo = function () {
        this.sendInfoToServer("WS_ECHO", { echobackfromserver: "echo back from server" });
    };
    return GwWebsocket;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwWebsocket = GwWebsocket;
exports.gwWebsocket = new GwWebsocket();


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GwFlagGroup_1 = __webpack_require__(234);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwFlags = /** @class */ (function (_super) {
    __extends(GwFlags, _super);
    function GwFlags() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GwFlags.prototype.getSystemName = function () {
        return "gwFlags";
    };
    GwFlags.prototype.checkAvailabilityOfAllButtons = function () {
        var alreadySeen = {};
        $("[data-gw-flags-scope]").each(function (index, element) {
            var scope = element.dataset.gwFlagsScope;
            if (alreadySeen[scope] === undefined) {
                new GwFlagGroup_1.GwFlagGroup(element.dataset.gwFlagsScope).updateButtonsAvailability();
                alreadySeen[scope] = true;
            }
        });
    };
    GwFlags.prototype.headerCheckBoxChanged = function (checkBox) {
        var group = new GwFlagGroup_1.GwFlagGroup(checkBox.dataset.gwFlagsScope);
        var checked = checkBox.checked;
        group.checkBoxes.forEach(function (c) {
            c.checked = checked;
        });
        group.updateButtonsAvailability();
    };
    GwFlags.prototype.checkBoxChanged = function (checkBox) {
        var group = new GwFlagGroup_1.GwFlagGroup(checkBox.dataset.gwFlagsScope);
        group.updateButtonsAvailability();
    };
    GwFlags.prototype.init = function () {
        this.checkAvailabilityOfAllButtons();
    };
    return GwFlags;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwFlags = GwFlags;
exports.gwFlags = new GwFlags();


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gw_1 = __webpack_require__(10);
var GwInitializableSystem_1 = __webpack_require__(4);
var GwWebsocketSystem = /** @class */ (function (_super) {
    __extends(GwWebsocketSystem, _super);
    function GwWebsocketSystem() {
        var _this = _super.call(this) || this;
        if (_this.availableToWebSocket()) {
            gw_1.gw.registerWebsocketSystem(_this);
        }
        return _this;
    }
    GwWebsocketSystem.prototype.availableToWebSocket = function () {
        return true;
    };
    return GwWebsocketSystem;
}(GwInitializableSystem_1.GwInitializableSystem));
exports.GwWebsocketSystem = GwWebsocketSystem;


/***/ })
/******/ ]);
});